
### 前言

在数论中，有一个更有趣的算法叫做快速傅里叶变换（FFT）。FFT是许多算法的关键构建块，包括大数乘法、多项式乘法以及高效生成和恢复纠错码。特别是纠错码非常灵活；除了基本用例中的容错数据存储和恢复外，纠错码还具有更高级的用例，例如在可扩展区块链和[[00-STARK的解剖-介绍]]中确保数据可用性。本文将介绍快速傅里叶变换是什么，并解释一些计算它们的较简单算法。

### 背景

原始的傅里叶变换是一种数学运算，通常被描述为在“频域”和“时域”之间转换数据。更准确地说，这意味着如果你有一段数据，运行该算法将得到一组具有不同频率和振幅的正弦波集合，如果将它们相加起来，则可以近似还原出原始数据。傅里叶变换可用于表达通过复杂轮圈绘制方形轨道以及推导出能够画出大象的一组方程等奇妙事物。

![[Pasted image 20240506100348.png]]

![[Pasted image 20240506100354.png]]

> 好吧，傅里叶变换在信号处理、量子力学和其他领域也有非常重要的应用，并且有助于推动全球经济的重要部分。但是说实话，大象更酷。

在“逆向”方向上运行傅里叶变换算法只需将正弦波相加，并在任意想要采样的点计算所得值。

我们在本文中要讨论的傅里叶变换是一种类似的算法，不同之处在于它是对有限域上的离散傅里叶变换(DFT)，而不是连续的实数或复数傅里叶变换（请参阅此处的“[模运算插曲]([STARKs, Part II: Thank Goodness It's FRI-day (eth.limo)](https://vitalik.eth.limo/general/2017/11/22/starks_part_2.html))”部分以了解有限域的概念）。[[从群环域到椭圆曲线密码学]]

不谈论在“频域”和“时域”之间的转换，这里我们将讨论两种不同的操作：多点多项式求值(在𝑁个不同的点上计算一个degree为𝑁的多项式。**给出N个不同的点，计算出一个degree为N的多项式**)及其逆运算，也就是多项式插值(给定一个degree为N的多项式在N个不同点上的计算值，恢复多项式。**给出一个degree为N的多项式上的N个点，恢复这个degree为N的多项式**)。

例如，如果我们在模5的素域(有限域)中进行操作，给定一个多项式$y = x^2 + 3 \space (\space mod \space 5 \space)$ （为了方便，我们可以按照递增顺序，写出这个多项式的系数向量 $(3, 0, 1)$）,  根据$x = (0,1,2)$计算出三个点来$y = (3,4,2)$  (注意，不是$y = (3,4,7)$， 因为该多项式在GF(5)上)， 然后，我们可以用这三个点，来恢复系数向量$(3,0,1)$。 系数向量可以本身就决定一个唯一的多项式。

有针对多点求值和插值的算法，可以在$𝑂(𝑁^2)$时间内执行任一操作。多点求值很简单：只需分别在每个点上求值多项式。以下是用Python编写的代码示例：

```python
def eval_poly_at(self, poly, x, modulus):
    y = 0
    power_of_x = 1
    for coefficient in poly:
        y += power_of_x * coefficient
        power_of_x *= x
    return y % modulus
```

算法通过循环遍历每个系数，并对每个系数执行一项操作，因此运行时间为$𝑂(𝑁)$。多点求值涉及在N个不同点上的求值，因此总运行时间为$O(N^2)$

拉格朗日插值更为复杂（在此处搜索“拉格朗日插值”以获取更详细的解释 https://blog.ethereum.org/2014/08/16/secret-sharing-erasure-coding-guide-aspiring-dropbox-decentralizer）。

基本策略的关键构建模块是对于任意域(Domain) 𝐷 和点 𝑥，我们可以构造一个多项式，对于𝑥返回1，并且对于除了𝑥以外的任何值在域𝐷中返回0。 请看以下例子，如果$D = (1,2,3,4)$ 并且$x = 1$, 那么多项式就是:

$$
y = \frac{(x - 2)(x - 3)(x - 4)}{(1 - 2)(1 - 3)(1 - 4)} = \frac{(x - 2)(x - 3)(x - 4)}{-6}
$$

你可以将1、2、3和4代入上述表达式中，并验证它在𝑥=1时返回1，在其他三种情况下返回0。

我们可以通过乘法和加法来恢复在给定域$D$上给出任意期望输出的多项式。如果我们把上述的多项式记为$P_1$ , 那么与之等价的$x = 2, x = 3, x = 4$ 的多项式就记为$P_2, P_3, P_4$ 

$$
P_2 = \frac{(x - 1)(x - 3)(x - 4)}{(2 - 1)(2 - 3)(2 - 4)} = \frac{(x - 1)(x - 3)(x - 4)}{2}
$$
你可以验证$P_2$, 在$x = 2$的时候，$P_2 = 1$。在$x \in D$且$x \neq 2$ 的时候，$P_2 = 0$。 同理可得$P_3, P_4$

$$
P_3 = \frac{(x - 1)(x - 2)(x - 4)}{(3 - 1)(3 - 2)(3 - 4)} = \frac{(x - 1)(x - 2)(x - 4)}{-2}
$$


$$
P_4 = \frac{(x - 1)(x - 2)(x - 3)}{(4 - 1)(4 - 2)(4 - 3)} = \frac{(x - 1)(x - 2)(x - 3)}{6} 
$$


好了，现在知道了这个域$D$ 上每个点构造出来的多项式的集合，也就是$P_1, P_2, P_3, P_4$ 那么我们可以根据这四个多项式构造出一个新的多项式，让这个新的多项式来适配新的点的集合，比如让新的多项式在域$D = (1,2,3,4)$上返回$(3,1,4,1)$ , 那么这个新的多项式就是$3P_1 + P_2 + 4P_3 + P_4$ 。 当然你可以让新的多项式返回你想要的$(5, 3, 1, 2)$ 那么这个新的多项式就是$5P_1 + 3P_2 + P_3 + 2P_4$。以此类推。一句话也就是，你想要返回的向量，就是这四个多项式的线性组合。

那么计算$P_i$个多项式，就需要花费$O(N^2)$ 的时间（你在整个域上构造的第一个返回0的多项式，就会花费$O(N^2)$, 然后对于每个$x_i$还要分别除以$(x - x_i)$），然后再计算它的线性组合又是另一个$O(N^2)$的复杂度，本质是$O(2N^2)$， 消除常数项就是$O(N^2)$。

快速傅里叶变换让我们能够使多点求值和插值变得更快。

### 快速傅里叶变换

使用这种更快的算法，你需要付出的代价是，你不能选择任何任意的域(Field)和任何任意的域(Domain)。而使用拉格朗日插值，你可以选择你想要的任何x坐标和y坐标，以及你想要的任何域Field（你甚至可以在普通的实数上进行操作），并且可以得到一个通过这些点的多项式。而快速傅里叶变换（FFT）则必须使用有限域(finite field)，并且域(Domain)必须是该有限域(finite field)的乘法子群（也就是说，一些“生成元”值的幂的列表）。

例如，你可以用一个mod 337的有限域，然后该有限域的乘法子群所构成的域Domain是(1,85,148,111,336,252,189,226)。以有限域中其中的一个元素85为生成元进行模幂运算$85^n \space mod \space 337$，得到这个乘法子群（你可以选择其他的元素作为生成元）。另外注意，乘法子群的大小必须是$2^n$
，这里的乘法子群大小是8。（有方法可以使它适用于形如$2^m \cdot 3^n$的数字，并且可能稍微更高一点的素数幂，但之后它会变得复杂得多，效率也低得多）。这里的乘法子群大小也可以说是子群的阶(order)。

对于mod 59的有限域，可能不能工作。以58为生成元，乘法子群为(1, 58)。那么这个乘法子群的阶为2。你可以选取其他的生成元，不过我告诉你。这个有限域的所有乘法子群的阶就是2，29，58。2太小了，所以对它不感兴趣。因子29又过大，对FFT不友好。来自大小为 $2^n$的乘法群的对称性使我们能够创建一个递归算法，该算法非常巧妙地通过较少的工作量计算出我们需要的结果。

要理解算法及其为何运行时间较短，理解递归的一般概念很重要。递归算法是一种算法，它有两种情况：一种是“基本情况”，即算法输入足够小，可以直接给出输出；另一种是“递归情况”，此时所需的计算由一些“粘合计算”加上一个或多个对更小输入使用相同算法的情况组成。例如，你可能已经看到递归算法被用于排序列表。

如果你有一个列表（例如：(1,8,7,4,5,6,3,2,9)，那么你可以使用以下步骤对其进行排序：

- 如果输入有一个元素，那么它已经“排序”好了，所以可以直接返回输入。
- 如果输入包含多个元素，那么分别对列表的前半部分和后半部分进行排序，然后将这两个已排序的子列表合并(子列表分别是A和B)。
### 快速傅里叶变换(FFTs)和二元域(Binary Field)

> 二元域就是2个元素的有限域。元素就是0和1。  GF(2)

