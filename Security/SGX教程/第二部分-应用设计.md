
> 注意，这部分的应用是在windows上设计的GUI程序，调用enclave的DLL，不适合在Linux上直接用，Linux上有Linux的so库，但是思路都是一样的。


## 密码管理器长什么样

大多数人可能对密码管理器及其作用很熟悉，但在我们进入应用设计本身的细节之前，回顾一下基本原理是一个好主意。

密码管理器的主要目标是。

- 减少终端用户需要记住的密码数量。
- 使最终用户能够创建比他们通常自己选择的更强大的密码。
- 使每个账户使用不同的密码成为现实。

对于互联网用户来说，密码管理是一个日益严重的问题，多年来许多研究都试图对这个问题进行量化。[微软在2007年发表的一项研究](http://research.microsoft.com/en-us/um/people/cormac/papers/www2007.pdf) --截至本文写作时已近十年--估计平均每个人有25个需要密码的账户。最近，在2014年，Dashlane估计他们的美国用户平均有130个账户，而他们的全球用户的账户数量平均为90多个。问题还不止于此：人们在挑选 "好 "密码方面是出了名的糟糕，经常在多个网站上重复使用同一个密码，这导致了一些惊人的攻击。这些问题归结为两个基本问题：黑客工具难以猜出的密码，人们往往难以记住，而拥有更多的密码，就必须记住哪个密码与哪个账户相关联，从而使这个问题更加复杂。

有了密码管理器，你只需要记住一个非常强大的口令，就可以进入你的密码数据库或保险库。一旦你对你的密码管理器进行了认证，你就可以查找你所存储的任何密码，并根据需要将它们复制和粘贴到认证字段。当然，密码管理器的关键漏洞是密码数据库本身：因为它包含了用户的所有密码，所以对攻击者来说是一个有吸引力的目标。为此，密码数据库采用强加密技术进行加密，用户的主要密码成为解密其中数据的手段。

我们在本教程中的目标是建立一个简单的密码管理器，提供与商业产品相同的核心功能，同时遵循良好的安全实践，并将其作为为英特尔SGX设计的学习工具。这个教程中的密码管理器，我们将其命名为 "采用英特尔®SGX的教程密码管理器"（是的，这是一个口号，但它是描述性的），并不打算像商业产品那样运作，当然也不会包含商业产品中的所有防护措施，但这种程度的细节是没有必要的。

## 基本应用需求

一些基本的应用要求将有助于缩小应用范围，这样我们就可以把重点放在英特尔SGX的集成上，而不是应用设计和开发的细枝末节。同样，我们的目标不是创造一个商业产品：采用英特尔SGX的教程密码管理器不需要在多个操作系统或所有可能的CPU架构上运行。我们所需要的只是一个合理的起点。

为此，我们的基本应用要求是。

鉴于本教程系列是关于英特尔SGX应用开发的，第一个要求可能看起来很奇怪，但现实世界的应用需要考虑传统的安装基础。对于一些应用程序来说，限制只在具有英特尔SGX能力的平台上执行可能是合适的，但对于教程中的密码管理器，我们将使用一个不太严格的方法。支持英特尔SGX的平台将获得一个加固的执行环境，但不支持的平台仍然可以运行。这种用法适合于密码管理器，用户可能需要将他或她的密码数据库与其他旧系统同步。这也是实现双代码路径的一个学习机会。

第二个要求使我们能够访问非英特尔SGX代码路径中的某些加密算法以及我们需要的一些库。64位要求通过确保对本地64位类型的访问来简化应用开发，同时也为某些针对64位代码优化的加密算法提供了性能提升。

第三项要求使我们能够访问非英特尔SGX代码路径中的RDRAND指令。这大大简化了随机数的生成，并确保了对高质量熵源的访问。支持RDSEED指令的系统也将使用该指令。(有关RDRAND和RDSEED指令的信息，请参见[《英特尔®数字随机数发生器软件实现指南》](https://www.intel.com/content/www/us/en/develop/articles/intel-digital-random-number-generator-drng-software-implementation-guide.html )）。

第四项要求使开发人员（和最终用户）所需的软件清单尽可能地简短。不需要下载和安装第三方库、框架、应用程序或实用程序。然而，这个要求有一个不幸的副作用：如果没有第三方框架，我们只有四个选项可以用来创建用户界面。这些选择是

- Win32 APIs
- 微软基础类（MFC）
- Windows Presentation Foundation (WPF)
- Windows窗体

前两个是用本地/非托管代码实现的，而后两个需要.NET*。

## UI框架

选择WPF框架

![[Pasted image 20221214102012.png]]

图1显示了当英特尔SGX应用程序从本地代码转移到C#时对其最小组件构成的影响。在完全的本地应用中，应用层可以直接与enclave DLL交互，因为enclave桥接功能可以被纳入到应用的可执行文件中。然而，在混合模式的应用程序中，enclave桥函数需要与托管代码块隔离，因为它们被要求是100%的本地代码。另一方面，C#应用程序不能与桥接函数直接交互，在C++/CLI模型中，这意味着要创建另一个中介：一个DLL，在受管的C#应用程序和本地的、enclave bridge DLL之间进行数据的调取。

## 密码口令金库的需求

密码管理器的核心是密码数据库，也就是我们所说的密码保险库。这是一个加密的文件，将保存最终用户的账户信息和密码。我们的教程应用程序的基本要求是。

- 密码金库必须是可移植的
- 金库必须时刻是被加密的
- 所有加密必须使用一个认证的加密模式

要求保险库是可移植的，这意味着我们应该能够将保险库文件复制到另一台计算机上，并且仍然能够访问其内容，无论它们是否支持英特尔SGX。换句话说，用户体验应该是一样的：密码管理器应该无缝工作（当然，只要系统满足基本的硬件和操作系统要求）。

在休息状态下加密保险库意味着保险库文件在没有被积极使用时应该被加密。至少，保险库必须在磁盘上加密（如果没有可移植性要求，我们有可能通过使用英特尔SGX的密封功能来解决加密要求），并且在内存中解密的时间不应超过必要的时间。

认证的加密提供了保证，即加密后的金库没有被修改。它还为我们提供了一个验证用户口令的方便手段：如果解密密钥不正确，在验证认证标签时，解密将失败。这样，我们就不必检查解密的数据是否正确。

### 密码口令

任何账户信息都是敏感信息，原因有很多，其中最重要的是它能告诉攻击者到底要攻击哪些登录和网站，但密码可以说是金库中最关键的一块。知道要攻击什么账户还不如根本不需要攻击它来得有吸引力。出于这个原因，我们将对存储在保险库中的密码引入额外的要求。

- 账户口令必须用金库加密
- 账户口令只可以按要求被解密

这就是嵌套式的加密。用户的每个账户的密码在存储到保险库时都是加密的，而整个保险库在写入磁盘时也是加密的。这种方法允许我们在保险库被解密后限制密码的暴露。将保险库整体解密是合理的，这样用户就可以浏览他们的账户信息，但以这种方式以明文显示他们所有的密码是不合适的。

账户密码只有在用户要求查看时才会被解密。这限制了它在内存和用户显示器上的暴露。

### 密码学算法

随着加密需求的确定，是时候确定具体的加密算法了，在这里，我们现有的应用需求对我们的选择施加了一些重大限制。教程密码管理器必须在英特尔SGX和非英特尔SGX平台上提供无缝的用户体验，而且它不允许依赖第三方库。这意味着我们必须选择一种算法，以及支持的密钥和认证标签大小，这是Windows CNG API和英特尔SGX可信加密库所共有的。实际上，这让我们只有一个选择。带有128位密钥的高级加密标准-Galois计数器模式（AES-GCM）。这可以说不是在这个应用中使用的最好的加密模式，特别是由于128位GCM的有效认证标签强度低于128位，但对于我们的目的来说，这已经足够。记住：这里的目标不是创造一个商业产品，而是为英特尔SGX开发提供一个有用的学习工具。

随着GCM的出现，还有一些其他的设计决定，即IV的长度（12字节对算法来说是最有效的）和认证标签。

- 128bit的key
- 128bit的认证tag
- 无额外的认证数据（AAD）
- 96-bit IVs

### 加密秘钥和用户认证

在选择了加密方法后，我们可以把注意力转向加密密钥和用户认证。用户将如何对密码管理器进行认证以解锁他们的保险库？

简单的方法是使用一个密钥推导函数（KDF）直接从用户的口令或密码中推导出加密密钥。但是，虽然这种简单的方法是有效的，但它确实有一个明显的缺点：如果用户改变了他或她的密码，加密密钥也会随之改变。相反，我们将遵循更普遍的做法，对加密密钥进行加密。

在这种方法中，主要的加密密钥是使用高质量的熵源随机产生的，并且它永远不会改变。用户的口令或密码被用来得出二级加密密钥，而二级密钥被用来加密主密钥(primary key)。这种方法有一些关键的优势。

- 当用户的密码或口令改变时，数据不必重新加密。
- 加密密钥永远不会改变，所以理论上可以用十六进制符号写下来，并锁在一个物理上安全的地方。因此，即使用户忘记了他或她的密码，数据仍然可以被解密。由于密钥永远不会改变，它只需要写下一次。
- 理论上，一个以上的用户可以被授予访问数据的权利。每个人都会用自己的口令对主密钥的副本进行加密。

并非所有这些都是关键的或与教程密码管理器有关的，但它仍然是一个良好的安全实践。

- 金库秘钥(主秘钥)会从RDSEED指令生成，如果是不支持RDSEED指令的系统，也可以使用seed-from-RDRAND来生成
- 金库秘钥（主秘钥，primary key）会被master key加密
- master key是用户口令通过KDF生成的
- KDF是基于SHA256的

这里的主密钥被称为金库密钥，而从用户的口令中导出的次要密钥被称为master key。用户通过输入他们的口令进行认证，而密码管理器则从口令中导出一个master key。如果主密钥成功地解密了金库密钥，那么用户就被认证了，保险库就可以被解密。如果口令不正确，金库密钥的解密就会失败，这就使得金库无法被解密。

最后一个要求，即围绕SHA-256构建KDF，来自于我们要找到一种Windows CNG API和英特尔SGX可信加密库共同的散列算法的约束。

## 账户详情

最后一个高层次的要求是在保险库中实际存储什么。在本教程中，我们将保持简单的东西。图2显示了主用户界面屏幕的早期模拟图。

- 账户名
- 账户所在的实际网址的URL
- 账户的登录ID（也就是用户名）
- 账户口令密码
- 金库保存固定数量的账号

![[Pasted image 20221214110324.png]]

最后一个要求是关于简化代码的。通过固定存储在保险库中的账户数量，我们可以更容易地为保险库的规模设置一个上限。当我们开始设计我们的enclave时，这将是很重要的。当然，现实世界中的密码管理器没有这种奢侈，但就本教程而言，这是可以承受的。