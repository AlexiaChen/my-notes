有一些不同的方法来表示一些看似简单的东西，如一组词一样简单的东西。例如，哈希或字典是我们可能熟悉的一种方式。但还有一种结构 是为了解决代表一组词的问题而创建的：Trie。术语 "trie "来自单词retrieval（检索），通常读作 "try"，以区别于其他 "树形 "结构。当然trie是一种prefix tree。

然而，Trie基本上是一个树形数据结构，但它在创建方式上有一些规则需要遵循。在如何创建和使用方面，它只是有一些规则需要遵循。

trie是一个树状的数据结构，其节点存储了字母表中的字母。通过以一种特定的方式构建节点，可以通过沿着树的分支路径遍历，从结构中检索出单词和字符串。

在计算机科学的背景下，trie是一个相对较新的东西。它们第一次在计算中被考虑是在1959年，当时一个名叫René de la Briandais的法国人建议使用它们。根据Donald Knuth在《计算机编程的艺术》中的研究:

> 用于计算机搜索的Trie内存是由René de la Briandais首先推荐的。他指出，如果我们为每个节点向量使用一个链接列表，我们可以在牺牲运行时间的情况下节省内存空间，因为向量中的大多数条目往往是空的。

使用tries作为计算结构的最初想法是，它们可以成为运行时间和内存之间的一个很好的折衷办法。但我们稍后会回到这个问题上。首先，让我们退一步，试着理解这个结构最开始到底是什么样子的。

![[Pasted image 20220925163459.png]]

我们知道，tries经常被用来表示字母表中的单词。在这里显示的插图中，我们可以开始了解这种表示方法的具体运作方式。

**每个 trie 都有一个空的根节点，与其他节点有链接（或引用）--每个可能的字母值都有一个。** 

trie的形状和结构总是一组链接的节点，连接到一个空根节点。需要注意的一个重要问题是，trie中子节点的数量完全取决于可能的值的总数。例如，如果我们表示的是英文字母，那么子节点的总数与可能的字母总数直接相关。在英语字母表中，有26个字母，所以子节点的总数将是26。

然而，想象一下，我们正在创建一个 trie 来保存Khmer（柬埔寨）字母表中的单词，这是已知最长的字母表，有 74 个字符。在这种情况下，根节点将包含74个链接到其他74个子节点。

> 一个 trie 的大小与 trie 可能代表的所有可能的值的大小直接相关。

好吧，到这里，你可以理解到了，一个 trie 可以很小，也可以很大，这取决于它包含的内容。但是，到目前为止，我们所谈到的都是根节点，它是空的。那么，如果根节点不包含不同单词的字母，那么这些字母该放在哪里呢？

答案就在根节点对其子节点的引用中。让我们仔细看看trie中的单个节点是什么样子的，希望这将开始变得更加清晰。

![[Pasted image 20220925164040.png]]

在这里显示的例子中，我们有一个trie，它有一个空的根节点，它有对子节点的引用。如果我们看一下这些子节点的横截面(cross-section)，我们会注意到trie中的一个节点只包含两个东西。

- 一个值，它可能是空的
- 一个对子节点的引用数组，所有这些子节点也可能是空的

trie中的每个节点，包括根节点本身，都只有这两个“成员字段”。当一个代表英语的 trie 被创建时，它由一个根节点组成，其值通常被设置为一个空字符串。"".

这个根节点还将有一个包含26个引用的数组，这些引用一开始都会指向空。随着 trie 的增长，这些指针开始被其他节点的引用填满，我们很快就会看到一个例子。

这些指针或引用的表示方式特别有趣。我们知道，每个节点都包含一个指向其他节点的引用/链接数组。最酷的是，我们可以使用数组的索引来找到节点的特定引用。例如，我们的根节点将持有一个索引为0到25的数组，因为字母表的26个字母有26个可能的插槽。由于字母表是按顺序排列的，我们知道对包含字母A的节点的引用将停留在索引0。

那么，一旦我们有了一个根节点，我们该从哪里着手呢？现在是时候尝试增长我们trie了!

### 试试trie的遍历

一个只有根节点的 trie 根本就没有什么意思！所以，让我们把事情弄得更复杂一些，玩一个有字的 trie。那么，让我们通过玩一个有一些单词的 trie 来使事情变得更复杂一些，好吗？

在下面显示的trie中，我们代表的是童谣，它的开头是 "Peter Piper picked peck pickled peppers "这样的话。我不会试图让你记住它的其余部分，主要是因为它很混乱，让我头疼。

![[Pasted image 20220926082043.png]]

看一下我们的 trie，我们可以看到我们有一个空的根节点，这是典型的 trie 结构。我们也有六个不同的词，我们在这个 trie 中表示。`Peter`, `piper`, `picked`, `peck`, `pickled`, 和 `peppers`。

为了使这个trie更容易看，我只画了其中实际有节点的引用；重要的是要记住，尽管这里没有说明，每个节点都有26个可能的子节点的引用。

注意这个trie有六个不同的 "分支"，每个词都有一个分支。我们还可以看到，有些词是共享父节点的。例如，`Peter`、`peck`和`peppers`这三个词的所有分支都共享`p`和`e`的节点。同样，`pick`和`pickled`这两个词的路径共享`p`、`i`、`c`和`k`的节点。

那么，如果我们想把`pecked`这个词添加到这个三角形所代表的单词列表中呢？为了做到这一点，我们需要做两件事。

- 首先，我们需要检查`pecked`这个词是否已经存在于这个 trie中。
- 接下来，如果我们已经遍历了这个词应该存在的分支，而这个词还不存在，我们就在这个词应该存在的节点的引用中插入一个值。在这种情况下，我们会在正确的引用处插入`e`和`d`。

但是我们实际上如何去检查这个词是否存在？我们又如何将这些字母插入到正确的位置？用一个小的trie作为例子更容易理解，所以让我们看看一个空的trie，并尝试在其中插入一些东西。

我们知道，我们将有一个空的根节点，它的值是""，还有一个数组，里面有26个引用，所有这些引用开始时都是空的（指向null）。比方说，我们想插入 "pie "这个词，并给它一个5的值。另一种思考方式是，我们有一个哈希值，看起来像这样。{ "pie": 5 }.

![[Pasted image 20220926082905.png]]

我们将通过key的方式工作，使用每个字母来建立我们的trie，并根据需要添加节点。

我们首先寻找`p`的指针，因为我们的键 "pie "的第一个字母是p。由于这个trie中还没有任何东西，根节点中`p`的引用将是空的。因此，我们将为`p`创建一个新的节点，根节点现在有一个包含26个空槽的数组，以及一个包含节点引用的槽（在索引15处，因为下标是从0开始）。

现在我们在索引15处有一个节点，保存着`p`的值。但是，我们的字符串是 "pie"，所以我们还没有完成。我们将对这个节点做同样的事情：检查在key的下一个字母：`i`处是否有一个空指针。由于我们在`i`处遇到了另一个空链接的引用，我们将创建另一个新节点。最后，我们到了key的最后一个字符："pie "中的`e`。我们为`e`的数组引用创建一个新的节点，在这个我们创建的第三个节点中，我们将设置我们的值：5。

在未来，如果我们想检索key "pie "的值，我们将从一个数组向下遍历到另一个数组，使用索引从节点`p`到`i`再到`e`；当我们到达索引为`e`的节点时，我们将停止遍历，并从该节点检索出值，这将是5。

![[Pasted image 20220926083547.png]]

让我们实际看看在我们新建立的trie中search会是什么样子的

在这里显示的插图中，如果我们搜索关键字 "pie"，我们会在每个节点的数组中进行遍历，看看是否有一个分支路径的值：p-i-e。如果它确实有一个值，我们可以简单地返回它。这有时被称为**search hit**，因为我们能够为key找到一个值。

但是如果我们搜索的是不存在于我们trie中的东西呢？如果我们搜索 "pi "这个词，而我们还没有把它作为一个带value的key来添加呢？那么，我们将从根节点到索引p的节点，然后我们将从p的节点到索引i的节点。在这种情况下，它没有value；它指向的是null。所以，我们可以确定，键 "pi "在我们的 trie 中不存在一个带value的字符串。这通常被称为**search miss**，因为我们找不到这个key的value。

最后，还有一个我们可能想对我们的 trie 进行的操作：删除东西！我们如何从 trie 中删除一个key和它的value？我们怎样才能从我们的 trie 结构中删除一个key和它的value呢？为了说明这一点，我在我们的 trie 中增加了一个词。我们现在有两个key "pie "和 "pies"，每个都有自己的值。假设我们想从我们的 trie 中删除key "pies"。

![[Pasted image 20220926084500.png]]

为了做到这一点，我们需要采取两个步骤。

- 首先，我们需要找到包含该key value的节点，并将其value设置为null。这意味着向下遍历并找到 "pies "这个词的最后一个字母`s`，然后将最后一个节点的值从12重置为null。
- 其次，我们需要检查该节点的引用，看看它指向其他节点的指针是否都是空的。如果所有的都是空的，这意味着在这个节点下面没有其他的词/分支，它们都可以被删除。然而，如果有其他节点的指针确实有值，我们就不想删除刚刚被我们设置为空的节点。

这最后一项检查特别重要，因为当我们删除一个词的前缀子串时，不会删除更长的字符串。但是，除了这个单一的检查之外，就没有其他的了!

### 分析一下

当我第一次学习tries的时候，它们让我想起了Hash Table。事实上，我越是了解tries以及如何建立和搜索它们，我就越想知道这两种结构之间的权衡究竟是什么。

![[Pasted image 20220926085021.png]]
事实证明，tries和哈希表都让人想起了彼此，因为它们都在实现层下使用数组。然而，哈希表使用与链表相结合的数组，而tries使用与指针/引用相结合的数组。

这两种结构之间有很多细微的差别，但是哈希表和tries之间最明显的差别是tree不需要哈希函数，因为每个key都可以按顺序（按字母顺序）表示，并且是唯一的检索，因为每个通往字符串值的分支路径对该key都是唯一的。这样做的副作用是没有碰撞需要处理，因此依靠数组的索引就足够了，而散列函数是不必要的。

然而，与Hash Table不同的是，trie的缺点是占用了大量的内存和空间的空（空）指针。我们可以想象，一个大的trie会如何开始增长，每增加一个节点，就必须初始化一个包含26个空指针的整个数组。对于较长的词，这些空引用可能永远不会被填满；例如，设想我们有一个key "Honorificabilitudinitatibus"，有一些value。这是一个超长的词，而且我们可能不会在 trie 中为这个词添加任何其他的子分支；这是为这个词的每个字母设置的一堆空指针，它们占用了空间，但并没有真正被使用。

![[Pasted image 20220926085328.png]]
但愿我们不会把 "Honorificabilitudinitatibus "这个词作为一个字符串使用。

不过，使用tries有一些很大的好处。首先，创建一个 trie 的大部分工作都发生在早期。如果我们考虑一下，这是有道理的，因为当我们第一次添加节点时，我们必须做一些繁重的工作，每次都要为数组分配内存。但是，随着 trie 规模的增长，我们每次添加一个key value所要做的工作就会减少，因为我们很可能已经初始化了节点及其值和引用。添加 "中间节点 "变得容易得多，因为trie的分支已经被建立起来了。

trie的另一个事实是，每次我们添加一个单词的字母时，我们知道我们只需要在一个节点的数组中查看26个可能的索引，因为英语字母表中只有26个可能的字母。尽管26个看起来很多，但对于我们的计算机来说，它真的没有那么多空间。然而，我们确定每个数组只包含26个引用的事实是一个巨大的好处，因为这个数字在我们trie的上下文中永远不会改变！这是一个常量。

关于这一点，让我们快速看一下trie数据结构的大O时间复杂性。创建一个 trie 的时间与 trie 所包含的词/key的数量，以及这些key可能有多长直接相关。创建一个 trie 的最坏情况下的运行时间是 m 的组合，m 是 trie 中最长的key的长度，n 是 trie 中key的总数。因此，创建一个trie的最坏情况下的运行时间是O(m\*n)。

![[Pasted image 20220926085740.png]]

搜索、插入和删除 trie 的时间复杂度取决于被搜索、插入或删除的词 a 的长度，以及总词数 n，因此这些操作的运行时间为 O(an)。当然，对于trie中最长的词，插入、搜索和删除将比trie中最短的词花费更多时间和内存。

那么，现在我们知道了tries的所有内部工作，还有一个问题有待回答：tries用在哪里？好吧，事实是它们很少被单独使用；通常，它们与其他结构结合使用，或者在一个算法的背景下使用。但是，也许最酷的例子是自动完成功能（因为是前缀树），比如在谷歌等搜索引擎中使用的自动完成功能，可以利用尝试的形式和功能。

![[Pasted image 20220926085929.png]]
现在我们知道了tries的功能，我们可以想象在搜索框中输入两个字母会如何检索出一个更大的 trie结构的子集。另一个强大的方面是，tries使得搜索一个子集的元素变得很容易，因为，类似于binary search tree，每当我们沿着树的一个分支向下遍历时，我们就减少了我们需要看的其他节点的数量！这就是tries。值得一提的是，搜索引擎可能有更多复杂的尝试，因为它们会根据某些术语的流行程度来返回这些术语，并且可能有一些额外的逻辑来确定与它们的trie结构中某些术语相关的权重。但是，在实现底层的观点来看，他们可能正在使用trie来实现这种神奇的效果。

Tries也用于匹配算法和实现诸如拼写检查器(SpellChecker)之类的东西，也可以用于实施Radix Sort的版本。

