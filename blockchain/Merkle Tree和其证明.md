
如果你想了解 BTC ETH等区块链技术你需要学习。

- 默克尔树是如何表达一个大数据集的
- 默克尔证明是如何工作的
- 为什么梅克尔树如此高效

![[Pasted image 20220915110625.png]]

Hash函数，这个不用多说，把任意长度的字符串，映射为一个定长的唯一的二进制字符串。

默克尔树使用Hash建立一个数据结构，可以快速、高效、可验证地证明一个交易被包含在一个更大的数据集中。

它们也被称为Hash Tree，是以Ralph Merkle（他在1987年提出）的名字命名的。

一个（二进制）Merkle树是一个数据结构，它首先对单个数据块应用Hash函数来创建一个哈希值列表

然后将两个哈希值合并, 并再次哈希，创建一个新的（更小的）哈希值列表。循环往复，直到有一个单一的哈希值。

![[Pasted image 20220915110946.png]]

顶部哈希值（也称为root hash或根节点）是一个单一的值，代表Merkle树的独特结构。

如果任何数据被改变，它所创建的哈希值（以及所有后续的哈希值）将是不同的，包括根节点。

![[Pasted image 20220915111237.png]]


Merkle树的输出是该组数据的唯一标识符；我们可以使用哈希树来验证一个数据集，而无需转移整个数据集

Merkle root可以在本地得出，然后在外部进行比较。如果root hash匹配，则数据集是相同的

由于Merkle树依赖于Hash函数，它们只在一个方向上运作：从原始数据建立一棵树非常容易，但要从树本身恢复数据是不可能的。

因此，Merkle root可以公开发布而不用担心暴露数据。

然而，这有一个有趣的困境：你能确认一个单独的数据(某个交易)在Merkle tree中是否存在吗？

换句话说，除了验证整个数据集之外（数据集是否有被修改），默克尔树还能做什么吗？

答案是：当然可以!

Merkle证明是通过提供特定的数据和中间哈希值来建立的，这使得验证者能够重新创建Merkle树。

如果新计算的根节点与数据集的根节点相匹配，验证者可以确定数据在数据集中（验证某个交易是否在这个Tree中）。

![[Pasted image 20220915111833.png]]

上图就是验证`data_2` 是否在这个数据集中。上面的例子是针对大小为4的数据集，在实践中，Merkle树被部署在数百万、数十亿和数万亿的数据集上。

随着数据集越来越大，Merkle树的效率也越来越高。在协调和验证方面都是如此。

 Merkle树为整个数据集提供了一个单一的、唯一的输出；一个多GB的文件可以被缩减为一行。

一个设计良好的网络可以在本地维护许多资源，并通过沟通一个极其轻量级的root hash来协调。

这种效果可以通过简单的Hash实现；一个好的Hash函数可以为每个数据集生成一个唯一的散列。

默克尔证明给了我们难以置信地高效验证包容的能力（对于真正的书呆子来说，验证复杂度扩展为O(log n)）。

默克尔树将巨大的数据集压缩成一条加密的值(root hash)。Merkle证明可以用来有效地验证数据集中存在的数据块。

