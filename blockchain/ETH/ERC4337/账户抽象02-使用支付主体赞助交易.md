
在本系列的第一部分中，我们完全复制了EOA的功能，并通过允许用户选择自定义验证逻辑来改进了它。但是，现在钱包仍然需要支付燃气费，这意味着钱包所有者需要找到一种方法在执行任何链上操作之前获取一些ETH。

如果我们希望除钱包所有者之外的其他人支付燃气费，怎么办？

有一些很好的原因希望这样做：

- 如果钱包所有者是区块链新手，则在执行链上操作之前需要获取ETH是一个巨大的障碍。  
- Dapp可能愿意为其方法支付燃气费，以便燃气费不会吓退潜在用户。  
- 赞助商可能允许钱包以除ETH以外的某些代币支付燃气费，例如使用USDC。  
- 出于隐私考虑，用户可能希望将资产从混币器中提取到一个新地址，并将燃气费用收取到与他们无关的帐户中。


## 引入支付主体(paymasters)

让我们假设我是一个Dapp，希望为其他人的Gas付款。显然，我不想在任何地方为所有人的Gas付款，因此我需要在链上放置自定义逻辑，该逻辑可以查看用户操作并决定是否要为该操作付款。

将自定义逻辑放置在链上的方法是部署一个合约，我们将其称为付款人。

它将有一个方法，该方法查看用户操作并决定是否愿意为该操作付款：

```cpp
contract Paymaster {
  function validatePaymasterOp(UserOperation op);
}
```

然后，当钱包提交操作时，他们需要指示哪个付款人（如果有）他们希望支付他们的Gas。

我们将向UserOperation添加一个新字段以指定此内容。

我们还将向用户操作添加一个字段，钱包可以使用该字段向付款人传递任意数据，以帮助它说服付款人为其成本付款。

例如，这可能是付款人所有者在链外签署的内容。

```cpp
struct UserOperation {
  // ...
  address paymaster;
  bytes paymasterData;
}
```

接下来，我们将更改入口点的`handleOps`以利用新的付款人。

其行为现在是：

对于每个操作：

- 调用sender操作的钱包上的`validateOp`
- 如果操作具有付款人地址，则调用`validatePaymasterOp`以验证该付款人
- 任何未通过验证的操作都将被丢弃
- 对于每个操作，调用`executeOp`的sender钱包，跟踪我们使用的Gas量，然后将ETH转移到执行者以支付该Gas。如果操作具有`paymasters`字段，则此ETH来自付款人。否则，它像之前一样来自钱包。

与钱包一样，付款人必须通过入口点的`deposit`方法存入他们的ETH，然后才能用于支付操作。

![[Pasted image 20230529150602.png]]

这其实很简单，对吧？

我们只需要让Bundler程序更新其模拟，然后...

## 支付主体（paymasters）质押

在之前的文章中，当钱包退款给Bundler程序时，Bundler程序使用模拟来尝试避免执行失败验证的操作，因为这意味着钱包不会支付，所以Bundler程序将承担燃气费用。

这里也出现了同样的问题：

Bundler程序希望避免提交未通过支付主验证的操作，因为支付主不会支付，Bundler程序将再次承担费用。

起初，似乎我们可以对 `validatePaymasterOp` 施加与 `validateOp` 相同的限制（即它只能访问钱包和其自己关联的存储，并且不能使用被禁止的操作码），然后Bundler程序可以在模拟钱包的 `validateOp` 的同时模拟用户操作的 `validatePaymasterOp`。

但这里有个问题。

由于存储限制，即钱包的 `validateOp` 只能访问该钱包的关联存储，我们知道，只要来自不同钱包的多个操作的验证不会相互干扰，因为它们几乎没有共同的存储。

但是，支付主的存储在使用该支付主的捆绑包中的所有操作之间共享。

这意味着一个 `validatePaymasterOp` 的操作可能会导致使用同一支付主的捆绑包中的许多其他操作的验证失败。

恶意的支付主可以利用这一点来进行拒绝服务攻击。

为了防止这种情况，我们引入了一个声誉系统。

我们将让Bundler程序跟踪每个支付主最近失败验证的频率，并通过限制或禁止使用该支付主的操作来惩罚失败频率较高的支付主。

如果恶意支付主可以创建许多自身实例（Sybil攻击），则此声誉系统将无效。因此，我们要求支付主抵押以太币。这样它就不会从拥有多个帐户中获益。

让我们向入口点添加新方法来处理抵押：

```cpp
contract EntryPoint {
  // ...

  function addStake() payable;
  function unlockStake();
  function withdrawStake(address payable destination);
}
```

一旦放入押金，就不能在调用 `unlockStake` 后的一段延迟时间内撤回。

这些新方法与先前讨论的 `deposit` 和 `withdrawTo` 不同，后者用于钱包和支付主添加将用于支付燃气费的以太币，并且可以随时立即提取。

抵押规则有一个例外：

如果支付主只访问钱包的关联存储而不是支付主自己的存储，则它不需要提供抵押，因为在这种情况下，bundle中的多个操作访问的存储不会相互重叠，原因与钱包的 `validateOp` 调用相同。

实际上，我认为声誉系统的详细规则并不那么重要。您可以在这里阅读有关它们的信息，但只要您知道bundler程序将具有一种机制来避免选择刚刚损失的支付主的操作，那就足够了。

此外，每个bundler程序都在本地跟踪声誉，因此，如果bundler程序实现认为自己可以做得更好并且不会给其他bundler程序带来麻烦，它可以自由地实现自己的声誉逻辑。

> 是的，与许多抵押方案不同，这里的押金从不被削减。它们只是一种要求潜在攻击者锁定大量资本以进行大规模攻击的方式。这种机制可以防止恶意支付主进行拒绝服务攻击或其他攻击。




## 改进：支付主体 `postOp`

## 概括： 支付主体怎样打开赞助交易
