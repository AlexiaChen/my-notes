
## 下载STM32的入门资料

[资料下载 (jiangxiekeji.com)](https://jiangxiekeji.com/download.html)

https://pan.baidu.com/s/11WKAG6GZ4f0Kg020BhIvHw?pwd=1234


这个资料里面包含江科大的STM32的视频教程的几乎所有资料了 [江协科技的个人空间_哔哩哔哩_bilibili](https://space.bilibili.com/383400717) 

## 套件介绍

![[Pasted image 20230805173656.png]]

### 面包板

![[Pasted image 20230805173735.png]]

在这个套件中，导线和一些硬件模块都是插在面包板上完成连接的

![[Pasted image 20230805174159.png]]

上图是面包板专用的跳线，可以贴在面包板上插线，适合长时间插线的情况。

![[Pasted image 20230805174307.png]]

上图中，最上面的一小扎是面包板的飞线，比较长，适合挪动，比较适合经常挪动的接线情况。下面两大扎是杜邦线，分别为公对母和母对母的，用于插接一些电路模块。

## 其他模块

![[Pasted image 20230805174518.png]]

上图就是STM32最小系统板了，中间的正方形的黑色芯片就是STM32芯片。

![[Pasted image 20230805174632.png]]

上图是0.96寸的OLED显示屏模块（4引脚）有些时候也有7引脚版本，用于显示参数和变量。

![[Pasted image 20230805174755.png]]

上图的蓝色元件是电位器，主要用来进行AD转换实验的。

![[Pasted image 20230805174925.png]]

上图就是按键，是2引脚的。可以按照下图使用(红色圆圈):

![[Pasted image 20230805175031.png]]

![[Pasted image 20230805175108.png]]

上图五颜六色的是LED灯，入门就是点灯实验了。

![[Pasted image 20230805175200.png]]

上图是STLink，用来下载程序和供电的，当然也有DAP这个与之对标。DAP与STLink的区别主要就是:

![[Pasted image 20230806101136.png]]

![[Pasted image 20230805175302.png]]

上图是USB转串口模块，用来电脑和STM32进行串口通信。

![[Pasted image 20230805175405.png]]

上图是有源蜂鸣器模块，内置震荡源，接上电就可以响。相比无源蜂鸣器需要不断翻转IO口的啊哦做方式，更方便简单。

![[Pasted image 20230805175556.png]]

四个都是一些传感器模块，电路基本是一致的。

第一个是光敏电阻模块(4引脚)，其中2个引脚是用来供电的，还有两个是光敏电阻信号的模拟输出和数字输出，可以用来进行IO口读取实验或者AD实验。

第二个是热敏电阻模块(4引脚)，同上。第三个是对射式红外模块，可以配合遮光片用来计数或者配合编码盘用来测速。第四个是反射式红外模块，寻迹车会用到。

![[Pasted image 20230805180016.png]]

上图左边是W25Q64 Flash存储模块。可以存储数据，并且是用SPI总线进行通信。主要就是为了学习SPI通信。中间的是MPU6050陀螺仪和加速度计，可以测量芯片自身的姿态，比如四轴飞行器上一般都会有这个元件，是I2C总线进行通信的。

右边这个是旋转编码器，可以输出两路正交的方波信号，用于指示旋转的方向和速度，STM32里面有专门的编码器电路，可以很方便地识别这种信号，可以当做快速的按键使用，主要还是用来模拟编码器的测速。现在的编码电机一般都会配备霍尔传感器或者光电传感器，这些传感器的输出和这种旋转编码器是一样的，所以学习旋转编码器就可以了，插在面包板上也比较方便。

![[Pasted image 20230805180715.png]]

上图左边的是直流电机，右边是TB6612电机驱动模块。可以用来进行直流电机的PWM调速实验。

![[Pasted image 20230805180824.png]]

上图是SG90舵机，也是用PWM进行控制的。输出端可以像船舵一样，根据我们给定PWM信号的占空比固定在某一个角度上。可以用来做一些机器人或者机械臂的关节。

## STM32简介

- STM32是ST公司基于ARM Cortex-M内核开发的32位微控制器(MCU)。 ST公司的中文全称是意法半导体（STMicroelectronics）  MCU就是我们常说的单片机。Cortex-M内核是ARM公司设计的，相当于芯片的CPU，STM32就是基于这个内核封装的，当然，也有其他公司基于ARM的内核封装自己的芯片。
- STM32常应用在嵌入式领域，如智能车、无人机、机器人、无线通信、物联网、工业控制、娱乐电子产品等。关于无线通信这个，可以给STM32连接上一些2.4G无线模块或者蓝牙模块，WIFI模块，ZigBee模块。这个是物联网用的多，通过STM32驱动继电器来控制220V电路的通断。关于工业控制，甚至有些PLC设备里面的主控就是STM32。
- STM32功能强大、性能优异、片上资源丰富、功耗低，是一款经典的嵌入式微控制器

![[Pasted image 20230805181816.png]]

STM32有不同系列的产品。

### ARM介绍

ARM是ARM公司也是指ARM处理器内核，它只设计内核，不生产具体的实物，半导体公司完善内核周边电路并生产芯片。授权给别人，收取授权费过日子。

![[Pasted image 20230805182433.png]]

Cortex内核有A系列，R系列，和M系列。STM32就是M系列。R和M系列用于嵌入式，R面向实时的嵌入式领域，M主要就是MCU单片机领域了。A系列用于上层应用，手机芯片就用A系列了。高通，苹果等。

### STM32F1

![[Pasted image 20230805183418.png]]

![[Pasted image 20230805183527.png]]

上图颜色深的部分是STM32内核里面的外设，其他的都是内核外的外设。学习STM32，就是学习STM32的各种外设。 ^81274b

SysTick外设，其实主要是被RTOS使用的，是可以接入操作系统的。Free RTOS这些。操作系统需要SysTick提供定时来进行任务切换的功能。

操作外设之前，都必须使能它的时钟。就需要用到RCC来完成时钟的功能。GPIO就是通用的IO口，可以用GPIO来点灯，读取按键等。AFIO是复用IO口，完成复用功能端口的重定义，还有中断端口的配置。

EXTI是外部中断，配置好外部中断后，当引脚有电平变化时，就可以触发中断，让CPU来处理任务。TIM定时器，是STM32最常用，用的最多的外设之一。

ADC是模数转换器，这个系列的STM32内置了12位的AD转换器，可以直接读取IO口的模拟电压值，无需外部连接AD芯片。

DMA，直接内存访问。帮助CPI完成大量的数据搬运工作，CPU效率太慢了。

USART是同步或者异步串口（同时支持异步和同步串口）。UART是异步串口的意思、

I2C，SPI是两种通信协议，STM32也内置了它们的控制器，可以用硬件来输出时序波形。

CAN，USB也是通信协议了。CAN一般用于汽车领域。

RTC是实时时钟，在STM32内部完成年月日，时分秒的计时功能。还可以接外部备用电池，掉电也可以正常运行。

CRC。就是软件里面的CRC校验。

PWR，电源控制。可以让芯片进入睡眠模式等状态，省电。

BKP，备份寄存器。一段存储器，当系统掉电时。可以由备用电池保持数据。

IWDG，WWDG。独立看门狗和窗口看门狗。当单片机因为电磁干扰死机，或者程序设计不合理出现死循环，看门狗可以及时复位芯片，保证系统的稳定。

DAC是数模转换器，它可以在IO口直接输出模拟电压。ADC的逆过程。

SDIO是SD卡的接口，读取SD卡

FSMC是可变静态存储控制器，可以用于扩展内存。或者配置成其他总线协议，用于某些硬件操作，

USB OTG就是USB主机接口。用OTG功能，可以让STM32作为USB主机去读取其他USB设备

### 这个STM32型号的命名规则

![[Pasted image 20230805185838.png]]

### 这个STM32型号的系统结构

![[Pasted image 20230805190326.png]]

左上角就是Cortex-M3的内核，这个内核引出了3个总线。分别是ICode指令总线，DCode数据总线，System系统总线。ICode和DCode总线主要是用来连接Flash闪存的。Flash里面存储的就是我们编写的程序。ICode总线就是用来加载我们的程序指令的。DCode总线是用来加载数据的，比如常量和调试数据这些。System总线连接到SRAM和FSMC上。AHB（先进高性能总线）系统总线主要是用来挂接主要的外设的。APB总线是先进外设总监，用于连接一般的外设。因为AHB和APB的速率等方面有差异，所以中间需要加个桥接来完成数据的转换和缓存。

然后说说DMA，DMA也是连接到总线矩阵上，间接地连接各种外设，如果有外设需要搬运数据，就会发请求给DMA，DMA获得总线控制权，访问并转运数据。整个过程不需要CPU参与。

### STM32这个型号的引脚定义



![[SK03015-STM32F103C8T6引脚定义.png]]

一般拿到一个新的芯片时，都会着重看一下其引脚定义。有经验的人，引脚定义看完，也大概知道这个芯片如何使用了。其中有FT的，代表IO口能容忍5V的电压，没有FT的，只能容忍3.3V电压。主功能就是上电后，默认的功能，一般与引脚名称相同。默认复用功能就是IO口同时连接的外设功能引脚，这个在配置IO口的时候，可以选择是通用IO口还是复用功能。重定义功能就是如果你主功能和复用功能两个功能需要同时用，那么可以用重定义功能把复用功能映射到其他端口上。

梳理下各个引脚:

1. VBAT, 备用电池供电的引脚。这个引脚可以接一个3V的电池。当系统电源断电时，备用电池可以给内部的RTC时钟和BKP备份寄存器提供电源。
2. 3个功能，PC13, 侵入检测口，RTC口。做一些安全保障的功能。比如为了安全，可以在STM32的外壳加一个防拆的触点，接上电路到这个引脚。有人强行拆开设备，那触点断开，这个引脚的电平变化，就会触发STM32的侵入信号，然后就会清空数据来保证安全。RTC引脚可以用来输出RTC校准时钟，RTC闹钟脉冲或者秒脉冲。
3.  3， 4 引脚是IO口或者接32.768KHz的RTC晶振。5， 6号引脚接系统的主晶振，一般是8MHz。可以倍频，加速速率，作为系统主时钟。
4.  7号NRST是系统复位引脚，N代表它是低电平复位的。
5. 8， 9号引脚是内部模拟部分的电源，比如ADC，RC振荡器等。VSS是负极，接GND，VDD是正极，接3.3V。
6. 10 - 19号引脚都是IO口，PA0还兼具了wakeup的功能，这个可以用来唤醒处于待机模式的STM32。
7. 20号引脚，是IO口或者BOOT1引脚，BOOT引脚是用来配置启动模式的。看图推荐使用加粗的IO口，没有加粗的IO口可能需要配置。
8. 21，22号引脚都是IO口。
9. 23，24号引脚是是系统的主电源口，VSS,VDD同上 后面的35，36号引脚和47，48号引脚都是系统的主电源口。因为STM32内部采用了分区供电的方式，所以供电接口比较多。在使用时，把VSS都接GND，VDD都接3.3V即可。
10. 25- 33号引脚都是IO口。
11. 34，37-40号引脚，都是IO口或者调试端口。调试端口就是用来调试程序或者下载程序的。这个STM32支持SWD和JTAG两种调试模式。SWD需要两根线，分别是SDWIO和SWCLK。JTAG需要5根线，分别是JTMS，JTCK, JTDI, JTDO, NJTRST。  目前教程用的是STLink调试下载程序的，STLink只支持SWD的调试模式，所以只需要占用PA13和PA14这两个IO口。在使用SWD调试时，剩下的PA15,PB3,PB4可以切换为普通的IO口使用（需要程序配置）。
12. 41-43号，45，46号引脚都是IO口
13. 44号引脚。和BOOT1一样，也是用来作为启动配置的。

这些引脚，其实都可以在STM32的数据手册里面找到。

### 启动配置

![[Pasted image 20230805194752.png]]

这就是STM32的启动配置，就是之前提到的BOOT0和BOOT1两根引脚的功能，启动配置的作用就是指定程序开始运行的位置。一般情况下，程序都是在Flash程序存储器开始执行的，但是在某些情况下，也可以让程序在别的地方开始执行。

解释一下上图，BOOT0为0，也就是接地时，BOOT1的X代表无论是BOOT1是接地还是接什么，启动模式都是在主闪存存储器的模式。最常用的模式，一般情况下都是这个配置。

当BOO1接0也就是接地，BOOT0接1也就是接3.3V电源正的意思，就是系统存储器启动，就是用来串口下载用的，系统存储器存的就是STM32中的一段bootloader程序，作用就是接收串口的数据，然后刷新到主闪存中。这样就可以使用串口下载程序了，就不用STLink或JLink了。可以用来救急。

第三种模式是，一般是程序调试用的，用的少。

最后一句话就是，设置BOOT0 BOOT1引脚后，在系统上电后，SYSCLK第四个上升沿，BOOT引脚的状态是什么值就无所谓了也没用了。也就是BOOT引脚的状态，只在开机的一小段时间内有用。

### STM32最小系统的电路原理图

![[Pasted image 20230805200010.png]]

STM32要开始使用。首先需要把电源部分和最小系统部分的电路连接好，也就是引脚图上标记为橘红色和蓝色的部分接好。

上图右边就是STM32的供电的电路图，可以看到VSS VDD1-3这3个分区供电的主电源和VSSA VDDA模拟部分电源都连接了供电引脚。可以看到与之前提到的一样，VSS接GND接地，VDD都连接了3.3V的正极。但是发现供电有一个电容，电容就像蓄水池，可以保证供电电压的稳定，一般遇到供电，都会习惯上的加上几个滤波电容。

左上角就是晶振电路，这个型号的电路中间有一个8MHz的主时钟晶振，STM32的主晶振一般都是8MHz，8MHz经过内部锁相环倍频，得到72MHz的主频。可以看到这个晶振的两根引脚，接到了STM32芯片的5，6号引脚。另外电路中也接了2个20pF的电容，作为启震电容，电容的另一端接地即可。如果你需要RTC功能的话，还需要再接一个32.768KHz的晶振，电路和这个晶振一样，只是接到3，4号引脚。OSC32的意思就是32.768KHz晶振的意思。32768是2的15次方，内部RTC电路经过2^15分频，就可以生成1秒的时间信号了。

然后看复位电路，这个电路是一个10k的电阻和0.1uF的电容组成的，给单片机提供复位信号，中间的NRST接在STM32点的7号引脚。这个复位电路在上电的瞬间，电源通过电阻开始向电容充电，此时电容的点在这一瞬间肯定是没有充满的，所以电容呈现短路状态，此时NRST是低电平。当电容逐渐充满电时，电容相当于断路，此时NRST就会被R1电阻上拉为高电平。那上电的瞬间的波形就是先低电平，然后逐渐高电平。这个低电平，就可以提供STM32的上电复位信号。因为电容充电很快，所以单片机就在上电的瞬间复位了。这个复位电路还提供一个K1的开关按键，提供一个手动复位的功能，当开关接通瞬间，电容放电，然后NRST引脚也相当于接地了，所以就相当于手动产生了一个低电平复位信号，按键松开手后，NRST又回归高电平，此时单片机就从复位状态转为工作状态。

> 现在来解释为什么在上电的一瞬间，电容在充电时会导致NRST引脚处于低电平的情况。在复位电路中，通常会使用一个电容来延迟复位信号的生成。这个电容与一个上拉电阻连接在一起，形成一个RC电路。
> 
> 当系统上电时，电源电压开始升高，而电容开始充电。在电容充电的过程中，电压会逐渐增加，但一开始电容的电压非常低。在这个时刻，电容表现出短路的特性，因为它的电阻非常低（接近于短路）。因此，当系统刚刚上电时，NRST引脚会受到电容的影响，电压被短路到地，使得NRST引脚处于低电平状态。
> 
> 随着时间的推移，电容会逐渐充电，电压也会逐渐增加。当电压达到芯片规定的复位电压阈值时，复位电路会生成一个高电平的复位信号，将NRST引脚拉高，使芯片退出复位状态，开始正常的运行。
> 
> 这种设计可以确保在系统上电时，芯片能够正确地进行初始化，并避免在不稳定的状态下启动。通过使用电容来延迟复位信号的生成，可以在系统电源稳定之前保持芯片处于复位状态，以确保正确的启动和初始化过程。

> 为什么随着电容充电，电压会逐渐升高？ 在一个直流电路中，当一个电容器连接到电源上时，电容器开始充电。在充电的过程中，电容器的电压逐渐增加，直到达到电源电压的值。

> 电容器的充电过程涉及到电荷的积累。在初始时刻，电容器是未充电状态，没有电荷积累在其两个极板上。当电源施加电压时，电荷开始从电源流向电容器。由于电容器的特性，它可以存储电荷并在极板之间建立电场。 在充电的早期阶段，电容器的电压较低，电荷的积累速度较快。随着电荷的积累，电容器的电压会逐渐增加。这是因为电容器的电压与存储在其极板上的电荷量成正比。根据电容器的性质，电容器的电压与电荷量之间的关系可以通过以下公式表示：

> V = Q / C

> 其中，V表示电容器的电压，Q表示存储在电容器极板上的电荷量，C表示电容器的电容。根据这个公式，当电荷量增加时，电容器的电压也会相应增加。

再看，我们看启动配置的电路。H1相当于开关作用，拨动这个开关，就可以让BOOT引脚选择接3.3V还是GND，在配套的最小系统板上，需要使用跳线帽来充当开关的功能。

![[Pasted image 20230805210426.png]]

![[Pasted image 20230805210446.png]]

跳线帽，插左边两个脚时，就是接GND。插右边两个脚时，就是接3.3V。这样就可以配置BOOT的高低电平了。

最后我们来看看下载端口的电路。如果是用STLink/DAP下载程序的话，需要把SWDIO和WSDCLK也就是34，37号引脚引出来方便接线。

## 软件安装

[[2-1] 软件安装_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1th411z7sn?p=3&vd_source=d0fbfa94405374eeb9a05529fc055dcc)

在第一步的下载资料后的文件夹里有Keil5 MDK安装包。

### 安装器件支持包

就理解为芯片型号的插件，为了方便适应芯片的更新速度与Keil软件的开发速度不匹配。这样更灵活。不安装支持包，在新建工程时就不会出现相应的器件型号。支持包，在配套的资料里面有离线安装包了。

### USB转串口驱动

这个插上识别不出来设备管理器会有个感叹号，视频里面有讲解，Keil目录下有驱动的安装。下载资料中也有。

### STLink驱动

这个下载资料里面也有，但是目前入门配套的是DAP，DAP是免驱动的。只要接线就可以了。

## 新建工程

需要建立Keil工程进行管理。目前STM32的开发方式有三种，基于寄存器的，基于标准库(库函数), 基于HAL库的方式。基于寄存器的方式和51单片机的开发方式有点类似。基于寄存器的方式，最底层，最直接与硬件打交道。但是STM32的结构复杂，寄存器太多，所以基于寄存器的方式，目前是不推荐的。

基于库函数的方式，是使用ST官方提供好的封装好的函数。调用函数来间接的配置寄存器。提高开发效率。开发友好，不用太直接跟最底层打交道。

基于HAL库的方式可以用图形化快速配置STM32。比较适合快速上手STM32的情况，但是隐藏了底层逻辑。推荐适合非常有经验的熟手用，因为熟手不需要了。过了学习阶段。

先找到下载资料中提供的库函数的目录把，就在固件库的STM32F10x_StdPeriph_Lib_V3.5.0中，这个目录下面的Libraries文件夹就是库函数的文件了，新建工程会用到。Project文件夹是官方提供的工程示例和模板，使用库函数的时候可以参考。Utilities是STM32官方评估板的相关例程，评估板就是官方用STM32做的一个小电路板，用来测评STM32的。然后就是Release Notes文件和使用手册了。

这里介绍一下，Libraries文件夹底下为什么有CMSIS这个名词:

> CMSIS（Cortex Microcontroller Software Interface Standard）是一种由ARM公司提供的软件开发标准，旨在为ARM Cortex-M系列处理器的软件开发提供统一的接口和一致的编程模型。
> 
> CMSIS定义了一套通用的API（Application Programming Interface），用于访问处理器内核、外设和系统资源，以简化嵌入式软件的开发过程。它提供了一些常用功能的标准接口，例如中断控制、时钟配置、外设驱动程序等，使开发人员能够更方便地编写可移植、可重用的嵌入式软件。
> 
> CMSIS的主要组成部分包括：

> 1. Cortex Microcontroller Software Interface Standard Core (CMSIS-CORE)：提供了对Cortex-M处理器内核的访问和配置的API，包括中断控制、系统控制、寄存器访问等。
> 2. Cortex Microcontroller Software Interface Standard DSP Library (CMSIS-DSP)：提供了一套用于数字信号处理（DSP）的函数库，包括滤波、变换、数学运算等常用功能
> 3. Cortex Microcontroller Software Interface Standard RTOS (CMSIS-RTOS)：定义了一套与实时操作系统（RTOS）相关的API，用于在嵌入式系统中进行任务调度、同步和通信。
> 4. Cortex Microcontroller Software Interface Standard Device (CMSIS-Driver)：提供了一套用于外设驱动程序的API，用于访问和配置处理器的外设，如UART、SPI、I2C等。
> 5. Cortex Microcontroller Software Interface Standard SVD (CMSIS-SVD)：定义了一种用于描述器件寄存器和外设的XML格式，用于生成器件的软件开发工具和调试器的支持。
> 
> Keil是一家提供嵌入式软件开发工具的公司，他们开发了一款名为Keil MDK（Microcontroller Development Kit）的集成开发环境（IDE）。Keil MDK集成了CMSIS标准，并提供了对CMSIS的支持，使开发人员能够方便地使用CMSIS提供的功能和接口进行ARM Cortex-M系列处理器的软件开发。通过使用Keil MDK和CMSIS，开发人员可以更高效地开发嵌入式应用程序，并实现更好的移植性和可重用性。

`STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm` 这个目录下的文件就是STM32程序的启动文件，STM32的程序都是从启动文件开始执行的。把这些文件拷贝到你用Keil MDK新建的STM32的工程目录下，在这个目录下新建一个Startup的文件夹，把这些文件放在这个文件夹里面。

然后回到这个目录`STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x` 可以看到有一个`stm32f10x.h` 和两个`system`开头的`.c` `.h` 的C语言文件。第一个.h文件就是STM32的外设寄存器描述文件，跟51单片机的h文件regx52.h本质是做一件事。后面两个system开头的文件就是配置STM32时钟的，STM32主频72MHz就是system文件里面的函数配置的。同样把这三个文件复制粘贴到之前提到的Startup文件夹下面。

因为STM32内核寄存器描述文件和内核外设的寄存器描述文件不是放在一起的，所以我们还要添加内核描述文件。去`STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\CoreSupport` 目录下可以看到，内核寄存器描述的C语言文件。同样复制粘贴到Startup文件夹。

然后就可以用Keil添加之前复制粘贴的文件了。把新建工程里面的SourceGroup1修改成Startup方便阅读。

![[Pasted image 20230806095246.png]]

最后添加成上图的文件。然后把这个Startup添加成h文件的搜索路径，点击keil中的魔术棒按钮，点击C/C++ 选项卡中的Include Path。

> 解释下，上图的启动文件为啥用_md.s是根据芯片的型号来选择的。
> ![[Pasted image 20230806162538.png]]

然耨在Keil中新建一个group，叫User，专门放自己写的代码，比如main.c文件。在这个User中新建一个main.c文件，保存在User文件夹下。

main.c的内容:

```c
// 基于寄存器开发的模式，只是用来演示，基于寄存器开发之需要引入下面的头文件就可以了

#include "stm32f10x.h"

int main(void) 
{
	while(1) {}
		
	
}
```

这个Demo写好了，需要把程序烧录进STM32，所以需要使用到之前提到的DAP或者STLink了:

![[Pasted image 20230806101329.png]]

我们用的DAP。DAP插上以后其实不会亮灯，只会闪烁一下，与STLink不一样。

![[Pasted image 20230806101410.png]]

我四根母对母的杜邦线接入就可以了。照着上图。颜色最好一致啊，好区分和调试。红线一般接电源3.3V供电，蓝色接地。SDWCK是黄线，SWDIO是绿线。

最后完成就可以把DAP插入到电脑的USB上，正常的话就可以看到STM32板子上的PWR电源灯常亮。另一个连接在PC13口的灯是闪烁状态，这是芯片的一个测试程序。

然后配置Keil的Debugger为CMSIS-DAP Debugger（与配置inlcudepath差不多），然后点击右边的settings按钮，把Flash download那项其中有一个reset and run打上勾。这样程序一旦烧录进去就执行了，就不用手动去触发板子上的reset按钮了。

最后重新编译程序，点击Keil中的load按钮。就烧录进去了，这时你会看到PC13口的灯已经不闪烁了。

下面会利用基于寄存器配置的方法进行一个点灯实验。需要去看STM32的参考手册(Reference manual)。而不是数据手册(datasheet)。

> 通常在芯片选型的初期，首先要看《数据手册》以评估该产品是否能够满足设计上的功能需求；在基本选定所需产品后，需要察看技术参考手册以确定各功能模块的工作模式是否符合要求；在确定选型进入编程设计阶段时，需要详细阅读技术参考手册获知各项功能的具体实现方式和寄存器的配置使用。 在设计硬件时还需参考数据手册以获得电压、电流、管脚分配、驱动能力等信息。

接下来我们用寄存器的方式来控制PC13口的灯，在此之前需要提到一点，就是我们在操作任何外设之前，都需要使能外设的时钟，使能外设的时钟是通过RCC外设进行的，去参考手册找到RCC的章节。然后找到RCC的寄存器的小章节。

```c
// 基于寄存器开发的模式，只是用来演示，基于寄存器开发之需要引入下面的头文件就可以了

#include "stm32f10x.h"

int main(void) 
{
	// eanble IOPCEN(I/O port C clock enable) 其实就是打开GPIOC的时钟  因为PC13是Port C 13号口的意思
	RCC->APB2ENR = 0x00000010;
	
	// GPIOx CRH.  这个x是可以A到E的任意一个字母  config PC13, 13号口因为数字编码较大，所以在参考手册里面找到端口配置高寄存器
	// 其中的CNF13和MODE13就是配置13号口的。CNF13 = 00 (通用推挽输出模式) MODE13 = 11 (输出模式，最大速度50MHz) 
	GPIOC->CRH = 0x00300000;
	
	// 对配置好的PC13口输出数据，所以需要用到输出寄存器，对ODR13写1，这么PC13口就是高电平，写0就是低电平。
	// 因为这个灯是低电平点亮的，所以如果给ODR全0，那么这个灯才会亮，给ODR 0x00002000 就是灭
	// GPIOC->ODR = 0x00002000;
	GPIOC->ODR = 0x00000000;
	
	while(1) {}
	
}

```

接下来用库函数点灯。同样在工程目录下新建一个Library文件夹，然后去`STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver` 目录下把inc和src文件夹底下的库函数的源码文件拷贝到Library文件夹下面。然后添加进Keil工程作为一个新的Group叫Library。

到现在还不能直接用，现在去`STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template` 下面有两个it结尾的文件，以conf结尾的h文件，是用来配置库函数头文件的包含关系的。两个it结尾的文件是用来存放中断函数的。把这三个文件复制粘贴到工程目录下的User文件夹里面，添加进工程的User group中。

最后把`system_stm32f10x.h`中的

```c
#ifdef USE_STDPERIPH_DRIVER
  #include "stm32f10x_conf.h"
#endif
```

里面这个USE_STDPERIPH_DRIVER 宏拷贝到Keil IDE里面的predefile macro中，就是魔术棒里面的c/C++选项卡中的preprocessor define里面。如果用过VS的人，应该清楚是怎么回事，一样的道理。最后还要把头文件的目录添加上，因为在User和Library新加了h文件。

这样才可以使用标准外设的库函数。

下面是用库函数的完整代码，并且与寄存器的方式并存使用，让PC13口的灯闪烁:

```c
// 基于寄存器开发的模式，只是用来演示，基于寄存器开发之需要引入下面的头文件就可以了

#include "stm32f10x.h"

#define TRUE 1
#define FALSE 0

typedef int BOOL;


static void infinite_loop()
{
	while(1);
}

static void delay(uint32_t milliseconds)
{
    // 假设系统时钟频率为72MHz
    // 根据系统时钟频率和延迟时间计算出需要循环的次数
    uint32_t i;
    for(i = 0; i < (milliseconds * 72000); i++);
}


static void turn_pc13_light_based_on_register(BOOL enable)
{
	// eanble IOPCEN(I/O port C clock enable) 其实就是打开GPIOC的时钟  因为PC13是Port C 13号口的意思
	RCC->APB2ENR = 0x00000010;
	
	// GPIOx CRH.  这个x是可以A到E的任意一个字母  config PC13, 13号口因为数字编码较大，所以在参考手册里面找到端口配置高寄存器
	// 其中的CNF13和MODE13就是配置13号口的。CNF13 = 00 (通用推挽输出模式) MODE13 = 11 (输出模式，最大速度50MHz) 
	GPIOC->CRH = 0x00300000;
	
	// 对配置好的PC13口输出数据，所以需要用到输出寄存器，对ODR13写1，这么PC13口就是高电平，写0就是低电平。
	// 因为这个灯是低电平点亮的，所以如果给ODR全0，那么这个灯才会亮，给ODR 0x00002000 就是灭
	const int PC13_LIGHT_ON  = 0x00000000;
	const int PC13_LIGHT_OFF = 0x00002000;
	if (enable)
	{
		GPIOC->ODR = PC13_LIGHT_ON;
	}
	else
	{
		GPIOC->ODR = PC13_LIGHT_OFF;
	}
	
}

static void turn_pc13_light_based_on_std(BOOL enable)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStruct;
	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_13;
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOC, &GPIO_InitStruct);
	
	if (enable)
	{
		// Reset是置低电平
		GPIO_ResetBits(GPIOC, GPIO_Pin_13);
	}
	else
	{
		// Set是置高电平
		GPIO_SetBits(GPIOC, GPIO_Pin_13);
	}
}

int main(void) 
{
	for (int i = 0; i < 10; ++i)
	{
		turn_pc13_light_based_on_register(TRUE);
		delay(100);
	    turn_pc13_light_based_on_std(FALSE);
		delay(100);
	}
	infinite_loop();
}
```


最好放一张工程原理图:

![[Pasted image 20230806162819.png]]


