# Phala网络:一个基于polkadot的安全的去中心化云计算网络

更新时间: 2022.03.07

## 1. 介绍

现在，无许可区块链的安全性通常是通过状态复制和共识算法来保证的。  虽然这种方法对区块链很好，但这也意味着区块链上的所有内容都是公开的。这就带来了一个问题：机密信息不能由区块链处理。缺乏保密性大大限制了区块链在处理敏感业务和用户数据方面的应用。处理敏感的商业和用户数据。例如，股票交易员通常不希望透露他们的职位或订单历史。更重要的是，所有的  
以太坊上所有与隐私有关的DApps都不能遵守《通用数据保护条例》，因此会被欧盟阻止  
  
现在，已经提出了几种方法来解决隐私问题。Monero和Zcash通过环形签名和zk-SNARK技术实现了私有交易[13]，但他们的方法只能为加密货币提供隐私并很难扩展到通用的智能合约。 MPC（多方计算）在理论上可以运行任意程序而不向参与者透露中间状态，其代价是$10^6$  倍的开销[9]，这使得它在现实世界的用例中不切实际。

一种新的方法是利用特殊的硬件，即可信的执行环境（TEE）[8]。TEE是一些处理器中的一个特殊区域，它提供了一个更高层次的安全，包括隔离执行、代码集成和状态保密。纯正的TEE作为一个计算平台有几个不足之处，例如如缺乏一个可靠的时间源和可用性保证。

Ekiden[9]通过引入TEE-区块链混合架构解决了这些问题并实现了一个高性能的保密智能合约 
平台。然而，Ekiden中的合约是孤立的，这意味着这些合约不能相互操作，更不用说与外部区块链了互操作了。互操作能力是现代智能合约的一个关键因素。例如，以太坊最顶尖的10个合约中的8个是世界上最大的智能合约平台。函数调用或资金转移到至少一个其他合约上。如果没有互操作性，合约就不能读取信息或调用其他智能合约的功能，更重要的是，使用自定义的代币，这是一个智能合约中使用最广泛的场景之一。如果所欲合约不能访问代币合约，那么很多功能是无法实现的。

![[Pasted image 20220919083651.png]]
在本论文中，我们提出了Phala网络，一个新颖的跨链互操作的保密的智能合约网络，作为一个Polkadot parachain[10]。我们引入了一个Event Sourcing/CQRS[4, 3] 的架构到TEE-区块链混合系统中，以实现保密智能合约的跨合约和跨链互操作性。我们进一步去设计了一个Libra-Polkadot桥，以通过保密合约实现保密的Libra Coin。


## 2. 背景

### 2.1 Intel SGX: 一个TEE实现

Intel SGX[6]是TEE的一个流行的实现。它在一个特殊的"Enclave"里面运行代码，这样代码的执行是确定的，也就是说，不受其他进程或底层操作系统的影响。并且中间状态不被泄露。在一个正确设置的系统中，Intel SGX可以防御来自操作系统层和硬件层的攻击。

为了确保在 "Enclave "内按预期完成执行，可以根据一个称为 "Remote Attestation "的协议生成一个证明。硬件可以根据硬件的详情，固件，在"Enclave"内执行的代码和其他的用户自定义数据成一个 *attestation quote* （证明凭证）的证明。凭证是由可信硬件在生产过程中用凭据(credential)嵌入并签署的。

接下来，生成的attestation quote被发送到Intel remote attestation service上。如果签名凭证(credential)有效，英特尔将签署该凭证(quote)。由于每个凭证(credential)都与Intel CPU单元唯一绑定，假的attestation quote将永远无法通过remote attestation service的检查。

最后，由Intel签署的attestation quote作为成功执行的证明。它证明了特定的代码已经在SGX enclave 内运行并产生了特定的输出。这意味着执行的保密性和正确性。该证明可以由任何拥有通用硬件的人发布和验证。就是这个最终由Intel签署的这个quote，可以被在任何人的通用计算机上验证并分享给其他人验证。

Intel SGX和remote attestation协议是保密合约的基础。除了Intel SGX，还有其他的实现方式诸如AMD SEV[1]和ARM TrustZone[2]。

### 2.2 Event Sourcing和CQRS

Event Sourcing是一种软件设计模式。相比存储数据的最新状态，它而是将导致状态转换的事件记录在一个append-only的日志中。Event是有时间戳的，可以通过重放来重建任何时候的状态。由于事件是有时间戳的，系统的状态是确定的。命令查询责任隔离（CQRS）是一种设计模式。
它将读操作和写操作分开处理。在一个CQRS和Event Sourcing相结合的系统中，写操作被记录为Event，而读操作可以由当前的状态视图提供服务。这种模式使系统易于扩展并避免冲突。

为了native CPU的性能和更好的安全性，每个保密合约作为一个执行者只被绑定在一个或一小部分TEEs上。通过这种设计，合约状态是相互隔离的，没有一致性保证。它 成为跨合约甚至是跨链互操作性的麻烦。

虽然很难在状态上保持强一致性，但合约仍然可以在状态转换是确定的前提下通过相互传递消息来进行沟通。在一个Event Sourcing/CQRS的设计中，命令(commands) 可以由用户或合约发起，并在区块链上严格标明时间。它保证了全局状态是确定的，因此实现了合约之间的消息传递。消息传递是实现更高级别的互操作性（如合约调用和代币转账）的一种基本手段。为了提高性能，只读操作没有时间戳。

## 3. 保密合约

Phala网络旨在建立一个通用的隐私保护平台而且还有图灵完备的智能合约。这样一个平台的基本要求可以是以下来定义。

- 保密性。与现有智能合约的区块链不同，Phala网络避免了任何输入、输出或中间状态的泄漏。
只有授权了的查询请求给合约，合约才会应答。
- 代码的完整性。任何人都可以验证一个输出是由一个特定的智能合约在区块链上发布的输出。
- 状态一致性。任何人都可以验证一个执行发生在区块链上的某个高度，这意味着执行的输出受制于链在某高度下的状态。
- 可用性。不能有单点故障，如矿工的通讯中断。
- 互操作性。合约之间可以互操作，也可以与外部区块链进行跨链调用。

现有的TEE解决方案，如Intel SGX，只能防止在孤立的程序执行过程中泄漏敏感信息，并且不能保证输入数据的可用性或验证。因此，它需要一个精心设计的基础设施，将TEE整合到区块链中，以满足 上述要求。

我们将介绍Phala网络的设计以及它如何满足上述要求。

### 3.1 保密合约的抽象

一个典型的智能合约可以被视为一个由当前状态$s_n$的状态机和一个状态转换函数$f$，它接受输入事件$e_n$，和上一个状态 $s_{n-1}$来产生最新的状态$s_n$。

$$
s_n = f(s_{n-1},e_n)
$$
由于状态转换过程发生在 "enclave "内部，所以它的任何中间状态对外界来说都是不可见的。我们可以进一步加密达到的状态(最终状态，也就是输出)和输入事件，以防止攻击者通过事件重放推断出合约的内部状态。

设$cs_n$为$s_n$的密文(cipher)，$ce_n$为$e_n$的密文，则保密合约的状态转换函数可表示为$p$

$$
\begin{align}
cs_n = p(cs_{n-1}, ce_n) \\
p(cs_{n-1},ce_n)= Enc(f(Dec(cs_{n-1}, Dec(ce_n))))
\end{align}
$$

其中$Enc$和$Dec$可以是精心选择的对称加密算法和解密算法，但算法必须符合合约规定。

与现有的智能合约不同，保密合约在默认情况下不会将任何信息暴露在enclave之外。
为了回答授权查询。我们引入了一个查询函数$q$，它接收当前的加密状态$cs_n$，
查询参数$paras$和用户的身份$I$（通常是一个pubkey）作为输入，并且返回响应$r$。

$$
r = q(cs_n, paras, I)
$$

保密合约必须首先验证用户的身份并然后对她的查询做出回应。除了来自用户的查询之外，合约还可以接受一个产生副作用的特殊查询。这些副作用包括矿工可以将出口数据(engressing data)发布到区块链上。（相当于这个特殊查询不是幂等的）。

![[Pasted image 20220919095423.png]]


## 4. 协议

如图2所示，协议中涉及几个角色。  
  
- 用户。用户调用、查询和部署智能合约。用户与用户通过区块链和workder节点与智能合约互动。用户他们可以通过运行一个轻量级的客户端或完整的节点(full node)来独立验证区块链以及区块链上的加密证据。用户需要使用保密合约不需要有特殊的硬件，即TEE。  
  
- Worker节点。workder节点在兼容TEE的硬件中运行保密合约。 workder节点是链外的。在每个节点中，一个特殊的程序称为*pRuntime*的特殊程序被部署到enclave。该运行时有一个内置的虚拟机来 运行合约。它还与区块链合作，以支持合约的整个生命周期中。worker节点可以进一步分为三个角色。  
  
    -  创世节点。创世节点帮助启动网络和设置加密配置。有且只有一个Genesis节点，它在Phala网络启动后被销毁。  
    - 守门员(Gatekeepers)。守门员管理秘密以确保网络的可用性和网络的安全性。守门人是在区块链上动态选出来的  区块链上动态选出，他们用大量的Phala代币做staking质押。他们因在线而被奖励，并在有不当行为的情况下被惩罚，因为有 一定数量的正常的守门员在任何时间里都在运行
- Remote Attestation Service。远程认证服务是一项公共服务。它可以验证workder节点是否正确部署了*pRuntime*。该服务产生的加密证据可以证明某个输出是由TEE内运行的*pRuntime*产生的。IAS[5]是Intel SGX的Remote Attestation Service的实现。
- 区块链。区块链是Phala网络的骨干。它存储了workder节点的身份、已发布的保密合约、已加密的合约状态，以及来自用户和其他外部区块链的调用交易。当插入Polkadot parachain插槽时，它能够通过Polkadot中继链与其他区块链进行互操作。
  

### 4.1 系统设计

我们首先提出了一个重要的属性，它是以下系统设计的基础。  
  
**所有的worker节点都是非拜占庭节点。** 如上图所示，每个workder节点在其TEE中运行一个特殊的程序*pRuntime*。pRuntime，顾名思义，它是保密合约的运行环境。它为合约暴露出一组API，以访问状态资源，管理 与区块链的连接，并安全地回答用户的查询。*pRuntime* 实现了本文中描述的Phala网络协议。由于*pRuntime*的完整性是由remote attestation service保证的，这种等价交换保证了不会有拜占庭错误，除非TEE和pRuntime都被破坏，否则不可能发生拜占庭错误。 而敌对的workder节点只能发起一个DoS攻击，这可以通过我们的响应性监测协议进一步检测出来。  
  
在我们的系统中，执行者(executor)，即矿工，是无状态的，这意味着  保密合约的最新状态必须通过顺序执行所有的区块链上的输入事件，或从缓存的合约状态和之后的Events中获取。 所有的输入都必须首先发布到区块链上，以这种方式，区块链就成了合约输入的典型来源，这就是Event Sourcing模式。我们进一步利用了CQRS的理念运用在协议的设计中，我们进一步利用了CQRS的理念来加速用户对合约的查询。  

*pRuntime*在其生命周期中维护一组秘密。合约状态通过一个对称秘钥在区块链上被加密和被保存为检查点。每个pRuntime在区块链上注册其身份，并通过非对称密钥与用户建立安全连接。
与用户的非对称密钥对建立安全连接。由于每个pRuntime都在区块链上注册了自己，任何用户都可以验证其身份。这些秘密永远不会泄漏到pRuntime之外。

![[Pasted image 20220919103032.png]]


### 4.2 节点注册

所有的workder节点都需要在区块链上注册，然后才能参与挖矿或守门员选举。

Remote attestation提供了一个构建模块，以验证enclave内特定代码的执行和输出。然而，在每次执行时运行这种attestation证明的时间效率很低。在Phala网络中，我们采用了一个更好的协议。attestation在注册时测量pRuntime实例和生成的唯一ID，而不是在每次执行期间测量，通过这种方式。单一的attestation就比较高效了，就足以确保pRuntime的未来行为。

- workder节点$n$的主机程序（即Miner或Gatekeeper）调用 **pRuntime.GetIdentity**来生成一个密钥对作为身份$I_n(pk_n，sk_n）$。$sk_n$被保存在enclave内，$pk_n$被透露给主机。这里的主机应该就是substrate的非runtime部分了。
-  主机调用**pRuntime.GetRAQuote**来生成一个Remote Attestation quote(远程证明凭据) $q$，其中包含对$pk_n$的承诺(commitment)，以及其他必要的元数据。
- 主机将$q$提交给远程认证服务（Remote Attestaion Service），并得到签名的凭据(Quote) $q_{signed}$
- 主机将$（q_{signed},pk_n）$提交给区块链。然后，区块链接受这些信息并验证后就把其保存起来。

注册的pRuntime实例是非拜占庭式的。pRuntime的实例和生成的身份是由attestation来衡量的。这意味着 pRuntime在TEE中运行，身份ID是安全生成的。由于 私钥对任何一方都是未知的，所以没有人可以伪装成一个已注册的pRuntime。

有了注册的身份，请求者和目标pRuntime之间的类似于TLS的通道就可以被建立。在区块链上公布的身份ID来作为PKI来避免MitM攻击。由于pRuntime是非拜占庭式的，在这样一个通信信道中，pRuntime就无需remote attestation的情况下可被信任。这个技巧就提升了代码运行性的执行效率和灵活性。

元数据包含其他必要的信息，例如，节点网络的的endpoint，如libp2p multiaddrs。注册有一个失效过期日期，以防止在未来发现漏洞。workder节点可以通过重新重做注册过程来更新它，包括生成一个新的身份并做远程认证(remote attestation)。

### 4.3 状态加密

保密合约在pRuntime上运行，状态被持久化在区块链上，以确保其可用性。由于区块链上的信息是 公开的，所以保存的状态必须是加密的。在Phala网络中，每个合约$(c_i)$都与一个对称密钥相关联，称为合约密钥$（k_{c_i}）$。  
  
合约密钥由pRuntime内的守门员生成。要运行一个合约，注册的矿工应该从守门员那里获得相应的合约密钥。  矿工读取最新的合约状态，并在初始化时用合约密钥解密。在初始化过程中用合约密钥解密。然后，更新的状态会被加密并在未来保存到区块链上。守门人持有合约密钥 作为其状态的一部分。守门人之间共享一个对称的密钥，称为根密钥 (root key) $(k_r)$. 守门人的状态也被加密并保存在区块链上，就像矿工。所有的密钥都由pRuntime使用并保存在pRuntime中。  
  
密钥管理的细节将在下面的小节中讨论。我们还提出了一些改进措施，包括密钥旋转（在 "密钥旋转 "小节）和分布式密钥生成（DKG）方案（在 "开放性问题 "中）。 

### 4.4 区块链启动

在区块链启动阶段，区块链将加载初始分配的原生代币，并开始选举守门员。一个创世节点协助 
区块链的启动。

1. 在创世区块之前，创世节点运行*pRuntime.Bootstrap*以 生成一个密钥对作为节点的身份ID，和一个对称密钥。即Genesis Identity $I_g,(pk_g,,sk_g)$和Genesis Root Key $k_r^{(0)}$。运行时揭示$pk_g$，但 
但保留$sk_g$和$k_r^{(0)}$的隐私。

2. 用$pk_g$启动区块链。 在这个阶段，$pk_g$被发布在创世区块中,并用于其他worker节点与创世节点建立安全通道。$k_r^{(0)}$ 被保存在创世节点内，用于存储运行网络所需的秘密。最初的原生代币分配被加载到创世区块中。

3. 区块链在创世区块之后处于预启动阶段。治理模块已启用，但其他模块，包括保密合约仍处于禁用状态，直到选出守门人。  

4. 想参与守门人选举的worker节点可以按照 遵循节点注册计划，在区块链上注册他们的身份。  
然后，$n_{gatekeepers}$个门卫（一个在几十到几百之间的链上参数）将在预启动阶段被选出。这可以  
这可以通过Polkadot式的NPoS验证人选举在链上完成（详见附录二的细节）。  
  
5. 当选举完成后，守门人将向创世节点通过TLS连接发送一个要$k_r^{(0)}$的请求。创世节点只响应来自所选网守的请求。守门人确认他们在区块链上的准备情况。  
  
6. 当创世节点从区块链上看到门卫的确认时，它就会退役并自我销毁。如果有不响应的  
守门人，选举将过期并在截止日期后重新开始。  

到目前为止，守门员的身份已经在区块链上注册，$k_r^{(0)}$已被分发到所有守门人的runtime上。然后，$k_r^{(0)}$将被用于未来部署节点和合约。

周期性的密钥旋转对于前向保密是必要的。根密钥在era $n$表示为$k_r^{(n)}$，我们将在 "密钥旋转 "小节中讨论其细节。

### 4.5 部署Worker节点

矿工和守门员都必须遵循 "节点注册 "计划来加入网络。该协议确保节点是非拜占庭式的。所以 
我们只考虑响应性故障。为了确保服务质量，所有worker节点必须持有一定数量的Phala代币，一旦不能满足响应性要求，就会被惩罚。我们将在 "响应性监控 "一节中讨论关于押注staking和监控的细节。

由于守门员存储了根密钥并需要始终在线，他们必须满足更高的标准，需要押注更大的金额。他们得到的奖励让他们保持在线，否则就会被惩罚下线。

### 4.6 部署合约

编译后的合约的字节码被发布在区块链上，然后由用户指定的矿工加载到其pRuntime中。守门员们为每个新发布的合约生成一个对称的加密密钥。该密钥被共享给与相应的pRuntime，用于状态加密。更具体地说。

1. 开发者将合约$c_i$发布到区块链上
2. 一旦守门员们注意到$c_i$的发布，他们就会生成一个相应的合约密钥$k_{c_i}$用于合约状态的加密。
3. 守门人们将$k_{c_i}$保存在区块链上，作为链状态的一部分。用根密钥$k_r^{(n)}$对状态进行加密。
4. 开发者找到一个可用的矿工来加载合约。开发者可以运行他的矿工，这样就不需要额外的费用，或者从资源市场上租赁一个矿工（更多细节见 "经济设计paper"）。
5. 矿工的runtime通过安全连接，连接到守门员并通过*pRuntime.GetContractKey*询问合约秘钥$k_{c_i}$。

矿工的pRuntime将使用合约秘钥$k_{c_i}$来加密合约状态，并定期保存到区块链上。我们将在 "执行合约 "和 "状态恢复 "部分讨论详细情况。

### 4.7 秘钥旋转(轮换)

每个era（时代）的守门人们都是根据选举规则（附录二）重新选举的。在轮换守门员们的同时，根钥匙也被轮换。让$G_{n-1}$和$G_n$是时代$n$选举前和选举后的守门员集合。根秘钥将被轮换如下:

1. $G_n$由治理模块在每个时代（era）的最后一个区块在链上选出。同时，两个领导者$l_{n-1} \in G_{n-1}$和$l_{n} \in G_{n}$被随机选出。这个随机性来自于区块中的随机信标。
2.  矿工们和守门员们之间的任何通信都被阻止，直到密钥旋转完成。
3. 一旦该区块被最终确定，$l_{n-1}$和$l_n$合作生成下一个根密钥$k_r^{(n)}$ 是通过一个类似DH的密钥交换协议加入盐生成的。$l_{n-1}$对守门员的状态进行解密，然后用$k_r^{(n)}$ 重新加密，并将其保存到区块链上。$l_n$广播$k_r^{(n)}$到$G_n$中的其他成员，通过一个安全的通讯信道。当$G_n$成员收到$k_r^{(n)}$时，他们会在链上确认准备好了。
4. 一旦所有$G_n$成员确认，并且$l_{n-1}$已经更新了守门员的状态。区块链将产生一个 "密钥轮换就绪 "事件,这样，矿工就可以恢复与新守门人的通信。同时，不在$G_n$中的$G_{n-1}$成员将注意到该事件，并进行自我销毁。
5. 钥匙轮换过程有一个过期时间，以防止不响应。在这种情况下，没有反应的守门员将被惩罚砍掉，而秘钥轮换过程应该重新开始。
.
![[Pasted image 20220919163445.png]]
所有链外的密钥管理和加密都由门卫们的pRuntime 来处理的。

密钥轮换协议从一个时代(era)的第一个区块开始，在链上的最后确认后结束。在这段时间内，没有新的合约可以部署到矿工，因为矿工和守门员之间的通信被阻止。然而，与一个时代(era)的长度相比，该协议所造成的延迟是微不足道的。在最好的情况下，延迟是2个往返的 
时间（两次链上确认）。

合约密钥可以以更简单的方式进行轮换。矿工生成一个新的合约密钥，并用新的密钥重新加密状态。然后，它可以用安全通道将新的合约密钥发送到守门员，并将状态保存到区块链上。这两个动作结合在一个交易中，使之成为原子化。

根密钥和合约密钥的轮换确保了信任状态的前向保密性（对于守门员状态和合约状态）。过时数据的密钥在轮换完成后被销毁。

### 4.8 执行合约

我们采用一个Event Sourcing/CQRS风格的架构来执行合约。读取查询和写入命令是分开的。

合约状态由写命令决定，写命令有多个来源：用户调用、区块链事件和来自中继链的输入性消息(ingressive message)。在一个纯正的设计中，我们要求所有的写命令都要在区块链上显式记录。
这些命令由Ingressive Events到pRuntime表示。由于区块链上的事件是自然而然地有序的，所以区块链 就成为事件的典型来源。

1. 矿工（主机）通过调用*pRuntime.SyncBlockchain*将输入的事件输入到runtime。传入的事件与加密证据配对，并由pRuntime内部的轻量级Substrate客户端验证。它确保了传入事件的完整性。
2. rungtime挑选出针对合约部署的事件和合约的通讯（调用）事件。合约的执行会产生一个关于`Chainstate`的视图，即`Chainview`
3. 在任何时候，用户都可以通过*pRuntime.Query*来查询*Chainview*。caller的身份会被附加到查询中，以便合约可以根据其定制的授权策略决定决定是否回答。对查询的响应包括查询结果，以及对当前区块链状态（如高度）和合约状态的承诺。换句话说，所有的输出都受制于某一刻区块链的状态。
4. runtime也会产生各种副作用，可以通过*pRuntime.DumpSideEffect*访问。一种基本的副作用是由pRuntime定期产生的加密的合约状态更新。有了完整的合约状态，一个新的矿工不需要通过重放整个区块链历史来同步数据。另一种副作用是针对其他合约或区块链的出口信息(outgoing messages) 即Egressing Events。发布消息到外部实体的能力是合约互操作性的构建块。提交的事件最终会被派发到目标合约或其他区块链上。派发到其他链上是通过Polkadot ICMP (Interchain Message Passing，https://research.web3.foundation/en/latest/polkadot/ICMP/）。矿工（主机）负责将副作用发布到区块链上。

为了调用一个合约，用户需要与运行合约的矿工生成一个共享密匙。这可以通过一个非交互式的Diffie- Hellman密钥交换方案来完成，该方案使用用户的私钥和矿工的注册的公共密钥[12]来构建。该密钥被用于未来的通信，然后用户可以将加密的payload提交给区块链。调用事件一旦到达矿工节点，就由pRuntime处理。  
  
由于调用payloads被包含在一个区块中，区块链自然是事件的典型来源。所有由用户发起的合约调用。  智能合约和其他区块链发起的所有合约都有时间戳，并被执行者平等对待。  因此，它为合约的互操作性做了一个统一的接口。  
  
该架构的缺点是，命令的确认发生在区块确认之后。区块链的性能成为合约调用的瓶颈。然而，只读的查询直接进入runtime，其性能不受区块链的限制。  这是有可能的，因为查询不会修改合约状态。  
  
矿工负责确保pRuntime和区块链之间的通信。  需要一个监控方案来确保连接性。在最坏的情况下（例如矿工关闭），合约的执行可以由另一个矿工继续。  
  

### 4.9 状态恢复

一个矿工就足以高效运行一个合约。尽管矿工们被激励着去长期运行合约，但矿工仍然可能因为网络或电力中断而变得没有反应。在这种情况下，另一个矿工可以恢复 从区块链上恢复保存的状态，并恢复执行。

正如在 "执行合约 "一节中提到的，pRuntime产生的一个副作用之一是周期性的合约状态更新。转储的状态被$k_{c_i}$加密，并存储在区块链上。在矿工不可用的情况下。新矿工可以从区块链上恢复最新的转储合约状态 并用$k_{c_i}$解密它。在恢复状态后，runtime可以进一步 重放区块链上的其余事件，直到到达链端（chain tip）chain tip一般表示区块链的最高高度，当前的最长链，最新的区块高度。

### 4.10 响应监控

守门员和矿工都需要保持响应性，以保持Phala网络的功能。守门员必须保持高水平的响应性，因为根密钥被保存在守门员的runtime内，必须随时可用。只要守门员能够为矿工提供合约密钥，合约的可用性就能得到保证。因此，无响应的矿工并不像无响应的守门员那样对系统有害。

我们采用类似Polkadot的无响应检测算法[7]。无论是守门员和矿工在运行时都会产生副作用。他们必须至少要在一个时间间隔内定期向区块链发布状态更新。因此，所有提交的副作用都可以作为在线活动的一个计数器。然后，我们可以通过以下方式确定一个节点$n$在一个时代（era）内是否没有反应。

$$
c_n < {1 \over 4}\max_{n'}(c_{n'})
$$
其中$c_n$是节点$n$的活动计数器，$n'$是这个时代（era）所有连接的worker节点。关于$n'$的详细设计，请参考经济设计论文。

## 5. 开放问题

安全方面的改进:

- 替代TEE硬件。尽管我们使用Intel SGX作为当前设计的参考。目前的设计，我们不对硬件做任何假设。潜在的TEE硬件包括AMD SEV、ARM Turstzone以及一些正在进行的开源实现。当我们支持任何替代方案时，不同的TEE可以透明地一起工作。

- 守门员根密钥上的threshold secret sharing。所有的保密合约的保密性来自于根密钥。然而，根密钥是在目前的设计中，根密钥是在所有守门员之间复制的，这意味着一个被破坏(被黑)TEE 可能会破坏整个系统。一个更强大的方法是对根秘钥应用threshold secret sharing（比如Shamir secret sharing）一个 分布式密钥生成方案（DKG）可以用来代替选择一个领导者来生成密钥轮换协议中的密钥。

- 通过secret sharing方案进行合约密钥备份。为了避免发生灾难，即为了避免Intel SGX完全崩溃的灾难（例如，Intel禁止所有的remote attestation请求。我们可以利用一个secret sharing方案，将根密钥分配给守门员，或者是两代守门员。在这种情况下，我们可以等待其他TEE系统的部署。然后 秘密持有者可以合作摄取密钥来恢复Phala网络的执行。

优化:
- 一个合约的冗余矿工：目前一个合约只与一个矿工相关联。状态恢复仍然需要一些时间，尽管可用率是有保证的。有了1个矿工，由于合约的执行是确定性的。矿工们可以竞争运行合约，并对区块链上的状态进行检查。区块链可以一直接受新的状态，并拒绝重新提交。
- 状态存储修剪 
- 第2层状态共享

## 参考

[1] Amd secure encrypted virtualization (sev). https://developer.amd.com/sev/.
[2] Arm trustzone technology. https://developer.arm.com/ip-products/security-ip/trustzone.
[3] Command and query responsibility segregation (cqrs) pattern. https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs.
[4] Event sourcing design pattern. https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing.
[5] Intel sgx:Remote attestation. https://software.intel.com/en-us/sgx/attestation-services.
[6] Intel software guard extensions. https://www.intel.com/content/www/us/en/architecture-and-technology/software-guard-extensions.html, 2019.
[7] Polkadot slashing mechanisms. https://research.web3.foundation/en/latest/polkadot/slashing/amounts/, 2019.
[8] Trusted execution environment. https://en.wikipedia.org/wiki/Trusted_execution_environment, 2019.
[9] Raymond Cheng, Fan Zhang, Jernej Kos, Warren He, Nicholas Hynes, Noah Johnson, Ari Juels, Andrew Miller, and Dawn Song. Ekiden: A platform for confidentiality-preserving, trustworthy, and performant smart contracts. In 2019 IEEE European Symposium on Security and Privacy
(EuroS&P), pages 185–200. IEEE, 2019.
[10] Wood Gavin. Polkadot: Vision for a heterogeneous multi-chain framework. 2016.
[11] Eli Ben Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anony-mous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, pages 459–474. IEEE, 2014.
[12] Philipp Schindler, Aljosha Judmayer, Nicholas Stifter, and Edgar Weippl. Distributed key generation with ethereum smart contracts.
[13] Nicolas Van Saberhagen. Cryptonote v 2.0. https://cryptonote.org/whitepaper.pdf, 2013.

