
## 简单的选择如何导致复杂的路径到ERC-4337？

账户抽象即将完全改变我们与区块链的互动方式。但是，ERC-4337提出的账户抽象版本很难阅读，很难理解为什么有这么多参与者以及为什么他们以这种方式互动。

是否有更简单的方法？

在本文档中，我将介绍尝试设计一个非常简单的账户抽象版本的过程，我们将看到随着我们增加更多的要求并解决出现的问题，我们将得到一个越来越复杂的东西，并且越来越接近ERC-4337。

本文档的目标读者是具有一定智能合约知识但没有特定账户抽象知识的人。

由于本文档探索发明账户抽象的过程，因此在许多情况下，我描述的API或行为与ERC-4337的最终版本不匹配。

例如，当我列出用户操作的字段时，请不要假设那些是实际字段。它们代表在进行最终版本讨论之前定义用户操作的第一次尝试。

好的，准备好了吗？

我们开始吧！

## 目标：创建一个能保护我们资产的钱包

为了开始，让我们发明一种保护我们最有价值资产的方法。我们希望能够使用单个私钥（与典型账户相同）签署大多数交易，但是我们无价的Carbonated Courage NFT只有在我们使用第二个密钥签署并将其锁定在由三头犬守护的银行保险库中才能进行转移。

**这样第一个问题就来了。**

每个以太坊账户都是智能合约或外部拥有账户（EOA），后者使用私钥从链外进行控制。持有这些资产的账户应该是智能合约还是EOA？

实际上，持有资产的账户必须是智能合约。如果它是EOA，则始终可以通过使用EOA的私钥签署的交易进行转移，从而绕过我们想要的安全性。

因此，与今天大多数人不同，我们在链上的存在将由智能合约代表而不是EOA代表，我们将其称为智能合约钱包或仅称为“钱包”。

我们需要一种方法向此智能合约发出命令，以便它执行我们想要的操作。特别是，我们需要能够命令智能合约进行任何类型的转账或调用，就像我可以从EOA发送的任何类型的转账或调用一样。

> 每个想要以这种方式保护其资产的用户都需要自己的智能合约。不能有一个大合约持有多个人的资产，因为生态系统的其他部分假定一个地址代表一个实体，并且无法区分个别用户。
> 
> 例如，如果有人想将NFT发送给组合钱包合约中的某个人，那么NFT的transfer API将仅允许发送方指定组合钱包的地址，而不是其中的个别用户。


## 用户操作(User Operations)


我要部署一个钱包智能合约来管理你的资产，并且这个合约有一个方法可以让你传递信息，告诉它你想要执行什么操作。我们把这个操作称为用户操作或者用户操作指令。

因此，这个钱包合约看起来应该是这样的：

```cpp
contract Wallet { 
	function executeOp(UserOperation op); 
}
```

#### 用户操作里有些什么？

首先，我们需要所有我们通常会传递给 `eth_sendTransaction` 的参数。

```cpp
struct UserOperation {
  address to;
  bytes data;
  uint256 value; // Amount of wei sent
  uint256 gas;
  // ...
}
```

除此之外，我们还需要提供一个授权请求的数据块，也就是钱包会用来决定是否执行操作的数据块。

对于我们保护 NFT 的钱包，对于大多数用户操作，我们会传递一个由我们的主密钥签名的操作的其余部分的签名。

但是，如果用户操作是转移我们超值的 Carbonated Courage NFT，则钱包需要我们传递由我们的两个密钥中的每一个签署的操作其余部分的签名。

我们还会加入一个 nonce 来防止重放攻击，即某人可以重新发送先前的用户操作以再次运行它：

```cpp
struct UserOperation {
  // ...
  bytes signature;
  uint256 nonce;
}
```

这实际上实现了目标！

只要我的 Carbonated Courage NFT 被这个合约持有，它就不能在没有两个签名的情况下被转移。

> 虽然钱包可以选择以任何方式解释`signature`和 `nonce` 字段，但我预计几乎所有钱包都会使用签名字段来接收所有其他字段的某种签名，以防止未经授权的方进行伪造或篡改操作。同样，我预计几乎任何钱包都会拒绝具有它已经看到的 nonce 的操作。

#### 谁调用这个智能合约钱包

这里有一个未解答的问题，即如何调用 `executeOp(op) `。由于没有我的私钥签名，它不会执行任何操作，因此我们可以让任何人尝试调用它，而不会有任何安全风险。但是，我们确实需要有人实际进行调用，以便操作发生。

在以太坊上，所有交易都必须起源于 EOA，调用 EOA 必须用自己的 ETH 支付燃气费用。

我可以创建一个专门用于调用我的钱包合约的单独的 EOA 账户。虽然这个 EOA 不会像钱包合约一样具有两个签名保护，但它只需要持有足够的 ETH 来支付运行我的钱包的燃气费用，而更安全的钱包合约可以持有我所有有价值的资产。

因此，我们实际上只用一个相当简单的合约就实现了大部分账户抽象功能！

![[Pasted image 20230529100954.png]]

目前为止挺好。

> 我所谓的“钱包合约”在 ERC-4337 中被称为“账户”。我觉得这很令人困惑，因为我认为每个地址都是一个账户。我将始终将此参与者称为“钱包合约”或仅称为“钱包”。


## 目标- 不分离EOA

上述解决方案的一个缺点是需要我运行一个单独的 EOA 账户来调用我的钱包。如果我不想这样做怎么办？目前，我仍然愿意用 ETH 支付自己的燃气费用。我只是不想有两个单独的账户。

我们说过，任何人都可以调用钱包合约的 `executeOp` 方法，因此我们可以要求具有 EOA 的其他人为我们调用它。我将称此 EOA 和运行它的人为“执行者”。

由于执行者支付燃气费用，因此没有多少人愿意免费做这件事。因此，新计划是钱包合约将持有一些 ETH，并且作为执行者的调用的一部分，钱包将向执行者转移一些 ETH 以补偿执行者使用的任何燃气费用。

> “执行者（excutor）”不是 ERC-4337 的术语，但是它很好地描述了这个参与者的功能。稍后，我们将使用 ERC-4337 实际使用的术语“bundler”来替换它，但是目前还没有这样做的意义，因为我们目前没有进行任何捆绑。其他协议可能还将此参与者称为“中继者（relayer）”。

#### 第一次尝试：钱包在最后要支持给executor一定的费用

为了保持简单，钱包的接口还是如下:

```cpp
contract Wallet { 
	function executeOp(UserOperation op); 
}
```

我们将尝试修改executeOp的行为，以便在最后，它查看使用了多少 gas，并向执行者发送适当数量的 ETH 来支付它。

![[Pasted image 20230529101814.png]]

#### 第一次模拟

如果我的钱包值得信赖，那么这个方案非常好！但执行者需要确信钱包确实会支付退款。如果执行者调用 `executeOp`，但钱包实际上没有退还gas，执行者将需要承担gas费用。

为了避免这种情况，执行者可以尝试在本地模拟 `executeOp` 操作，可能使用 `debug_traceCall`，看看它是否真的被补偿了gas。只有在这种情况下，它才会发送实际的交易。

这里的问题是，模拟并不能完美地预测未来。完全有可能钱包在模拟期间支付了gas，但在实际添加到区块时未能支付。不诚实的钱包可能会故意这样做，让它的操作免费执行，并为执行者累积巨额的gas费用。

**模拟可能与实际执行不同，原因有几个：**

1.操作可能从存储中读取数据，而存储在模拟和执行之间可能会发生变化。

2.操作可能使用像`TIMESTAMP`、`BLOCKHASH`、`BASEFEE`等操作码。这些操作码从环境中读取信息，并且从一个块到另一个块的变化是不可预测的。

执行者可以尝试限制操作所允许的操作，例如拒绝使用任何“环境”操作码的操作。但这将是一个过于严厉的限制。

记住，我们希望钱包能够做任何一个EOA能做的事情，因此禁止这些操作码将阻止太多合法的用途。例如，它将阻止钱包与大量使用`TIMESTAMP`的Uniswap进行交互。

由于钱包的`executeOp`可以包含任意代码，我们无法合理地限制它以防止它欺骗模拟，所以这个问题在当前的接口下是无法解决的。`executeOp`只是一个太过于黑盒的操作。

#### 更好的尝试：引入入口

这里的问题是，我们要求执行者运行来自不受信任的合约的代码。执行者想要的是在授予某些保证的上下文中运行这些不受信任的操作。这就是智能合约的全部目的，因此我们将引入一个新的可信合约（即经过审计，源代码已验证），称为入口点，并给它一个方法，执行者将调用该方法而不是直接执行 untrusted contract 的方法：

```cpp
contract EntryPoint {
  function handleOp(UserOperation op);

  // ...
}
```

`handleOp`将执行以下操作：

1. 检查钱包是否有足够的资金支付它可能使用的最大gas量（基于用户操作中的gas字段）。如果没有，拒绝。

2. 调用钱包的`executeOp`方法（使用适当的gas），跟踪它实际使用的gas量。

3. 向执行者发送一些钱包的ETH，以支付gas费用。

为了使第三个要点起作用，我们实际上需要入口点持有支付gas费用的ETH，而不是钱包本身，因为正如我们在前一节中看到的，我们不能确定我们能否从钱包中取出ETH。因此，入口点还需要一种方法，使钱包（或代表钱包的人）将ETH放入入口点中以支付其gas费用，我们将另外提供一种方法，以便钱包可以在需要时将其ETH取回：

```cpp
contract EntryPoint {
  // ...

  function deposit(address wallet) payable;
  function withdrawTo(address payable destination);
}
```

使用这个实现，无论如何执行者都会得到燃气费的退款。

![[Pasted image 20230529103139.png]]

这对于执行者来说很好！但对于钱包来说，这实际上是一个相当大的问题...

> 钱包不应该使用存入入口点的 ETH 来支付燃气费，而应该能够使用自己的 ETH 来支付。是的，我们会解决这个问题，但在进行下一步更改之前我们无法这样做，即使在那之后，我们仍然需要存款/提款系统。此外，我们稍后需要存款/提款系统来支持付款主。

## 分离校验和执行

我们的钱包接口是这样的:


```cpp
contract Wallet { 
	function executeOp(UserOperation op); 
}
```

这种方法实际上有两个作用：它验证用户操作是否经过授权，然后执行操作。当钱包的所有者使用自己的帐户支付燃气费时，这种区别并不重要，但现在我们要求执行者这样做，这就很重要了。

我们当前的实现方式是，无论如何执行者都会得到燃气费的退款。但实际上，如果验证失败，我们不希望钱包支付燃气费。

如果验证失败，这意味着没有权限控制钱包的人要求钱包执行某些操作。

在这种情况下，钱包的 `executeOp` 方法将正确地阻止操作，但在当前的实现下，钱包仍然必须支付燃气费。

这是一个问题，因为没有与钱包相关的人可以请求该钱包执行一堆操作，并使用完所有的燃气费。

相比之下，如果验证成功，但之后操作失败，那么钱包应该支付燃气费。这表示钱包所有者授权了一个没有成功的操作，就像从 EOA 发送一个撤销的交易一样，因为他们授权了它，所以他们应该对燃气负责。

当前的钱包接口只有一个方法，无法区分验证失败和执行失败，因此我们需要将其拆分为两个部分。

新的钱包接口:

```cpp
contract Wallet {
  function validateOp(UserOperation op);
  function executeOp(UserOperation op);
}
```

入口点 `handleOp` 的新实现如下：

1. 调用 `validateOp`。如果失败，请在此处停止。
2. 从钱包的存款中分配 ETH，以支付它可能使用的最大燃气费（基于操作的 gas 字段）。如果钱包没有足够的 ETH，请拒绝操作。
3. 调用 `executeOp` 并跟踪它使用的燃气量。无论此调用成功还是失败，都会从我们分配的资金中向执行者退还燃气费，并将其余资金返回到钱包的存款中。
4. 现在钱包看起来很棒了！除了经过授权的操作，它不会被收取燃气费。

![[Pasted image 20230529104028.png]]

但执行者的情况再次变得不稳定...

>  我们应该确保未经授权的用户无法直接调用钱包上的 executeOp 方法，从而导致它在未经验证的情况下执行操作。钱包可以通过强制要求只能由入口点调用 executeOp 方法来防止这种情况的发生。

> 为什么不诚实的钱包不直接在 validateOp 方法中执行所有操作，这样如果执行失败，它就不会被收取燃气费用？接下来我们将看到，validateOp 方法将有重大限制，使其不适合进行“真正”的操作。


## 抽象化模拟

现在，当未经授权的用户提交钱包操作时，操作将在 validateOp 中失败，钱包不必支付费用。但执行者仍然需要为 on-chain 执行 validateOp 支付 gas 费用，而且不会得到补偿。

不诚实的钱包不能再免费运行它们的操作，但是恶意用户仍然可以在任何时候让执行者因为失败的操作而失去 gas 费用。

在前面的模拟部分中，执行者尝试在本地先模拟操作，以查看是否通过，然后再提交一个交易来调用 handleOp。

我们遇到了问题，因为执行者无法合理地限制执行，以防止它在模拟中成功但在实际交易中失败。

但是这次有所不同。

执行者不需要模拟整个执行过程（现在包括 validateOp 和 executeOp）。它只需要模拟第一部分 validateOp，以知道是否会得到报酬。而 executeOp 需要能够执行任意操作，以便钱包可以自由地与区块链交互，我们可以对 validateOp 加强限制。

具体来说，除非 validateOp 满足以下限制，否则执行者将拒绝用户操作而不将其放在链上：

1. 它从某个禁止列表中永远不使用操作码，该列表包括 TIMESTAMP、BLOCKHASH 等代码。

2. 它只访问钱包的相关存储，定义为以下任何一项：

    - 钱包自己的存储。
    - 映射（地址 => 值）中与钱包对应的存储槽中的另一个合约的存储。
    - 存储槽等于钱包地址的另一个合约的存储（这是一种不自然地发生在 Solidity 中的存储方案）。


这些规则的目的是最大限度地减少 validateOp 在模拟中成功但在实际执行中失败的情况。

禁止的操作码是不言自明的，但是存储限制可能看起来有点奇怪。

这个想法是任何存储访问都代表了虚假模拟的危险，因为存储槽可能会在模拟和执行之间发生变化，但如果我们将存储限制在仅与此钱包相关的位置，则恶意用户需要更新特定于钱包的存储才能伪造模拟。希望更新这个存储的成本足以阻止恶意用户。

有了这个模拟，钱包和执行者都是安全的。

> 这种存储限制还有另一个好处，即我们知道对不同钱包的操作调用`validateOp`的时候不太可能相互干扰，因为它们都可以访问的存储是有限的。当我们谈论捆绑(bundling)时，这一点将非常重要。

## 改进：直接从钱包支付gas费用

目前，钱包提供的ETH用于支付汽油款项，需要先将其存入入口点，然后才能发送用户操作。但是，普通的EOA从其自己的ETH储备中支付汽油款项。难道我们的钱包不能做到同样的事情吗？

现在我们已经将验证和执行分离，因此入口点可以要求钱包在验证步骤中向入口点发送ETH，否则操作将被拒绝。

我们将更新钱包的validateOp方法，以便入口点可以要求其提供资金，并在validateOp未向入口点支付所请求的金额时拒绝操作：

```cpp
contract Wallet {
  function validateOp(UserOperation op, uint256 requiredPayment);
  function executeOp(UserOperation op);
}
```

由于在验证时我们不知道执行过程中将使用的确切汽油量，因此入口点根据op的gas字段要求最大可能使用的执行量。然后在执行结束时，我们希望将未使用的汽油款项退还给钱包。

但是，这里我们遇到了一个问题。

在编写智能合约时，向任意合约发送ETH是有风险的，因为这样会在该合约上调用任意代码，可能会失败，使用不可预测的气体量，甚至试图对我们进行可重入攻击。因此，我们不会直接将多余的汽油款项返还给钱包。

相反，我们将保留它，并允许钱包通过稍后调用withdraw来将其取出。这是拉取支付模式。[External Calls - Ethereum Smart Contract Best Practices (consensys.github.io)](https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/#favor-pull-over-push-for-external-calls) 

因此，我们实际上将多余的汽油款项放在与`deposit`结束时发送的ETH相同的位置上，钱包可以稍后使用`withdrawTo`将其取出。

事实证明，我们确实需要存款/提款系统（或者至少需要它的提款部分）。

这意味着钱包的汽油付款实际上可以来自两个不同的地方：其由入口点持有的ETH和钱包自己持有的ETH。

入口点将首先尝试使用存入的ETH支付汽油款项，然后如果存入的ETH不足，它将在调用钱包的validateOp时要求支付剩余部分。

## 执行者(executor)激励

  
目前，成为执行者是一项不受感激的任务。他们需要运行大量的模拟，却没有任何利润，有时还被迫自掏腰包支付燃料费，当他们的模拟被证明是虚假时。

为了补偿执行者，我们将允许钱包所有者在他们的用户操作中提交小费，这些小费将会给予执行者。

我们将在用户操作中添加一个字段来表达这个功能：

```cpp
struct UserOperation {
  // ...
  uint256 maxPriorityFeePerGas;
}
```

与常规交易中的类似字段相似，`maxPriorityFeePerGas`代表了发送方愿意支付的费用，以使他们的操作获得优先处理。

当执行者向调用入口点的`handleOp`发送其交易时，可以选择较低的`maxPriorityFeePerGas`，并将差额纳入自己的口袋。

## 把入口点作为一个单例

我们已经讨论了入口点应该是一个受信任的合约以及它的功能。你可能会注意到，入口点与钱包或执行者无关。因此，整个生态系统中的所有钱包和执行者都可以与同一个入口点合约交互。

这意味着我们需要调整用户操作，以便它们还指定了它们所属的钱包，这样当操作传递给入口点的`handleOp`时，入口点将知道要请求哪个钱包进行验证和执行。

更新后的用户操作:

```cpp
struct UserOperation {
  // ...
  address sender;
}
```


## 没有单独的EOA概括


我们的目标是创建一个可以自行支付燃气费用的链上钱包，而无需其所有者管理单独的EOA，我们现在已经实现了这一目标！

我们所拥有的是一个带有以下接口的钱包：

```cpp
contract Wallet {
  function validateOp(UserOperation op, uint256 requiredPayment);
  function executeOp(UserOperation op);
}
```

**We also have a blockchain-wide singleton entry point with the interface:**

```cpp
contract EntryPoint {
  function handleOp(UserOperation op);
  function deposit(address wallet) payable;
  function withdrawTo(address destination);
}
```

当钱包所有者想要执行某个操作时，他们会创建一个用户操作，并在链下请求执行者代为处理。

执行者会在此用户操作上模拟钱包的 `validateOp` 方法，以决定是否接受它。

如果接受，执行者会向入口点发送一笔交易，调用 `handleOp` 方法。

入口点会处理验证和在链上执行该操作，并在完成后从钱包存入的资金中向执行者退还ETH。

## 插曲：捆绑(bundling)

在我们进入下一个重要功能之前，让我们花点时间进行一个出乎意料的简单优化。

到目前为止，执行者发送一个交易来执行一个用户操作。但现在我们有了一个不仅仅绑定在一个钱包上的入口合约，我们可以通过收集来自不同人的一堆用户操作，在单个交易中执行它们，从而节省一些 gas！

这种打包用户操作的方式可以通过不重复支付固定的 21,000 gas 费用来发送交易以及降低执行冷存储访问的费用（在交易中多次访问相同的存储在第一次之后会更便宜）来节省 gas。

这只需要进行令人耳目一新的少量更改。

```cpp
contract EntryPoint {
  function handleOps(UserOperation[] ops);

  // ...
}
```

![[Pasted image 20230529123834.png]]

新的 handleOps 方法实现了更多或更少你所期望的功能：

- 对于每个操作，调用操作的发送者钱包上的 validateOp。任何未通过验证的操作都会被丢弃。
- 对于每个操作，调用操作的发送者钱包上的 executeOp，跟踪我们使用的 gas 的数量，然后转移 ETH 给执行者来支付那笔 gas 的费用。

这里需要注意的一件事是，我们首先执行所有的验证，然后才执行所有的操作，而不是在移动到下一个操作之前验证和执行每个操作。

这是为了保留模拟结果。

如果在 handleOps 中，我们在验证下一个操作之前先执行了一个操作，那么第一个操作的执行将能够自由地干扰第二个操作的验证依赖的存储，并导致即使第二个操作在真空中模拟通过了验证，它也会失败。

类似的，我们想避免一个操作的验证干扰捆绑包中后面操作的验证。

只要捆绑包(the bundle)不包含同一钱包的多个操作，我们实际上可以通过上面讨论的存储限制来轻松实现这一点：如果两个操作的验证不涉及相同的存储，它们就不会相互干扰。为了利用这一点，执行者将确保捆绑包(the bundle)中最多包含来自任何给定钱包的一个操作。

对于执行者来说，一个很棒的事情是他们有了一个新的收入来源！

执行者有机会通过安排用户操作在捆绑包中（并可能插入自己的操作），以盈利的方式获得一些最大可提取价值 (MEV) [What is Maximal Extractable Value (MEV)? (alchemy.com)](https://www.alchemy.com/overviews/what-is-mev) 。

现在我们有了捆绑功能，我们可以停止称这些参与者为“执行者”，并开始用他们的真实名称——捆绑器（bundlers）——称呼他们。

为了与 ERC-4337 的术语保持一致，我在这个 4 部分系列的其余部分中将称他们为捆绑器，但实际上，我认为“执行者”是我脑海中思考他们的一个好方法，因为它强调了他们的工作是作为一个实际上从 EOA 发送交易开始链上执行的人。

## 捆绑者(bundlers)作为网络参与者

我们有一个设置，钱包所有者向捆绑器提交用户操作，希望这些操作被包含在捆绑包中。这与普通交易的设置非常相似，账户所有者向区块构建者提交交易，希望这些交易被包含在区块中，因此我们可以从一些相同的网络架构中受益。

就像节点将普通交易存储在内存池中并将其广播给其他节点一样，捆绑器可以将验证过的用户操作存储在内存池中并将其广播给其他捆绑器。捆绑器可以在与其他捆绑器共享之前验证用户操作，从而节省彼此验证每个操作的工作。

如果捆绑器也是区块构建者，他们可以从中受益，因为如果他们可以选择包含他们的捆绑包的区块，他们可以减少甚至消除在模拟成功后执行期间操作失败的可能性。此外，区块构建者和捆绑器可以通过了解如何提取 MEV 以类似的方式受益。

随着时间的推移，我们可能会预计捆绑器和区块构建者合并为同一角色。



到目前为止，我们已经弄清楚了如何创建一个智能合约钱包来保护我们最有价值的资产，以及如何依靠执行者或捆绑器代表我们调用这个智能合约钱包。