[1390.pdf (iacr.org)](https://eprint.iacr.org/2020/1390.pdf)


## Abstract

阈值签名研究在过去三年里取得了很大进展，尤其是 ECDSA，它比 EdDSA 等基于 Schnorr 的签名更不适合 MPC。这一进展主要是由区块链应用推动的，并受到 Lindell 和 Gennaro & Goldfeder 同时发表的突破性成果的推动。此后，多个研究团队发布了具有不同功能、设计权衡、构建模块和证明技术的阈值签名方案。此外，阈值签名现在已被部署到大型组织中，以保护大量数字资产。因此，研究人员和从业人员需要清楚地了解研究现状、现有协议的相对优势和未决问题，特别是那些能解决 "现实世界 "挑战的问题。

因此，本调查报告建议：(1) 基于扩展的算术黑盒形式(ABB+)，以通用、统一的方式描述阈值签名及其构建块(build block)；(2) 回顾最先进的阈值签名协议，强调其独特属性，并根据实践中的相关标准，在安全保证和性能方面对其进行比较；(3) 回顾现有的主要开源实现方法；(4) 探讨新的阈值签名协议。

## 1. 介绍

一个门限化签名方案(TSS), 允许一组参与者协同计算一个签名并且并不需要知道对方私钥信息。在一个(t,n) 的TSS方案中，n个参与者持有各自一个独立的秘钥分片(Key share)，然后这n个参与者中的任意t +1个参与者(这些参与者不同), 都可以共同签署一个合法的签名，在这里t + 1 <= n。 如果参与者人数小于等于t个，那么就不行。TSS的setup阶段依赖一种叫分布式秘钥生成(Distributed Key Generation, DKG)的协议, 也就是在各参与方不公开秘钥的情况下，生成秘钥分片(Key shares)。在实践中，TSS通常会增加一个reshare的协议(也叫share rotation)。以便在不改变相应秘钥的情况下更新这些秘钥分片(Key Shares)。

在 Desmedt 提出阈值签名这一概念 [Des87] 30 多年后，在 [Sho00]、[aK01]、[MR01]、[LP01]、[BLS04] 等成果达到顶峰 15-20 年后、 区块链应用再次激发了人们对 TSS 的兴趣，过去 3 年中出现了 [BDN18]、[GG18]、[DKLas18]、[DKLas19]、[DKO+19]、[GRSB19]、[Cs19]、[SA19]、[CCL+19a]、[CCL+20a]、[KG20]、[CMP20]、[GG20] 等著作。因此，这些研究往往侧重于区块链协议中使用的签名方案，即 ECDSA（最常用的是 secp256k1 椭圆曲线）和 EdDSA（如 Ed25519）--请注意，快速阈值 RSA 签名已有 20 年历史 [Sho00]，[aK01]。

在本文中，我们试图总结所有这些最新著作所确立的技术现状，特别是回顾可大规模部署以保护加密货币或其他资产的高效 TSS 构造。我们将重点放在 ECDSA 案例上，因为：(1) ECDSA 是目前最重要的应用，ECDSA 是比特币和以太坊当时唯一支持的签名方案；(2) ECDSA 的 "阈值化 "比 EdDSA 或纯 Schnorr 签名更复杂，由于其 s 计算的线性，它们对阈值相对友好。

> 注: 因为签名是是用(R,s) 元组来表示。另外，关于secp256k1曲线的Schnorr签名方案，其实已经被集成进了BTC的源码里面，叫BIP-340

本调查旨在帮助研究人员和工程师了解 TSS 协议的不同之处，以及它们在安全性、性能和功能方面的优势和局限性。在为数字资产保管解决方案选择协议时，这种了解至关重要，因为 TSS 可用于多方共享控制，或在单个组织内分配信任。事实上，正如 [AS20] 中的攻击所显示的，TSS 协议及其实现中的微妙特性或缺陷可能会带来灾难性的影响。这项工作还将帮助安全审计人员审查 TSS 实现，并帮助安全架构师确保适当的控制措施到位，以便在其环境中安全集成 TSS。

我们把文章的结构分为以下几个部分:

- 第二节- 定义了阈值签名，即本文中使用的算术黑盒形式，并简要介绍了 TSS 协议的主要加密构件(building blocks)。
- 第三节- -回顾了秘密共享技术及其变体和相关技术，例如从乘法共享到加法共享的转换。
- 第五节-描述了TSS协议的评估标准，重点是实际应用
- 第六节-根据提出的评价标准，讨论了所选协议的相对优点。
- 第七节-回顾了现有的一些主要开放源代码实施方案，重点介绍了 "经过实战检验 "和经过审计的代码。

## 2. 序言

### 2.1 记号

在协议中的 $P_1$、......、$P_n$ 参与者被建模为概率多项式时间图灵机。 对方手 A(adversary A) 控制着参与者的一个子集，其建模方式与所有参与者的相同。

在这个过程中。一个变量被赋值是用 $\leftarrow$ 操作符。 当箭头的右侧是任意集合 X 或概率函数 F 时，所赋值将从 X 或 F 的分布中均匀采样。我们会把 $a \leftarrow b$ 简写成 $a \leftarrow  \{b\}$

一般来说，私钥/公钥对, 分别用 $sk$ 和 $pk$ 表示，由密钥生成程序 $KGen$ 生成。 签名生成和验证算法分别用 $Sig$ 和 $Vf$ 表示。加密和解密函数为 $Enc$ 和 $Dec$。

Hash函数用$H$ 表示，根据上下文的不同，Hash函数既可以是通用的hash一段数据到bit string的，也可以是hash一段数据到一个特定集合的。

有限域$K$ 上的椭圆曲线$E$ 用 $E(K)$ 表示。我们用$\mathbb{G} \subseteq E(K)$ 表示$E(K)$ 上的一个素阶子群，素数的阶数为$q$ 。 这个素阶子群的生成元用$G$ 表示。也就是椭圆曲线上的G点，该点是所有参与方都知道的

然后关于操作的加法记号是这样表示的，标量$k \in \mathbb{Z}_p$ 乘以素阶群上的一个点$P \in \mathbb{G}$ 表示为$k \cdot P$

多方计算的功能其实就是我们使用操作这些在$\mathbb{Z_q}$上的共享秘密值和$\mathbb{G}$ ， 也就是基于椭圆曲线上的标量乘法。我们把这些共享秘密值叫作共享秘密。被定义为秘密共享方案(secret sharing scheme, SSS)。有限域$x \in \mathbb{Z}_q$ 上的这些域元素的共享秘密值，我们记为$[x]$, 共享秘密$x$ 在椭圆曲线的素阶群 $x \cdot G \in \mathbb{G}$上对应的共享秘密记为$<x>$， 这个实际上是为了表示底层的共享秘密$x$ 。本质上其实这个秘密$x$ 也就是正常的椭圆曲线的私钥(标量)。

使用 MPC 功能的算法和协议都是从一方 $P_i$ 的角度编写的。 每当建立一个共享秘密(shared secret)时，就会隐含地定义一个变量，代表 $P_i$ 的分片。这些份额分别用 $x_i$ 和 $X_i$ 表示 $[x]$ 和 $<x>$。

在一个(t, n)的门限方案中，包含了n个参与方，其中阈值$t < n$ 是在保持基础方案安全的情况下，可被破坏的最大参与方数量。每当使用这种阈值时，我们有时会添加 $t$ 作为下标，以示清晰。请注意，并不是所有的 $t$ 值都能被给定的 TSS 协议支持，因为其安全性取决于对抗模型（例如，诚实与不诚实的多数，如第 5.2.3 节所讨论的）。

> 注意: : 有些论文采用的约定是，$t$ 个当事人是签发签名的必要且充分条件（因此最多 t - 1 个当事人可以被破坏, 也就是少一个，就签名不了），而其他论文则分别采用 $t + 1$ 和 $t$。后者似乎是近期论文中最常见的约定，因此我们也采用它。

### 2.2 门限化签名方案

下面有一个半形式化的TSS定义，在这篇调研论文中也够用了:

> 定义 2.1 在给定(单方)签名方案($KGen, Sig, Vf$) 的(t, n)门限签名方案涉及$n > 1$方 $P_1,. P_n$能够运行以下协议:


- $Thresh-KGen$ 是一种分布式密钥生成（DKG）协议，不需要事先共享密钥材料，只需要公开身份/地址。当协议成功完成时，每一方 $P_i$ 都有私钥 $sk$ 的私有分片 $sk_i$，所有各方都知道公钥 $pk$，没有任何一方知道关于 $sk$ 的信息。 也就是，在大家一起分布式协商下，产生了一个大家都不知道的私钥$sk$ ，取消了私钥的显式生成，带来的私钥单点故障安全性。

- $Thresh-Sig$ 是一种分布式签名协议，所有各方都会收到要签名的信息(Message)，并共同返回一个有效的签名。也就是大家一起基于各自自己的分片$sk_i$分布式协商签署一个合法的签名。

下面的协议是可选的:

- $Thresh-PreSig$ 是 $Thresh-Sig$ 的一个子协议，它不依赖于要签名的信息（Message）。执行成功后，每个参与者都会存储一个自己的预签名(presignature)，以便在 $Thresh-Sig$ 完成后检索。

- $Thresh-Reshare$ 是一个门限化的秘密共享协议，它是被在运行$Thresh-KGen$之后执行。在输入 $t^{'} <= n$ 时，刷新秘密分片 $sk_i$，使该方案满足 $(t^{'}, n)$ 门限。

在实践中，需要对参与者之间通信的可靠性和完整性做出一些假设，我们将在第 5.3 节中讨论这些假设

### 2.3 算术黑盒形式

为了描述在共享秘密上运行的 MPC 协议，可以将复杂的操作分解为一系列简单的操作，每个操作都被单独定义为安全的 MPC 操作。为此，我们使用算术黑盒（ABB）[DN03] 框架及其扩展 ABB+ [DKO+19]，其中包括计算阈值签名所需的所有操作。

特别是，ABB+ 允许各方使用 $x \in Z_q$ 的表示 $[x]$ 或 $<x>$ 的共享秘密安全地执行算术运算。重要的是，这些函数的实现不会泄露任何有关输入或输出的信息。

ABB+ 假定通过线性秘密共享方案共享秘密, 也就是说，对于任意$a、b \in Zq$ 和表示 $[x]$、$[y]$ 或 $<x>$、$<y>$，双方可以在本地计算 $a[x]+b[y] = [ax+by]$ 和 $a \cdot <x> + b \cdot <y> = <ax + by>$。关于线性秘密共享方案的各种可能实现方式，请参阅第 3 节。

从形式上看，ABB+ 包含以下操作：

![[Pasted image 20231202083017.png]]

> 注: 上图中的$Z_p$ 就是$Z_q$ 就是大素数，也就是有限域，基域

虽然其中一些函数的实现很简单，但它们通常需要额外的步骤来保证其安全性。 例如，调用 Open 时，双方通常要事先承诺(commit)各自的分片，以防止结果被篡改。

> 注: 这就需要用到密码学里面的承诺(commitment)了。

为了了解我们如何使用和组合这些函数来构建 MPC 协议，我们在下图中展示了 Beaver [BIB89] 和 [Bea91] 中实现 Mul 和 Invert 的两个著名示例。

![[Pasted image 20231202123711.png]]

我们注意到在这两个例子中使用了辅助随机秘密共享。它们通常被称为 "盲值"，因为它们允许各方打开从输入中导出的表示，而不会泄露关于共享或秘密的任何秘密信息。安全地乘以共享秘密并非易事，这也是构建高效 ECDSA 门槛方案的主要挑战。

在第 3 节中，我们将介绍这种不依赖 RandMul 的实现方法，有关 Mul 的其他构造，请读者参阅 [Mau06]、[DN07]。

### 2.4 密码学工具箱

我们简要总结了 ECDSA TSS 协议的主要组成部分：

#### 2.4.1 承诺方案(Commitment Schemes)

参与方 A 可以通过 $c \leftarrow Commit(m, r)$ 先计算出消息$m$ 的承诺，以隐藏消息$m$， 其中$r$ 是刚生成的随机数。然后参与方A 把随机数$r$承诺$c$分享给参与者B，并允许其他参与者通过运行$Open(m,c,r)$ 来验证承诺的合法性。其实$Open$函数本质上就是再次运行$Commit$ 函数，以验证承诺是否相等。 类似于Hash函数，来说明没有对消息$m$ 的篡改（也就是承诺值对消息$m$的绑定性）。

定义和记号略有不同，有时还涉及 "公开承诺密钥(public commitment key)"。

一个承诺方法的安全属性有:

- 隐藏性: 承诺$c$没有泄露关于消息$m$的任何信息
- 绑定性:  对方手(作恶者)不能作恶，就是找到另一个消息$m^{'}$ 和另一个$r^{'}$ 的承诺与原$(m,r)$的承诺相等。也就是无法轻易让 $Commit(m^{'}, r^{'}) = Commit(m,r)$这个公式相等，来伪造$Open(m{'},c,r^{'})$

TSS 协议通常使用 Pedersen 承诺(Perdersen Commitment)，其工作原理如下:

给定一个素阶为 $q$ 的循环群 $\mathbb{G}$  和两个生成元 $G、H \in \mathbb{G}$, 消息m $m \in \mathbb{Z}_q$ 的承诺就是$Commit(m,r) = m \cdot G + r \cdot H$ 

当然，TSS 中也有用 ElGamal 承诺(ElGamal Commitment)： 与 Pedersen 不同的是，承诺的信息$M$是 $\mathbb{G}$ 中的元素而不是 $\mathbb{Z}_q$ 元素，而且承诺计算是 $Commit(M, r) = (r \cdot G, M + r \cdot H)$。
#### 2.4.2 加法同态加密

一个加法同态加密方案主要由三个算法构成: $KGen, Enc_{pk}, Dec_{sk}$ 也就是秘钥对的生成，公钥加密，私钥解密:

- $(pk, sk) \leftarrow KGen()$ 是公私钥对生成
- $M$和$\xi$ 分别是消息和密文域，密文是被$pk$加密的。
- $Enc_{pk}:$ $M \rightarrow \xi$  是一个概率性算法
- $Dec_{sk}:$ $\xi \rightarrow M$是一个确定性算法
- 这有两个群上的操作符 $\oplus: \xi × \xi \rightarrow \xi$ 和$\odot: \mathbb{Z} × \xi \rightarrow \xi$ 并且满足以下关系:

$$
m_1 + m_2 = Dec_{sk}(Enc_{pk}(m_1) \oplus Enc_{pk}(m_2))
$$
$$
k \cdot m = Dec_{sk}(k \odot Enc_{pk}(m))
$$

在TSS协议中用的最多最广泛的同态加密就是Paillier算法了:

- $KGen$: 生成相同bit位长度的两个大素数$p$和$q$ 。然后让这两个大素数相乘 $N = p \cdot q$ ，然后计算$\lambda := (p - 1)(q - 1)$ 最后返回 $sk := \lambda$ 和$pk := N$ 也就是公私钥对
- $Enc_{pk}: \mathbb{Z}_N \rightarrow \mathbb{Z}_{N^2}$  :   对于一个消息$m$ ，其中$m \in \mathbb{Z}_N$ ，然后生成一个随机数$r$ ，其中$r \in \mathbb{Z^*}_N$ 。然后返回 $c := (N + 1)^{m}r^{N} \space mod \space N^2$
- $Dec_{sk}: \mathbb{Z}_{N^2} \rightarrow \mathbb{Z}_N$ :  定义一个函数$L(u) := (u - 1) / N$ , 其中 $u \in \mathbb{Z}_{N^2}$  记为 $N | u - 1$ 。 给定一个密文$c \in \mathbb{Z}_{N^2}$ ， 返回 $m := L(c^{\lambda}) \cdot \lambda^{-1}$

所以对于这个同态特性，我们可以得出以下关系:

$$
Enc_{pk}(c_1) \oplus Enc_{pk}(c_2) = Enc_{pk}(c_1) \cdot Enc_{pk}(c_2)
$$

$$
k \odot Enc_{pk}(c) = Enc_{pk}(c)^k
$$

当使用 Paillier 对 $\mathbb{Z}_q$ 中 $q < N$ 的元素进行加密时，我们经常会使用零知识范围证明(range proof)来保证上述操作不会导致 $\mathbb{Z}_q$ 的“溢出”，从而导致解密错误.

TSS协议中，有时也会使用 ElGamal 方案，是 in-the-exponent 版本。严格来说，这种 ElGamal 加密不是有效的加密方案，因为解密需要解决离散对数问题。它的工作原理如下:

公开的各种参数是一个阶为$q$的群$\mathbb{G}$, 生成元$G \in \mathbb{G}$, 公钥$pk$是群中的元素$P \in \mathbb{G}$。私钥是$sk := d$ ，其中$P = d \cdot G$ ， 加密是被定义为以下的一个概率函数，该函数以随机数$r \leftarrow \mathbb{Z}_q$ 作为输入：

$$
Enc_{pk}(m \space , r): \mathbb{Z}_q \rightarrow \mathbb{G} \times \mathbb{G} \\

$$
$$
m \rightarrow  (r \cdot G, r \cdot P + m \cdot G) = (U, V)
$$
给定公钥$P$(离散对数)， 我们可以求得$m \cdot G = V - r \cdot P = V - r \cdot (d \cdot G) = V - d \cdot (r \cdot G) = V - d \cdot U$

$$
m \cdot G = V - d \cdot U
$$

为了恢复明文$m$， 就需要计算一个离散对数，这个是非常困难的，除非$m$比较小。指数中的ElGa-mal通常有助于获得针对恶意对手的安全性（如TSS中的情况协议），通过对密文进行计算并在零知识的情况下进行验证，而且无需解密。

以下是ElGamal方案的同态性质:

$$

$$



#### 2.4.3 零知识证明


