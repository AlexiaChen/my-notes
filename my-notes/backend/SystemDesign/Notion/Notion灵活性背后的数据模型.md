
一代先驱者（Doug Engelbart、Ted Nelson、Alan Kay 等）将计算机视为通过赋予人们信息权力来增强人类解决问题的工具。

如今，这些信息大多在各种工具中保持孤立。以基于云的文档编辑器为例，其中页面是其最小的原子单元。信息被锁定在页面、文件和文件夹中——这让人想起一个世纪前的工作方式。

我们在一个框架上构建了 Notion，该框架允许信息独立存在，不受任何约束或容器的影响，而是将权力交到用户手中。该框架是建立在块(block)之上的。

你在 Notion 中看到的一切都是一个block。文本、图像、列表、数据库中的一行，甚至页面本身——这些都是块(block)，是动态的信息单元，可以转换为其他block类型或在 Notion 中自由移动。它们是我们用来构建和建模信息的乐高积木。当积木组合在一起时，它们就像乐高积木，创造出比它们各部分的总和大得多的东西。

这种灵活性是 Notion 使命的核心。虽然块(block)要求我们的工程团队在构建信息时应用极其严格的技术，但我们想要一个原子的、类似图(graph)的数据模型，为我们的用户提供自定义信息移动、组织和共享方式的能力。

block模型使 Notion 独一无二，它是 Notion 思考如何将先驱者认为计算作为一种媒介可能成为现实的基础。

### block的基础

就像乐高套装中的乐高积木一样，Notion 积木是代表 Notion 编辑器中所有信息单位的单数积木。block的属性决定了该信息的呈现和组织方式。

![[Pasted image 20240314173347.png]]

每个block有下列属性

- **ID** — 每个块都可以通过其ID进行唯一标识。您可以在浏览器的 URL 末尾看到页面block的 ID。我们在 Notion 中使用随机生成的 UUID （UUID v4） 作为 ID。
- **Properties** —包含有关特定块的自定义属性的数据结构。最常见的属性是 title，它存储块类型的文本内容，如段落、列表，当然还有页面的标题。更复杂的块类型需要其他或不同的属性，例如数据库中具有[用户定义属性的页面块]([Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.](https://www.notion.so/notion/Intro-to-databases-fd8cd2d212f74c50954c11086d85997e#6b755095caf3419fb544f2cc996fe926))。
- **Type** — 每个块都有一个类型，它定义块的显示方式，以及如何解释块的属性。Notion 支持多种类型的块，其中大部分可以在按下 + 按钮或 / 菜单时出现的“新块”菜单中看到：
    ![[Pasted image 20240314173629.png]]
    
除了描述块本身的属性外，每个块还具有定义它们与其他块关系的属性：

- **Content** — 表示此块内内容的块 ID 数组（或有序集），例如项目符号列表中的嵌套项目符号项或切换开关中的文本。
- **Parent** — 块的父级的块 ID。父块仅用于权限(permission)。
### block之间使如何适配组合在一起的

与乐高积木一样，Notion 积木可以与其他积木组合在一起，使功能更强大——比如完全根据团队流程定制的路线图，跟踪进度并将所有项目信息保存在一个地方。我们组织blocks的各个方面，以确保它们做正确的事情并生活在正确的地方，使用户能够连接它们并进一步定制 Notion 来解决他们的问题。

#### 类型和属性

block类型指定了block在 Notion 的 UI 中的呈现方式——根据该类型，我们对block的属性和内容有不同的解释。如果您在 Notion 中使用过 `Turn into` 函数，您可能对此很熟悉，该函数允许您将一种block类型转换为另一种block类型。

更改block的类型不会更改block的属性或内容，而只会更改 type 属性。信息只是以不同的方式呈现，如果该block类型未使用该属性，则甚至忽略该信息。

例如，您可以在此处看到`To-do list` block已转换为其他几种block类型。我们还会检查该`To-do list`列表项。当`To-do list` block转换为`Heading`和`Callout` block类型时，`To-do list` block的“checked”属性将被忽略，但当我们将该block转`To-do list` block时，它仍然处于选中状态。

![[Pasted image 20240314174333.png]]

将属性存储与block类型解耦可以有效地转换和更改渲染逻辑。但这对于协作也至关重要，因为我们尽可能多地保留用户意图。
#### Content和渲染树

block模型的灵活性还允许将块嵌套在其他block中，例如切换中的文本或页面内无限嵌套的子页面。block的 content 属性用于存储引用这些嵌套块的块 ID（或指针）数组。

![[Pasted image 20240314174532.png]]

在`To-do list`示例中，我们有一个`To-do list` block（“写一篇关于blocks的博客文章”），其内容数组中有三个块 ID。我们将这些 ID 视为“向下指针”，并将它们所指的block称为“content”或“render children”。

![[Pasted image 20240314174708.png]]

每个block都定义了其content blocks呈现的位置和顺序。我们将block及其render children之间的这种层次关系称为“渲染树”。但是，它看起来不像一棵有树枝的树——不同的block类型以不同的方式呈现它们的子blocks。

下面是一些示例，说明不同block类型如何呈现 content 属性：

- List Blocks — `Text`、`Bulleted list`和`To-do list`。List blocks以缩进方式显示其content。
- Toggles — `Toggle list`仅在展开时显示content。否则，它们仅显示 title 属性。
- Pages — `Page` blocks在新页面中显示其content，而不是在当前页面中呈现缩进。要查看此content，您需要单击进入新页面。

从结构上讲，这允许您在最精细的级别上操作block，从而继续为您的信息带来强大功能。这是一个概念，它保留了用户在处理其他信息时应如何组织和显示信息的意图。
#### 编辑渲染树

你有没有对 Notion 中的缩进工作方式感到惊讶？在传统的文字处理器中，缩进是表示性(presentational)的：它只影响文本与边距的间距。在 Notion 中，缩进是结构性的：它是渲染树结构的反映。换句话说，当您在 Notion 中缩进某些内容时，您是在处理block与其content之间的关系，而不仅仅是添加样式。

例如，在content block中按缩进键会尝试将该block添加到content tree中最近的同级block的content中。

![[Pasted image 20240314175521.png]]

大多数时候，缩进的工作方式与传统文档编辑器中的缩进方式类似——当前选择的block将移动到前一个block的content array中，并将在其中呈现缩进。但是，当前一个block不是list（或根本没有前一个block）时，缩进将不起作用，因为无处可移动该block。Notion 中文档的可视化表示反映了它所包含的信息的结构。

### 权限(permissions)

到目前为止，我们已经解释了块(block)如何组合在一起来组织和构建您的信息。了解此结构如何保护您的信息也很重要，以便只有合适的人才能阅读或更改它。

块根据它们所在的块（在树中位于它们上面）继承权限。考虑一个页面 - 要阅读其内容，您必须能够阅读该页面中的块。但是，有两个原因我们不能使用内容数组(content array)来构建此权限系统：

1. 最初，我们允许多个内容数组引用块，以简化我们的协作和并发模型。但是，由于一个块可以在多个位置引用，因此它将从哪个块继承权限是模棱两可的。**在权限系统中，歧义是不可接受的。**
2. 第二个原因是机械性的。为了实现对块的权限检查，我们需要查找树，获取该块的祖先，一直到树的根（即工作区）。试图通过搜索所有块的内容数组来找到此祖先路径是低效的，尤其是在客户端上。


![[Pasted image 20240314175722.png]]

取而代之的是，我们使用“向上指针”（父属性）作为权限系统。向上的父指针和向下的内容指针相互镜像（除了我们正在努力清理的一些边缘情况）。

![[Pasted image 20240314175737.png]]

### block的生命

区块(block)的生命周期从客户端开始。

当您在 UI 中执行操作（在编辑器中键入内容、在页面中拖动块）时，这些更改表示为创建或更新单个记录的操作。我们的团队将“记录”称为 Notion 中的任何类型的持久化数据，例如块、用户、工作区等。而且，由于许多操作通常会更改多个记录，因此操作会批处理到由服务器作为一个组提交（或拒绝）的事务中。

假设您正在与朋友一起在页面内工作，两人都在不同的计算机上编辑待办事项列表。幕后发生了什么？

#### 创建和更新blocks

您按回车键 — 这将创建一个新的“待办事项”块。

首先，客户端定义块的所有初始属性，生成新的唯一 ID，设置适当的块类型 （'to_do'），并填写块的属性（空的 'title' 和 'checked： [[“No”]]'）。它构建操作来表示使用这些属性创建新块。

![[Pasted image 20240314175831.png]]

新块不是孤立地创建的：块也会添加到其父级的内容数组中，因此它们在内容树中处于正确的位置。因此，客户端还会生成一个操作来执行此操作。所有这些单独的更改操作都分组到一个事务中。

然后，客户端将事务中的操作应用于其本地状态。在内存中创建新的块对象并修改现有块。在我们的本机应用程序上，我们将您在本地访问的所有记录缓存在 [SQLite](https://www.notion.so/blog/faster-page-load-navigation) 或 IndexedDB 之上的 LRU（最近最少使用）缓存中，称为 RecordCache。当您更改本机应用程序上的记录时，我们还会更新 RecordCache 中的本地副本。编辑器将重新渲染以将新创建的块绘制到屏幕上。这发生在您按键后的几毫秒内。

同时，事务被保存到 TransactionQueue 中，TransactionQueue 是客户端负责将所有事务发送到 Notion 服务器的部分，以便您的数据被持久化并与协作者共享。TransactionQueue 将事务安全地存储在 IndexedDB 或 SQLite 中（取决于平台），直到它们被服务器保留或被拒绝。
#### 在服务器上保存变化

以下是您的块最终安全地保存在服务器上的方式，以便您的朋友可以看到它。

通常，TransactionQueue 是空的，因此创建区块的事务会立即在 API 请求中发送到 Notion 的服务器。事务数据序列化为 JSON 并发布到“/saveTransactions”API 端点。

SaveTransaction 的主要工作是将您的数据导入我们的事实来源数据库，该数据库将所有区块数据以及所有其他类型的持久化记录存储在 Notion 中。

![[Pasted image 20240314175902.png]]

请求到达 Notion API 服务器后：

1. 我们加载交易中涉及的所有区块和父级。这为我们提供了记忆中的“之前”图片。在此示例中，请记住，我们正在创建一个块。因此，我们至少需要加载页面块，以便我们可以将新创建的块的 ID 插入到页面的内容数组中。
    
2. 我们复制刚刚加载到内存中的“之前”数据。然后，我们将事务中的操作应用于新副本以创建“之后”数据。
    
3. 然后，我们使用“之前”和“之后”的数据来验证权限和数据一致性的变化。如果所有内容都签出（通常确实如此），则所有创建或更改的记录都将提交到数据库中，这意味着您的区块现已正式创建。
    
4. 此时，对客户端发送的原始 API 请求有一个“成功”的 HTTP 响应。这确认您的客户端知道事务已成功保存，并且可以继续保存 TransactionQueue 中的下一个事务。
    
5. 在后台，我们会根据对您的交易所做的更改类型安排额外的工作。例如，我们为 [Quick Find](https://www.notion.so/Searching-with-Quick-Find-af945b6e69b64437afba2d143e4b546f)安排 [版本历史记录](https://www.notion.so/Version-history-eec3af1f5bc64ba0a712ee5794e12a9c) 快照和索引块文本。重要的是，我们还会通知 MessageStore（Notion 的实时更新服务）有关您所做的更改。
    
我们将在下一节中介绍数据如何到达您朋友的屏幕。
#### 实时更新

您按回车键，创建了一个新区块，现在您的区块会显示在您朋友的屏幕上。这是如何工作的？

![[Pasted image 20240314175931.png]]

每个客户端都与 Notion 的实时更新服务 MessageStore 建立了长期的 WebSocket 连接。当 Notion 客户端呈现块（或页面，或任何其他类型的记录）时，客户端使用此 WebSocket 连接从 MessageStore 订阅该记录的更改。当您的朋友打开与您相同的页面时，他们会订阅所有这些块的更改。

在您的更改通过 saveTransactions 流程后，API 会通知 MessageStore 新的记录版本。MessageStore 查找订阅了这些更改记录的客户端连接，并通过其 WebSocket 连接将新版本传递给它们。

当您朋友的客户端收到来自 MessageStore 的版本更新通知时，它会在其本地缓存中验证该块的版本。由于通知和本地块的版本不同，因此它会向服务器发送“syncRecordValues”API 请求，其中包含过时的客户端记录列表。服务器使用新的记录数据进行响应。客户端使用此响应数据使用新版本的记录更新本地缓存，然后重新呈现 UI 以显示最新的块数据。
#### 读取blocks

你的朋友打了个盹，但你继续在待办事项清单上工作。为了让他们知道您对列表进行了一些更改，您可以向他们发送一个指向您俩都在使用的 Notion 页面的链接。

在您的朋友醒来并点击链接后的最初几毫秒内，我们首先尝试仅使用本地数据加载该页面。在 Web 上，这意味着块内存中的数据。在我们的本机应用上，我们尝试从 RecordCache 持久化存储中加载不在内存中的块。但是，如果我们需要缺少的块数据，我们会停止并从 API 请求页面数据。

用于加载页面数据的 API 方法称为“loadPageChunk”——它从内容树的起点（可能是页面块的块 ID）下降，并返回内容树中的块以及正确呈现这些块所需的任何依赖记录。我们对“loadPageChunk”使用了几层缓存，但在最坏的情况下，这个 API 可能需要多次访问数据库，因为它以递归方式沿着树爬行以追踪块及其记录依赖项。

“loadPageChunk”加载的所有数据都将放入内存中（如果您使用的是该应用程序，则保存在 RecordCache 中）。一旦数据进入内存，我们就会布局页面并使用 React 进行渲染。
### blocks的将来下一步将如何发展

块是 Notion 使命中最基本的组成部分，它使任何人或企业都能根据他们的问题定制软件。这种架构为 Notion 的未来铺平了道路——新的块类型、自动化（[如 API](http://developers.notion.so/)、工作流程和功能，使您能够创建更强大的工具。
