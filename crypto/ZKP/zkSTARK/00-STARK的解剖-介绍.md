
> 这一系列文章是一个六部分的教程，解释了STARK证明系统的机制。它面向具有基本数学和编程知识的技术倾向受众。


### 需要的知识背景

- 有限域及其扩张域(Finite fields & extension fields)
- 有限域上的多项式，包括一元和多元多项式
- 快速傅里叶变换(FFT)
- 哈希函数
### STARKs是什么

在密码学证明系统领域，最令人兴奋的近期进展之一是STARKs的发展。它出现在蓬勃发展的区块链行业之后，而对于这个行业来说，普遍存在着适合其需求的证明系统：区块链网络通常由相互不信任的参与方组成，他们希望进行交易或根据状态演化规则更新集体状态，并使用秘密信息。由于参与方彼此不信任，他们需要手段来验证同伴提出的交易（或状态更新）是否有效。在这种环境中，zk-SNARKs天然具备计算完整性保障能力，并且具有以下特点：

- zk-SNARKs通常是通用型的，意味着它们能够证明任意计算过程的完整性；
- zk-SNARKs是非交互式的，也就是说完整性证明只包含一条消息；
- zk-SNARKs可高效验证，在比起简单地重新运行计算过程时要少得多工作量；
- zk-SNARKs具有零知识性质，也就是说它们不会泄露关于计算中秘密输入信息的任何信息。

![[Pasted image 20240429174651.png]]

Zk-SNARKs已经存在一段时间了，但STARK证明系统是一个相对较新的东西。它因以下几个原因而引人注目：

- 传统的zk-SNARKs依赖于尖端的密码学难题和假设，而STARK证明系统中唯一的密码学成分是一个抗碰撞哈希函数。因此，在理想化模型下，该证明系统可以被证明为后量子安全(In the literature, this idealization is known as the quantum random oracle model)。这与第一代SNARKs形成鲜明对比，后者使用双线性映射(bilinear map)，并且只能在不可伪造的假设下被证明为安全。
- STARKs中算术化领域与密码学难题无关，因此可以选择特定领域来优化性能。结果就是STARKs承诺(promise)具有非常快速的证明者(provers)。
- 传统zk-SNARKs依赖于一个值得信任的设置仪式(trust setup)来生成公共参数。仪式结束后，所使用的随机数必须被安全地遗忘掉。之所以信任这个仪式，是因为如果参与者拒绝或忽视删除这些加密毒物废料，则他们保留了伪造证据的能力。相反地，STARKs没有值得信任的设置过程(trust setup)，也没有加密毒物废料。

![[Pasted image 20240429175238.png]]

在本教程中，我试图解释许多部分如何相互配合。这种文字说明由一个基于[Rescue-Prime哈希函数](https://eprint.iacr.org/2020/1143.pdf)的Python实现支持，用于证明和验证简单计算。阅读或学习本教程后，您应该能够编写自己的零知识STARK Prover和Verifier，用于您选择的计算。
### 为什么使用呢？



