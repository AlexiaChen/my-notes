
## 下载STM32的入门资料

[资料下载 (jiangxiekeji.com)](https://jiangxiekeji.com/download.html)

https://pan.baidu.com/s/11WKAG6GZ4f0Kg020BhIvHw?pwd=1234


这个资料里面包含江科大的STM32的视频教程的几乎所有资料了 [江协科技的个人空间_哔哩哔哩_bilibili](https://space.bilibili.com/383400717) 

## 套件介绍

![[Pasted image 20230805173656.png]]

### 面包板

![[Pasted image 20230805173735.png]]

在这个套件中，导线和一些硬件模块都是插在面包板上完成连接的

![[Pasted image 20230805174159.png]]

上图是面包板专用的跳线，可以贴在面包板上插线，适合长时间插线的情况。

![[Pasted image 20230805174307.png]]

上图中，最上面的一小扎是面包板的飞线，比较长，适合挪动，比较适合经常挪动的接线情况。下面两大扎是杜邦线，分别为公对母和母对母的，用于插接一些电路模块。

## 其他模块

![[Pasted image 20230805174518.png]]

上图就是STM32最小系统板了，中间的正方形的黑色芯片就是STM32芯片。

![[Pasted image 20230805174632.png]]

上图是0.96寸的OLED显示屏模块（4引脚）有些时候也有7引脚版本，用于显示参数和变量。

![[Pasted image 20230805174755.png]]

上图的蓝色元件是电位器，主要用来进行AD转换实验的。

![[Pasted image 20230805174925.png]]

上图就是按键，是2引脚的。可以按照下图使用(红色圆圈):

![[Pasted image 20230805175031.png]]

![[Pasted image 20230805175108.png]]

上图五颜六色的是LED灯，入门就是点灯实验了。

![[Pasted image 20230805175200.png]]

上图是STLink，用来下载程序和供电的，当然也有DAP这个与之对标。DAP与STLink的区别主要就是:

![[Pasted image 20230806101136.png]]

![[Pasted image 20230805175302.png]]

上图是USB转串口模块，用来电脑和STM32进行串口通信。

![[Pasted image 20230805175405.png]]

上图是有源蜂鸣器模块，内置震荡源，接上电就可以响。相比无源蜂鸣器需要不断翻转IO口的啊哦做方式，更方便简单。

![[Pasted image 20230805175556.png]]

四个都是一些传感器模块，电路基本是一致的。

第一个是光敏电阻模块(4引脚)，其中2个引脚是用来供电的，还有两个是光敏电阻信号的模拟输出和数字输出，可以用来进行IO口读取实验或者AD实验。

第二个是热敏电阻模块(4引脚)，同上。第三个是对射式红外模块，可以配合遮光片用来计数或者配合编码盘用来测速。第四个是反射式红外模块，寻迹车会用到。

![[Pasted image 20230805180016.png]]

上图左边是W25Q64 Flash存储模块。可以存储数据，并且是用SPI总线进行通信。主要就是为了学习SPI通信。中间的是MPU6050陀螺仪和加速度计，可以测量芯片自身的姿态，比如四轴飞行器上一般都会有这个元件，是I2C总线进行通信的。

右边这个是旋转编码器，可以输出两路正交的方波信号，用于指示旋转的方向和速度，STM32里面有专门的编码器电路，可以很方便地识别这种信号，可以当做快速的按键使用，主要还是用来模拟编码器的测速。现在的编码电机一般都会配备霍尔传感器或者光电传感器，这些传感器的输出和这种旋转编码器是一样的，所以学习旋转编码器就可以了，插在面包板上也比较方便。

![[Pasted image 20230805180715.png]]

上图左边的是直流电机，右边是TB6612电机驱动模块。可以用来进行直流电机的PWM调速实验。

![[Pasted image 20230805180824.png]]

上图是SG90舵机，也是用PWM进行控制的。输出端可以像船舵一样，根据我们给定PWM信号的占空比固定在某一个角度上。可以用来做一些机器人或者机械臂的关节。

## STM32简介

- STM32是ST公司基于ARM Cortex-M内核开发的32位微控制器(MCU)。 ST公司的中文全称是意法半导体（STMicroelectronics）  MCU就是我们常说的单片机。Cortex-M内核是ARM公司设计的，相当于芯片的CPU，STM32就是基于这个内核封装的，当然，也有其他公司基于ARM的内核封装自己的芯片。
- STM32常应用在嵌入式领域，如智能车、无人机、机器人、无线通信、物联网、工业控制、娱乐电子产品等。关于无线通信这个，可以给STM32连接上一些2.4G无线模块或者蓝牙模块，WIFI模块，ZigBee模块。这个是物联网用的多，通过STM32驱动继电器来控制220V电路的通断。关于工业控制，甚至有些PLC设备里面的主控就是STM32。
- STM32功能强大、性能优异、片上资源丰富、功耗低，是一款经典的嵌入式微控制器

![[Pasted image 20230805181816.png]]

STM32有不同系列的产品。

### ARM介绍

ARM是ARM公司也是指ARM处理器内核，它只设计内核，不生产具体的实物，半导体公司完善内核周边电路并生产芯片。授权给别人，收取授权费过日子。

![[Pasted image 20230805182433.png]]

Cortex内核有A系列，R系列，和M系列。STM32就是M系列。R和M系列用于嵌入式，R面向实时的嵌入式领域，M主要就是MCU单片机领域了。A系列用于上层应用，手机芯片就用A系列了。高通，苹果等。

### STM32F1

![[Pasted image 20230805183418.png]]

![[Pasted image 20230805183527.png]]

上图颜色深的部分是STM32内核里面的外设，其他的都是内核外的外设。学习STM32，就是学习STM32的各种外设。 ^81274b

SysTick外设，其实主要是被RTOS使用的，是可以接入操作系统的。Free RTOS这些。操作系统需要SysTick提供定时来进行任务切换的功能。

操作外设之前，都必须使能它的时钟。就需要用到RCC来完成时钟的功能。GPIO就是通用的IO口，可以用GPIO来点灯，读取按键等。AFIO是复用IO口，完成复用功能端口的重定义，还有中断端口的配置。

EXTI是外部中断，配置好外部中断后，当引脚有电平变化时，就可以触发中断，让CPU来处理任务。TIM定时器，是STM32最常用，用的最多的外设之一。

ADC是模数转换器，这个系列的STM32内置了12位的AD转换器，可以直接读取IO口的模拟电压值，无需外部连接AD芯片。

DMA，直接内存访问。帮助CPI完成大量的数据搬运工作，CPU效率太慢了。

USART是同步或者异步串口（同时支持异步和同步串口）。UART是异步串口的意思、

I2C，SPI是两种通信协议，STM32也内置了它们的控制器，可以用硬件来输出时序波形。

CAN，USB也是通信协议了。CAN一般用于汽车领域。

RTC是实时时钟，在STM32内部完成年月日，时分秒的计时功能。还可以接外部备用电池，掉电也可以正常运行。

CRC。就是软件里面的CRC校验。

PWR，电源控制。可以让芯片进入睡眠模式等状态，省电。

BKP，备份寄存器。一段存储器，当系统掉电时。可以由备用电池保持数据。

IWDG，WWDG。独立看门狗和窗口看门狗。当单片机因为电磁干扰死机，或者程序设计不合理出现死循环，看门狗可以及时复位芯片，保证系统的稳定。

DAC是数模转换器，它可以在IO口直接输出模拟电压。ADC的逆过程。

SDIO是SD卡的接口，读取SD卡

FSMC是可变静态存储控制器，可以用于扩展内存。或者配置成其他总线协议，用于某些硬件操作，

USB OTG就是USB主机接口。用OTG功能，可以让STM32作为USB主机去读取其他USB设备

### 这个STM32型号的命名规则

![[Pasted image 20230805185838.png]]

### 这个STM32型号的系统结构

![[Pasted image 20230805190326.png]]

左上角就是Cortex-M3的内核，这个内核引出了3个总线。分别是ICode指令总线，DCode数据总线，System系统总线。ICode和DCode总线主要是用来连接Flash闪存的。Flash里面存储的就是我们编写的程序。ICode总线就是用来加载我们的程序指令的。DCode总线是用来加载数据的，比如常量和调试数据这些。System总线连接到SRAM和FSMC上。AHB（先进高性能总线）系统总线主要是用来挂接主要的外设的。APB总线是先进外设总监，用于连接一般的外设。因为AHB和APB的速率等方面有差异，所以中间需要加个桥接来完成数据的转换和缓存。

然后说说DMA，DMA也是连接到总线矩阵上，间接地连接各种外设，如果有外设需要搬运数据，就会发请求给DMA，DMA获得总线控制权，访问并转运数据。整个过程不需要CPU参与。

### STM32这个型号的引脚定义



![[SK03015-STM32F103C8T6引脚定义.png]]

一般拿到一个新的芯片时，都会着重看一下其引脚定义。有经验的人，引脚定义看完，也大概知道这个芯片如何使用了。其中有FT的，代表IO口能容忍5V的电压，没有FT的，只能容忍3.3V电压。主功能就是上电后，默认的功能，一般与引脚名称相同。默认复用功能就是IO口同时连接的外设功能引脚，这个在配置IO口的时候，可以选择是通用IO口还是复用功能。重定义功能就是如果你主功能和复用功能两个功能需要同时用，那么可以用重定义功能把复用功能映射到其他端口上。

梳理下各个引脚:

1. VBAT, 备用电池供电的引脚。这个引脚可以接一个3V的电池。当系统电源断电时，备用电池可以给内部的RTC时钟和BKP备份寄存器提供电源。
2. 3个功能，PC13, 侵入检测口，RTC口。做一些安全保障的功能。比如为了安全，可以在STM32的外壳加一个防拆的触点，接上电路到这个引脚。有人强行拆开设备，那触点断开，这个引脚的电平变化，就会触发STM32的侵入信号，然后就会清空数据来保证安全。RTC引脚可以用来输出RTC校准时钟，RTC闹钟脉冲或者秒脉冲。
3.  3， 4 引脚是IO口或者接32.768KHz的RTC晶振。5， 6号引脚接系统的主晶振，一般是8MHz。可以倍频，加速速率，作为系统主时钟。
4.  7号NRST是系统复位引脚，N代表它是低电平复位的。
5. 8， 9号引脚是内部模拟部分的电源，比如ADC，RC振荡器等。VSS是负极，接GND，VDD是正极，接3.3V。
6. 10 - 19号引脚都是IO口，PA0还兼具了wakeup的功能，这个可以用来唤醒处于待机模式的STM32。
7. 20号引脚，是IO口或者BOOT1引脚，BOOT引脚是用来配置启动模式的。看图推荐使用加粗的IO口，没有加粗的IO口可能需要配置。
8. 21，22号引脚都是IO口。
9. 23，24号引脚是是系统的主电源口，VSS,VDD同上 后面的35，36号引脚和47，48号引脚都是系统的主电源口。因为STM32内部采用了分区供电的方式，所以供电接口比较多。在使用时，把VSS都接GND，VDD都接3.3V即可。
10. 25- 33号引脚都是IO口。
11. 34，37-40号引脚，都是IO口或者调试端口。调试端口就是用来调试程序或者下载程序的。这个STM32支持SWD和JTAG两种调试模式。SWD需要两根线，分别是SDWIO和SWCLK。JTAG需要5根线，分别是JTMS，JTCK, JTDI, JTDO, NJTRST。  目前教程用的是STLink调试下载程序的，STLink只支持SWD的调试模式，所以只需要占用PA13和PA14这两个IO口。在使用SWD调试时，剩下的PA15,PB3,PB4可以切换为普通的IO口使用（需要程序配置）。
12. 41-43号，45，46号引脚都是IO口
13. 44号引脚。和BOOT1一样，也是用来作为启动配置的。

这些引脚，其实都可以在STM32的数据手册里面找到。

### 启动配置

![[Pasted image 20230805194752.png]]

这就是STM32的启动配置，就是之前提到的BOOT0和BOOT1两根引脚的功能，启动配置的作用就是指定程序开始运行的位置。一般情况下，程序都是在Flash程序存储器开始执行的，但是在某些情况下，也可以让程序在别的地方开始执行。

解释一下上图，BOOT0为0，也就是接地时，BOOT1的X代表无论是BOOT1是接地还是接什么，启动模式都是在主闪存存储器的模式。最常用的模式，一般情况下都是这个配置。

当BOO1接0也就是接地，BOOT0接1也就是接3.3V电源正的意思，就是系统存储器启动，就是用来串口下载用的，系统存储器存的就是STM32中的一段bootloader程序，作用就是接收串口的数据，然后刷新到主闪存中。这样就可以使用串口下载程序了，就不用STLink或JLink了。可以用来救急。

第三种模式是，一般是程序调试用的，用的少。

最后一句话就是，设置BOOT0 BOOT1引脚后，在系统上电后，SYSCLK第四个上升沿，BOOT引脚的状态是什么值就无所谓了也没用了。也就是BOOT引脚的状态，只在开机的一小段时间内有用。

### STM32最小系统的电路原理图

![[Pasted image 20230805200010.png]]

STM32要开始使用。首先需要把电源部分和最小系统部分的电路连接好，也就是引脚图上标记为橘红色和蓝色的部分接好。

上图右边就是STM32的供电的电路图，可以看到VSS VDD1-3这3个分区供电的主电源和VSSA VDDA模拟部分电源都连接了供电引脚。可以看到与之前提到的一样，VSS接GND接地，VDD都连接了3.3V的正极。但是发现供电有一个电容，电容就像蓄水池，可以保证供电电压的稳定，一般遇到供电，都会习惯上的加上几个滤波电容。

左上角就是晶振电路，这个型号的电路中间有一个8MHz的主时钟晶振，STM32的主晶振一般都是8MHz，8MHz经过内部锁相环倍频，得到72MHz的主频。可以看到这个晶振的两根引脚，接到了STM32芯片的5，6号引脚。另外电路中也接了2个20pF的电容，作为启震电容，电容的另一端接地即可。如果你需要RTC功能的话，还需要再接一个32.768KHz的晶振，电路和这个晶振一样，只是接到3，4号引脚。OSC32的意思就是32.768KHz晶振的意思。32768是2的15次方，内部RTC电路经过2^15分频，就可以生成1秒的时间信号了。

然后看复位电路，这个电路是一个10k的电阻和0.1uF的电容组成的，给单片机提供复位信号，中间的NRST接在STM32点的7号引脚。这个复位电路在上电的瞬间，电源通过电阻开始向电容充电，此时电容的点在这一瞬间肯定是没有充满的，所以电容呈现短路状态，此时NRST是低电平。当电容逐渐充满电时，电容相当于断路，此时NRST就会被R1电阻上拉为高电平。那上电的瞬间的波形就是先低电平，然后逐渐高电平。这个低电平，就可以提供STM32的上电复位信号。因为电容充电很快，所以单片机就在上电的瞬间复位了。这个复位电路还提供一个K1的开关按键，提供一个手动复位的功能，当开关接通瞬间，电容放电，然后NRST引脚也相当于接地了，所以就相当于手动产生了一个低电平复位信号，按键松开手后，NRST又回归高电平，此时单片机就从复位状态转为工作状态。

> 现在来解释为什么在上电的一瞬间，电容在充电时会导致NRST引脚处于低电平的情况。在复位电路中，通常会使用一个电容来延迟复位信号的生成。这个电容与一个上拉电阻连接在一起，形成一个RC电路。
> 
> 当系统上电时，电源电压开始升高，而电容开始充电。在电容充电的过程中，电压会逐渐增加，但一开始电容的电压非常低。在这个时刻，电容表现出短路的特性，因为它的电阻非常低（接近于短路）。因此，当系统刚刚上电时，NRST引脚会受到电容的影响，电压被短路到地，使得NRST引脚处于低电平状态。
> 
> 随着时间的推移，电容会逐渐充电，电压也会逐渐增加。当电压达到芯片规定的复位电压阈值时，复位电路会生成一个高电平的复位信号，将NRST引脚拉高，使芯片退出复位状态，开始正常的运行。
> 
> 这种设计可以确保在系统上电时，芯片能够正确地进行初始化，并避免在不稳定的状态下启动。通过使用电容来延迟复位信号的生成，可以在系统电源稳定之前保持芯片处于复位状态，以确保正确的启动和初始化过程。

> 为什么随着电容充电，电压会逐渐升高？ 在一个直流电路中，当一个电容器连接到电源上时，电容器开始充电。在充电的过程中，电容器的电压逐渐增加，直到达到电源电压的值。

> 电容器的充电过程涉及到电荷的积累。在初始时刻，电容器是未充电状态，没有电荷积累在其两个极板上。当电源施加电压时，电荷开始从电源流向电容器。由于电容器的特性，它可以存储电荷并在极板之间建立电场。 在充电的早期阶段，电容器的电压较低，电荷的积累速度较快。随着电荷的积累，电容器的电压会逐渐增加。这是因为电容器的电压与存储在其极板上的电荷量成正比。根据电容器的性质，电容器的电压与电荷量之间的关系可以通过以下公式表示：

> V = Q / C

> 其中，V表示电容器的电压，Q表示存储在电容器极板上的电荷量，C表示电容器的电容。根据这个公式，当电荷量增加时，电容器的电压也会相应增加。

再看，我们看启动配置的电路。H1相当于开关作用，拨动这个开关，就可以让BOOT引脚选择接3.3V还是GND，在配套的最小系统板上，需要使用跳线帽来充当开关的功能。

![[Pasted image 20230805210426.png]]

![[Pasted image 20230805210446.png]]

跳线帽，插左边两个脚时，就是接GND。插右边两个脚时，就是接3.3V。这样就可以配置BOOT的高低电平了。

最后我们来看看下载端口的电路。如果是用STLink/DAP下载程序的话，需要把SWDIO和WSDCLK也就是34，37号引脚引出来方便接线。

## 软件安装

[[2-1] 软件安装_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1th411z7sn?p=3&vd_source=d0fbfa94405374eeb9a05529fc055dcc)

在第一步的下载资料后的文件夹里有Keil5 MDK安装包。

### 安装器件支持包

就理解为芯片型号的插件，为了方便适应芯片的更新速度与Keil软件的开发速度不匹配。这样更灵活。不安装支持包，在新建工程时就不会出现相应的器件型号。支持包，在配套的资料里面有离线安装包了。

### USB转串口驱动

这个插上识别不出来设备管理器会有个感叹号，视频里面有讲解，Keil目录下有驱动的安装。下载资料中也有。

### STLink驱动

这个下载资料里面也有，但是目前入门配套的是DAP，DAP是免驱动的。只要接线就可以了。

## 新建工程

需要建立Keil工程进行管理。目前STM32的开发方式有三种，基于寄存器的，基于标准库(库函数), 基于HAL库的方式。基于寄存器的方式和51单片机的开发方式有点类似。基于寄存器的方式，最底层，最直接与硬件打交道。但是STM32的结构复杂，寄存器太多，所以基于寄存器的方式，目前是不推荐的。

基于库函数的方式，是使用ST官方提供好的封装好的函数。调用函数来间接的配置寄存器。提高开发效率。开发友好，不用太直接跟最底层打交道。

基于HAL库的方式可以用图形化快速配置STM32。比较适合快速上手STM32的情况，但是隐藏了底层逻辑。推荐适合非常有经验的熟手用，因为熟手不需要了。过了学习阶段。

先找到下载资料中提供的库函数的目录把，就在固件库的STM32F10x_StdPeriph_Lib_V3.5.0中，这个目录下面的Libraries文件夹就是库函数的文件了，新建工程会用到。Project文件夹是官方提供的工程示例和模板，使用库函数的时候可以参考。Utilities是STM32官方评估板的相关例程，评估板就是官方用STM32做的一个小电路板，用来测评STM32的。然后就是Release Notes文件和使用手册了。

这里介绍一下，Libraries文件夹底下为什么有CMSIS这个名词:

> CMSIS（Cortex Microcontroller Software Interface Standard）是一种由ARM公司提供的软件开发标准，旨在为ARM Cortex-M系列处理器的软件开发提供统一的接口和一致的编程模型。
> 
> CMSIS定义了一套通用的API（Application Programming Interface），用于访问处理器内核、外设和系统资源，以简化嵌入式软件的开发过程。它提供了一些常用功能的标准接口，例如中断控制、时钟配置、外设驱动程序等，使开发人员能够更方便地编写可移植、可重用的嵌入式软件。
> 
> CMSIS的主要组成部分包括：

> 1. Cortex Microcontroller Software Interface Standard Core (CMSIS-CORE)：提供了对Cortex-M处理器内核的访问和配置的API，包括中断控制、系统控制、寄存器访问等。
> 2. Cortex Microcontroller Software Interface Standard DSP Library (CMSIS-DSP)：提供了一套用于数字信号处理（DSP）的函数库，包括滤波、变换、数学运算等常用功能
> 3. Cortex Microcontroller Software Interface Standard RTOS (CMSIS-RTOS)：定义了一套与实时操作系统（RTOS）相关的API，用于在嵌入式系统中进行任务调度、同步和通信。
> 4. Cortex Microcontroller Software Interface Standard Device (CMSIS-Driver)：提供了一套用于外设驱动程序的API，用于访问和配置处理器的外设，如UART、SPI、I2C等。
> 5. Cortex Microcontroller Software Interface Standard SVD (CMSIS-SVD)：定义了一种用于描述器件寄存器和外设的XML格式，用于生成器件的软件开发工具和调试器的支持。
> 
> Keil是一家提供嵌入式软件开发工具的公司，他们开发了一款名为Keil MDK（Microcontroller Development Kit）的集成开发环境（IDE）。Keil MDK集成了CMSIS标准，并提供了对CMSIS的支持，使开发人员能够方便地使用CMSIS提供的功能和接口进行ARM Cortex-M系列处理器的软件开发。通过使用Keil MDK和CMSIS，开发人员可以更高效地开发嵌入式应用程序，并实现更好的移植性和可重用性。

`STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm` 这个目录下的文件就是STM32程序的启动文件，STM32的程序都是从启动文件开始执行的。把这些文件拷贝到你用Keil MDK新建的STM32的工程目录下，在这个目录下新建一个Startup的文件夹，把这些文件放在这个文件夹里面。

然后回到这个目录`STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x` 可以看到有一个`stm32f10x.h` 和两个`system`开头的`.c` `.h` 的C语言文件。第一个.h文件就是STM32的外设寄存器描述文件，跟51单片机的h文件regx52.h本质是做一件事。后面两个system开头的文件就是配置STM32时钟的，STM32主频72MHz就是system文件里面的函数配置的。同样把这三个文件复制粘贴到之前提到的Startup文件夹下面。

因为STM32内核寄存器描述文件和内核外设的寄存器描述文件不是放在一起的，所以我们还要添加内核描述文件。去`STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\CoreSupport` 目录下可以看到，内核寄存器描述的C语言文件。同样复制粘贴到Startup文件夹。

然后就可以用Keil添加之前复制粘贴的文件了。把新建工程里面的SourceGroup1修改成Startup方便阅读。

![[Pasted image 20230806095246.png]]

最后添加成上图的文件。然后把这个Startup添加成h文件的搜索路径，点击keil中的魔术棒按钮，点击C/C++ 选项卡中的Include Path。

> 解释下，上图的启动文件为啥用_md.s是根据芯片的型号来选择的。
> ![[Pasted image 20230806162538.png]]

然耨在Keil中新建一个group，叫User，专门放自己写的代码，比如main.c文件。在这个User中新建一个main.c文件，保存在User文件夹下。

main.c的内容:

```c
// 基于寄存器开发的模式，只是用来演示，基于寄存器开发之需要引入下面的头文件就可以了

#include "stm32f10x.h"

int main(void) 
{
	while(1) {}
		
	
}
```

这个Demo写好了，需要把程序烧录进STM32，所以需要使用到之前提到的DAP或者STLink了:

![[Pasted image 20230806101329.png]]

我们用的DAP。DAP插上以后其实不会亮灯，只会闪烁一下，与STLink不一样。

![[Pasted image 20230806101410.png]]

我四根母对母的杜邦线接入就可以了。照着上图。颜色最好一致啊，好区分和调试。红线一般接电源3.3V供电，蓝色接地。SDWCK是黄线，SWDIO是绿线。

最后完成就可以把DAP插入到电脑的USB上，正常的话就可以看到STM32板子上的PWR电源灯常亮。另一个连接在PC13口的灯是闪烁状态，这是芯片的一个测试程序。

然后配置Keil的Debugger为CMSIS-DAP Debugger（与配置inlcudepath差不多），然后点击右边的settings按钮，把Flash download那项其中有一个reset and run打上勾。这样程序一旦烧录进去就执行了，就不用手动去触发板子上的reset按钮了。

最后重新编译程序，点击Keil中的load按钮。就烧录进去了，这时你会看到PC13口的灯已经不闪烁了。

下面会利用基于寄存器配置的方法进行一个点灯实验。需要去看STM32的参考手册(Reference manual)。而不是数据手册(datasheet)。

> 通常在芯片选型的初期，首先要看《数据手册》以评估该产品是否能够满足设计上的功能需求；在基本选定所需产品后，需要察看技术参考手册以确定各功能模块的工作模式是否符合要求；在确定选型进入编程设计阶段时，需要详细阅读技术参考手册获知各项功能的具体实现方式和寄存器的配置使用。 在设计硬件时还需参考数据手册以获得电压、电流、管脚分配、驱动能力等信息。

接下来我们用寄存器的方式来控制PC13口的灯，在此之前需要提到一点，就是我们在操作任何外设之前，都需要使能外设的时钟，使能外设的时钟是通过RCC外设进行的，去参考手册找到RCC的章节。然后找到RCC的寄存器的小章节。

```c
// 基于寄存器开发的模式，只是用来演示，基于寄存器开发之需要引入下面的头文件就可以了

#include "stm32f10x.h"

int main(void) 
{
	// eanble IOPCEN(I/O port C clock enable) 其实就是打开GPIOC的时钟  因为PC13是Port C 13号口的意思
	RCC->APB2ENR = 0x00000010;
	
	// GPIOx CRH.  这个x是可以A到E的任意一个字母  config PC13, 13号口因为数字编码较大，所以在参考手册里面找到端口配置高寄存器
	// 其中的CNF13和MODE13就是配置13号口的。CNF13 = 00 (通用推挽输出模式) MODE13 = 11 (输出模式，最大速度50MHz) 
	GPIOC->CRH = 0x00300000;
	
	// 对配置好的PC13口输出数据，所以需要用到输出寄存器，对ODR13写1，这么PC13口就是高电平，写0就是低电平。
	// 因为这个灯是低电平点亮的，所以如果给ODR全0，那么这个灯才会亮，给ODR 0x00002000 就是灭
	// GPIOC->ODR = 0x00002000;
	GPIOC->ODR = 0x00000000;
	
	while(1) {}
	
}

```

接下来用库函数点灯。同样在工程目录下新建一个Library文件夹，然后去`STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver` 目录下把inc和src文件夹底下的库函数的源码文件拷贝到Library文件夹下面。然后添加进Keil工程作为一个新的Group叫Library。

到现在还不能直接用，现在去`STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template` 下面有两个it结尾的文件，以conf结尾的h文件，是用来配置库函数头文件的包含关系的。两个it结尾的文件是用来存放中断函数的。把这三个文件复制粘贴到工程目录下的User文件夹里面，添加进工程的User group中。

最后把`system_stm32f10x.h`中的

```c
#ifdef USE_STDPERIPH_DRIVER
  #include "stm32f10x_conf.h"
#endif
```

里面这个USE_STDPERIPH_DRIVER 宏拷贝到Keil IDE里面的predefile macro中，就是魔术棒里面的c/C++选项卡中的preprocessor define里面。如果用过VS的人，应该清楚是怎么回事，一样的道理。最后还要把头文件的目录添加上，因为在User和Library新加了h文件。

这样才可以使用标准外设的库函数。

下面是用库函数的完整代码，并且与寄存器的方式并存使用，让PC13口的灯闪烁:

```c
// 基于寄存器开发的模式，只是用来演示，基于寄存器开发之需要引入下面的头文件就可以了

#include "stm32f10x.h"

#define TRUE 1
#define FALSE 0

typedef int BOOL;


static void infinite_loop()
{
	while(1);
}

static void delay(uint32_t milliseconds)
{
    // 假设系统时钟频率为72MHz
    // 根据系统时钟频率和延迟时间计算出需要循环的次数
    uint32_t i;
    for(i = 0; i < (milliseconds * 72000); i++);
}


static void turn_pc13_light_based_on_register(BOOL enable)
{
	// eanble IOPCEN(I/O port C clock enable) 其实就是打开GPIOC的时钟  因为PC13是Port C 13号口的意思
	RCC->APB2ENR = 0x00000010;
	
	// GPIOx CRH.  这个x是可以A到E的任意一个字母  config PC13, 13号口因为数字编码较大，所以在参考手册里面找到端口配置高寄存器
	// 其中的CNF13和MODE13就是配置13号口的。CNF13 = 00 (通用推挽输出模式) MODE13 = 11 (输出模式，最大速度50MHz) 
	GPIOC->CRH = 0x00300000;
	
	// 对配置好的PC13口输出数据，所以需要用到输出寄存器，对ODR13写1，这么PC13口就是高电平，写0就是低电平。
	// 因为这个灯是低电平点亮的，所以如果给ODR全0，那么这个灯才会亮，给ODR 0x00002000 就是灭
	const int PC13_LIGHT_ON  = 0x00000000;
	const int PC13_LIGHT_OFF = 0x00002000;
	if (enable)
	{
		GPIOC->ODR = PC13_LIGHT_ON;
	}
	else
	{
		GPIOC->ODR = PC13_LIGHT_OFF;
	}
	
}

static void turn_pc13_light_based_on_std(BOOL enable)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStruct;
	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_13;
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOC, &GPIO_InitStruct);
	
	if (enable)
	{
		// Reset是置低电平
		GPIO_ResetBits(GPIOC, GPIO_Pin_13);
	}
	else
	{
		// Set是置高电平
		GPIO_SetBits(GPIOC, GPIO_Pin_13);
	}
}

int main(void) 
{
	for (int i = 0; i < 10; ++i)
	{
		turn_pc13_light_based_on_register(TRUE);
		delay(100);
	    turn_pc13_light_based_on_std(FALSE);
		delay(100);
	}
	infinite_loop();
}
```


最好放一张工程原理图:

![[Pasted image 20230806162819.png]]


## GPIO输出

### GPIO简介

- GPIO（General Purpose Input Output）通用输入输出口
- 可配置为8种输入输出模式
- 引脚电平：0V~3.3V，部分引脚可容忍5V
- 输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等
- 输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等

### GPIO基本结构

![[Pasted image 20230806164400.png]]

### GPIO位结构

也就是IO引脚的电路图

![[Pasted image 20230808212132.png]]

上图可以看到，引脚出有两个二极管，在GPIO引脚的硬件电路中，接VDD的二极管和接VSS的二极管通常用于保护引脚免受静电放电和电压干扰的影响。这些二极管可以将过高或过低的电压引导到VDD或VSS，以保护GPIO引脚和相关电路。

还有一个上拉电阻和下拉电阻：上拉电阻连接到GPIO引脚和VDD（正电源）之间，起到拉高引脚电平的作用。当GPIO引脚未连接到外部设备时，上拉电阻将引脚电平拉高至VDD电平，以避免引脚悬空导致的不确定状态。下拉电阻连接到GPIO引脚和VSS（地）之间，起到拉低引脚电平的作用。当GPIO引脚未连接到外部设备时，下拉电阻将引脚电平拉低至VSS电平，以避免引脚悬空导致的不确定状态。本质就是让IO引脚处于一个确定的状态。无论是高电平还是低电平。避免引脚的电平不确定性。

还有一种，TTL触发器是一种数字逻辑电路，常用于GPIO引脚的输入/输出驱动器中。它可以将输入信号进行放大和整形，并将其转换为与TTL（Transistor-Transistor Logic，晶体管-晶体管逻辑）电平兼容的信号。TTL触发器通常由多个晶体管和电阻组成，用于实现逻辑门功能。经过这个触发器的整形，就可以输入数据寄存器了。

图上面还有模拟输入，为了保证是模拟输入，所以接在触发器之前，这个线是接入到ADC上的。复用输入是为了给片上外设使用的，外设就是之前 提到的 [[#^81274b]]

同理，上图的输出与输入差不多一样。重点说一下，输出数据寄存器，某一个位为1，那么输出控制的后面的P-MOS就连通并且N-MOS断开，这样Vdd就导通，输出高电平，反之Vss导通，就是输出低电平。推挽输出模式下，STM32对IO口有绝对的控制权。高低电平都由STM32芯片说了算。

在开漏模式下，P-MOS是无效的，只有N-MOS在工作，这时候如果输出数据寄存器某一位为1，这时候，N-MOS也断开，同时P-MOS不工作，这时候，整个输出都相当于是断开，也就是高阻模式。相当于输出不了高电平。数据寄存器为0时，N-MOS导通，输出低电平。开漏模式就是通讯协议的方式，比如I2C的通信引脚，就是使用开漏模式。而且还可以防止干扰。

关闭模式主要是为了对引脚输入，让引脚输出关闭（两个MOS管都无效）。电平由外部信号来控制。

### GPIO的模式

|   |   |   |
|---|---|---|
|模式名称|性质|特征|
|浮空输入|数字输入|可读取引脚电平，若引脚悬空，则电平不确定|
|上拉输入|数字输入|可读取引脚电平，内部连接上拉电阻，悬空时默认高电平|
|下拉输入|数字输入|可读取引脚电平，内部连接下拉电阻，悬空时默认低电平|
|模拟输入|模拟输入|GPIO无效，引脚直接接入内部ADC|
|开漏输出|数字输出|可输出引脚电平，高电平为高阻态，低电平接VSS|
|推挽输出|数字输出|可输出引脚电平，高电平接VDD，低电平接VSS|
|复用开漏输出|数字输出|由片上外设控制，高电平为高阻态，低电平接VSS|
|复用推挽输出|数字输出|由片上外设控制，高电平接VDD，低电平接VSS|


通过GPIO的端口配置寄存器，端口可以配置成以上8种模式。

以上提到的都是STM32内部的GPIO外设，接下来我们就需要讲STM32外部的设备和电路。

### LED-蜂鸣器

- LED：发光二极管，正向通电点亮，反向通电不亮
- 有源蜂鸣器：内部自带振荡源，将正负极接上直流电压即可持续发声，频率固定
- 无源蜂鸣器：内部不带振荡源，需要控制器提供振荡脉冲才可发声，调整提供振荡脉冲的频率，可发出不同频率的声音

![[Pasted image 20230808220623.png]]

上图左边两幅图是，LED的两种接法，右边是蜂鸣器的两种接法。

我们先看左边。

- 左上：PA0口输出一个低电平，由于LED本质是一个二极管结构，所以，3.3V与低电平有一个电压差，方向跟二极管一致，电流导通，LED点亮。PA0输出高电平，3.3V与3.3V没有电压差，所以无电流。LED灭。这个叫做低电平驱动，一般的单片机都是这样的接法，都遵循一个高电平弱驱动，低电平强驱动的设计原则做的。
- 左下: PA0输出一个高电平，由于LED的负极接地，所以有电压差，LED灯亮。输出低电平，没有电压差，LED灭。

右边

- 右上： 注意有一个三极管的结构，是一个PNP三极管，这个三极管，只有基级电压低于发射极，那么电流导通，驱动蜂鸣器工作、如果给高电平，三极管端口，蜂鸣器不工作。
- 右下: 是一个NPN三极管结构，这个三极管是基极高电平导通电流，驱动蜂鸣器。低电平，蜂鸣器不工作。
## LED闪烁-LED流水灯-蜂鸣器

这欧里可以看这里:   [AlexiaChen/stm32-rs-learning-by-doing: STM32 program with Rust (github.com)](https://github.com/AlexiaChen/stm32-rs-learning-by-doing)  这里面有我写的代码例程。

## GPIO输入

### 开关模块

开关按键是管理电路通断的器件，但是在单片机中，这个开关抖动（按下和弹起）的瞬间，有一小段时间的不平稳。在单片机中，需要过滤掉，最简单的过滤就是让它delay一下，抖动是1-150ms之间。

![[Pasted image 20230812142522.png]]


### 传感器模块

传感器模块：传感器元件（光敏电阻/热敏电阻/红外接收管等）的电阻会随外界模拟量的变化而变化，通过与定值电阻分压即可得到模拟电压输出，再通过电压比较器进行二值化即可得到数字电压输出

![[Pasted image 20230812142549.png]]

上面就是几个传感器的电路图，中间图的N1就是一个可变电阻，它的阻值可以根据环境的光线，温度等模拟量进行变化。N1与R1这个定值电阻串联，记性压力分散。保护可变电阻。VCC接正极，GND负极。这样就是一个分压电路了，中间图的左下有一个C2的电容，主要是为了给中间的电压输出进行滤波的，消除干扰，保证数据电压波形的平滑。

图中的主要内容是光敏电阻传感器的电路。光敏电阻连接到 LM393 运算放大器的反相输入。LM393 是一个比较器，这意味着它可以比较其反相和同相输入端的电压。当反相输入端（光敏电阻）的电压低于同相输入端的电压时，LM393 的输出变为高电平。当反相输入端的电压高于同相输入端的电压时，LM393 的输出变为低电平。

光敏电阻感应照射在其上的光量。LM393 反相输入端的电压根据照射在光敏电阻上的光量而变化。
LM393 的输出根据反相输入端的电压而变高或变低。传感器模块的 DO 引脚由 LM383 的输出控制。该电路可用于检测光的存在，测量光量或根据光量控制其他设备。

N1这个可变电阻，无非就是光敏，或者热敏，又或者是红外接收管。

![[Pasted image 20230812150023.png]]

	上图都是开关的接法。一般大部分是上两幅图。先来将下PA0接开关的做法。当按下按键时，PA0直接被下拉到GND。此时读取PA0口的电压就是低电平。如果按键断开，那么PA0的引脚的电平就悬空，出现不确定的状态。这时候比如让PA0口的输入模式变成上拉输入，这样引脚即使悬空，PA0也是高电平。所以逻辑只能这样，按下按键为低电平，松手就为高电平。第二幅图，在外部接入了一个上拉电阻，当按键断开时，这时候引脚的PA0由于上拉做作用，自然是高电平。如果按键断开接地了，那么PA0口就是低电平。所以PA0的引脚可以配置为浮空输入或者上拉输入。

上图的下面两张图暂时不分析，大部分的电路都是上面的做法。

最后所以右边的传感器的电路，除了常见的GND和VCC，DO是数字输出口，AO是模拟输出口。目前接DO直接输出数字电信号，可以直接拿过来用。
## 按键控制LED-光敏传感器控制蜂鸣器

![[3-4 按键控制LED.jpg]]

两个开关用之前提到的左上角图片那个接法方法，把两个按键按钮，加到B11和B1上。其实也就是GPIOB11和GPIOB1了。
## OLED调试工具

- OLED（Organic Light Emitting Diode）：有机发光二极管
- OLED显示屏：性能优异的新型显示屏，具有功耗低、相应速度快、宽视角、轻薄柔韧等特点
- 0.96寸OLED模块：小巧玲珑、占用接口少、简单易用，是电子设计中非常常见的显示屏模块
供电：3~5.5V，通信协议：I2C/SPI，分辨率：128\*64


![[Pasted image 20230813172909.png]]

以上四个引脚的一般是用IIC协议，就是我写的本笔记使用的OLED屏幕。

![[Pasted image 20230813172959.png]]

7引脚的一般是SPI协议，

![[Pasted image 20230813173055.png]]

上图左边的是4引脚的OLED屏幕的原理图，VCC接3.3V供电，剩下的SCL和SDA是IIC的通信引脚。目前打算用GPIO口模拟IIC的通信协议，所以这2个端口，可以直接接在任意GPIO口上。

右边的图是7引脚的OLED原理图，处理供电，剩下的D0 D1这些全是SPI通信协议的引脚。同理，如果是GPIO口模拟的，也可以接在任意的GPIO口上就行了。

## OLED显示屏

这里可以看我github上的个人项目

## EXTI外部中断

### EXTI简介

- 中断：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行

- 中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源

- 中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回

![[Pasted image 20230818200042.png]]

- EXTI（Extern Interrupt）外部中断
- EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序
- 支持的触发方式：上升沿/下降沿/双边沿/软件触发
- 支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断
- 通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒（主要是16个GPIO引脚都可以作为EXIT中断引脚，其他后面的都是用来唤醒STM32低功耗模式等设置的）
- 触发响应方式：中断响应（其实就是申请中断）/事件响应（不会打断CPU，也不是中断，而是触发其他外设，比如ADC，DMA等）

### STM32中断

- 68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设（是STM32F1XX系列最多的终端数量，中断通道就是中断源的意思）几乎所有的模块都可以申请终端。

- 使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级

![[Pasted image 20230818200822.png]]

![[Pasted image 20230818200845.png]]

![[Pasted image 20230818200925.png]]

上图的表的灰色部分是内核的中断，一般用不到。白色的部分就是外设的中断了。一般我们都是用外设的中断。

上图的EXIT开头的就是这节需要学习的中断。

表中后面的地址是IDT，中断向量表，一般C语言编程是不需要这个表的。

### NVIC基本结构

NVIC是嵌入向量中断控制器，它是用来统一分配中断优先级和管理中断的。，NVIC是一个内核外设。

![[Pasted image 20230818201524.png]]

NVIC相当于CPU的助手，如果中断的引脚全部接入到CPU，就会很复杂麻烦，而NVIC就做了中断引脚这件事，可以接入很多中断源。

上面外设的线路上有一个斜杠和n代表一个外设可能会同时占用多个中断通道，所以这里有N条线。NVIC只有一个输出口。

### NVIC优先级分组

- NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级
- 抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队（中断号就是之前那个IDT表里面的数字，第二列）

![[Pasted image 20230818202039.png]]

### EXTI基本结构

![[Pasted image 20230818202757.png]]

上图，有AFIO中断引脚选择是因为，EXTI中断只能有16个通道，但是GPIOA-C每一个都有16根引脚，所以不够用，要选择。相同的Pin，不能同时触发中断。

### AFIO复用IO口

- AFIO主要用于引脚复用功能的选择和重定义

- 在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择

![[Pasted image 20230818203423.png]]

上图是要配置对应的寄存器才可以对中断通道进行选择。

### EXTI框图

![[Pasted image 20230818203629.png]]

什么时候使用EXIT中断，是CPU不可能随时监测信号的行为，有其他装置突发过来的脉冲信号，如果主动监测，一个是影响效率，一个是可能会错过波形，转瞬即逝。所以需要中断介入，立即打断CPU执行。

### 旋转编码器

- 旋转编码器：用来测量位置、速度或旋转方向的装置，当其旋转轴旋转时，其输出端可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度和方向
- 类型：机械触点式/霍尔传感器式/光栅式

![[Pasted image 20230818204401.png]]

可以测量方向。比如正交输出的编码器，两个触点输出的信号会有一个相位差。

### 硬件电路

![[Pasted image 20230818204932.png]]

先看左边的图，当转轴旋转时，左右两边的开关交替接通，未接通是，被VCC的上拉电阻上拉为一个高电平，接通时，因为导线接入GND，所以电平被拉低。A,B触点都是相同的原理，因为交替进行，所以输出的方波肯定有相位差。
## 对射式红外传感器计次-旋转编码器计次

看gituhb仓库 stm32-rs-learning-by-doing
## TIM定时中断

TIM是STM32中最重要，几乎也是最复杂的外设了。

### TIM简介

- TIM（Timer）定时器
- 定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断
- 16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时
- 不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能
- 根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型

### 定时器类型

![[Pasted image 20230819154828.png]]


注意，STM32F103C8T6 没有基本定时器。不同的型号，有不同的外设。

### 基本定时器框图

![[Pasted image 20230819155326.png]]

下面三个寄存器，PSC预分频器，自动重装载寄存器，CNT计数器构成了最基本的计数计时电路，所以这块电路就是时基单元。

预分频器通过CK_PSC连接到了内部时钟（因为基本定时器都是内部时钟源），这个内部时钟是CK_INT。内部时钟源来自RCC的TIMxCLK时钟，这里的频率值一般都是系统的主频72MHz。所以通向时基单元的基准频率就是72MHz。

预分频器可以对72MHz的计数时钟进行预分频，比如分频器写0，就是1分频，输入频率等于输出频率，如果是写1，就是2分频，输出频率=输入频率/2= 36MHz。写2就是3分频，以此类推。预分频器是16位的，最大值可以写65535，也就是65536分频。

计数器可以对预分频后的计数时钟进行计数。计数时钟每来一个上升沿，计数器的值就加1. 计数器也是16位的，最大值可以累加到65535。所以计数器会一直自增运行，当自增运行到目标值时，就会产生中断，完成了定时的任务。

所以还需要有一个存储目标值的寄存器，就是自动重装寄存器了，它也是16位的，它存的就是我们写入的计数的目标值。一旦计数器到达目标值，就会产生中断信号，并且清零计数器。计数器自动开始下一次的自动计时。

上图的向上的折线就是产生的中断，叫UI，更新中断。更新中断之后就会通往NVIC，我们再配置好NVIC的定时器通道，那定时器的更新中断就能够得到CPU的响应了。

向下的折线就是会产生一个事件，叫做更新事件。不会触发中断，但是可以触发内部其他电路的工作。

下面讲解一下主从模式触发DAC，这是STM32定时器的一大特色，用途就是在我们使用DAC的时候，可能会用DAC输出一段波形，就需要每隔一段时间来触发一次DAC，让它输出下一个电压点。
正常思路是，每隔一段时间在中断程序中调用代码手动触发一次DAC转换，然后DAC输出。但是会使主程序频繁被中断，影响其他逻辑的运行。不太好。

所以定时器就设计了一个主模式，使用这个模式，可以把定时器的更新事件，映射到这个触发输出TRGO（trigger out）的位置，TRGO直接接入到DAC的触发转换引脚上，这样定时器的更新就不需要中断来触发DAC转换了，让硬件自己完成。

### 通用定时器框图

![[Pasted image 20230819161628.png]]

首先，上图的时基单元，与基本定时器是一样的。

不过对于通用定时器而言，计数器的计数模式就不止向上计数（向上自增）一种了，通用定时器和高级定时器还支持向下计数模式和中央对齐模式。向下计数模式就是从重装寄存器的值开始，向下自减，减到0之后，回到重装寄存器设定的值同时申请中断。

中央对齐的计数模式，就是从0开始，先向上自增，到重装寄存器的值，申请中断，然后向下自减，到0，再申请中断。

上图自动重装载寄存器的上面的部分，就是内外时钟源选择和主从触发模式的结构了。通用定时器可以选择内部时钟源或者外部时钟源。第一个外部时钟就是来自TIMx_ETR引脚上的外部时钟。比如你回过去看引脚图，TIM2_CH1_ETR就是复用在了PA0引脚的位置。都可以找到。

所以看到以上的例子，我们就可以在TIM2的ETR引脚，也就是PA0上接一个外部方波时钟，然后配置一下内部的极性选择，边沿检测和预频分器电路。再配置一下输入滤波电路。这两块电路可以对外部时钟进行一定的整形，因为是外部引脚的时钟，所以难免会有毛刺，这些电路可以对输入的波形进行滤波。最后滤波的信号，兵分两路，上面一路ETRF进入触发控制器，紧跟着就可以选择作为时基单元的时钟了。如果你想在ETR外部引脚提供时钟，或者想对ETR时钟进行计数，把这个定时器当作计数器使用，那就可以配置，进入ETRF这一路的电路。在STM32中，这一路也叫做外部时钟模式2.

下面还有一路可以提供市政，就是TRGI(Trigger In), 用来触发输入使用的，可以触发定时器的从模式。这里后面再说。现在要说的是，这个触发输入作为外部时钟来使用的情况，可以把TRGI当作外部时钟来使用，这一路叫做外部时钟模式1。通过这路的外部时钟有哪些？第一个就是ETR引脚信号。 两路信号其实都是一样的，只是下面一路会占用触发输入的通道而已。第二个就是ITR信号，这一部分的时钟信号是来自其他定时器的，从右边可以看到，这个主模式的输出TRGO可以通向其他定时器，如果接到其他定时器，其实就相当于接到左边的其他定时器的ITR引脚上来了，ITR0-ITR3分别来自其他4个定时器的TRGO输出。比如看手册，就可以看到，TIM2的ITR0接在了TIM1的TRGO上。这一路其实就可以实现定时器的级联功能。比如先初始化TIM3，然后使用主模式，把它的更新事件映射到TRGO上，再初始化TIM2，选择ITR2，对应的就是TIM3的TRGO。然后设置外部时钟模式1，这样TIM3的更新事件就可以驱动TIM2的时基单元，也就实现了定时器的级联。

接着来看，TI1P_ED这里连接的是输入捕获单元的TIMx_CH1引脚，也就是从CH1引脚获得时钟，这里加入了一个ED(Edge)其实就是边沿的意思。也就是通过这路的时钟，上升沿和下降沿均有效。

最后，这个时钟还能通过TI1FP1和TI2FP2获得。其中TI1FP1是连接了CH1引脚的时钟。TI1FP2连接了CH2引脚的时钟。

到这里外部时钟模式1就介绍完了，就是外部时钟模式1的输入可以是ETR引脚，其他定时器，CH1引脚的边沿，CH1引脚，CH2引脚。

如果要使用外部时钟，首选还是ETR引脚外部时钟模式2的输入。编码器接口可以读取正交编码器的输出波形。

现在需要讲解上图下面一大部分的电路，右边这一块是输出比较电路，总共有4个通道，分别对应CH1到CH4的引脚。可以用来输出PWM波形，驱动电机。左边这块是输入捕获电路，也是4个通道，对应的也是CH1到CH4的引脚，可以用来测量输入方波的频率等。中间的寄存器是捕获/比较寄存器, 是输入捕获和输出比较电路共用的，因为输入捕获和输出比较电路不能同时使用，所以这里寄存器是共用的，引脚也是共用的。

### 高级定时器基本框图

![[Pasted image 20230819220414.png]]

高级定时器的左上的很大一部分电路与通用定时器基本差不多，主要的改动就是右下和左下这两个部分。

右下部分就是，申请中断的地方，增加了一个重复次数计数器，有了这个之后，就可以做到，每隔几个周期，才发生一次更新事件和更新中断。原来是一个周期就发生一次。相当于对输出的更新信号又做了一次分频。

DTG(Dead Time Generate)是死区生成电路，右边的输出引脚，由原来的一个变成了两个互补的输出，可以输出一对互补的PWM波。这些电路是为了驱动三相无刷电机的，这个电机还是比较常用的，四轴飞行器，电动车的后轮，电钻等，里面都有可能是这个电机。三相无刷电机的驱动电路一般需要3个桥臂，每个桥臂2个大功率开关管来控制。总共需要6个开关管，所以输出PWM引脚的前三路就变成了互补的输出。第四路就没有变化，因为三相电机，只需要三路就可以了。为了防止互补输出的PWM驱动桥臂时，在开关切换的瞬间，由于器件的不理想，造成短暂的直通现象。所以就有了DTG电路，在开关切换的瞬间，产生一定时长的死区，让桥臂的上下管全部关断，防止直通现象。

最后一部分，就是刹车输入的功能，为了给电机驱动提供安全保障的，如果外部引脚TIMx_BKIN产生了刹车信号，或者内部时钟失效，产生了故障。那么控制电路就会自动切断电机的输出，防止意外发生。

### 定时中断基本结构

![[Pasted image 20230819222155.png]]

这幅图就是之前的电路图的高级抽象，把关键部分列了出来。

### 预分频器时序

![[Pasted image 20230819222531.png]]

CK_PSC是预分频器的输入时钟，这个时钟在不断地运行。
CNT_EN是计数器使能，高电平计数器正常运行，低电平计数器停止。
CK_CNT是计数器时钟，其实就是预分频器的时钟输出，也是计数器的时钟输入。

可以看淡计数器未使能的情况下，计数器时钟是低电平，未运行。使能以后，经过一小段时间，正常工作，这个就是参数1的情况，也就是2分频，计数器的时钟等于预分频器前的时钟。后半段，预分频器系数变为2了，计数器的时钟输入就变成了预分频器前时钟的一半了。在计数器时钟输入的驱动下，下面的计数器寄存器也跟随时钟的上升沿不断自增，看上面的图，寄存器的值变为0，就可以推断出，自动重装载寄存器的值是FC。所以在重新计数的时候，下面就产生一个更新事件UEV（一个高电平）。

下面三行时序是预分频寄存器的一种缓冲机制，是为了在计数周期内，改变分频系数，缓冲是让周期完成了，才会设置为新的分频系数、

### 计数器时序图

![[Pasted image 20230819223933.png]]

分频系数为2.  第三行就是计数器的输入时钟了，因为系数为2，所以这个频率是CK_INT的频率除以2，当计数器增长到36的时候，就溢出，又重新开始计数。这时候，产生更新事件，同时，设置中断标志位，也就是高电平。这个标志位只要设置为1，就回去申请中断。中断程序中手动清零，就是清理这个标志位了。

### RCC时钟树

![[Pasted image 20230819225017.png]]

ST公司已经帮我们写好了，在进入main函数之前，有一个SystemInit函数，就是配置这个RCC时钟数的。RCC是高速晶振（也就是系统时钟），连接着AHB,APB1 APB2。RTC连接的是低速晶振。

## 定时器定时中断-定时器外部时钟

## TIM输出比较

## PWM驱动LED呼吸灯-PWM驱动舵机-PWM驱动直流电机

## TIM输入捕获

## 输入捕获模式测频率-PWMI模式测频率占空比

## TIM编码器接口

## 编码器接口测速

## ADC模数转换器

## AD单通道-AD多通道

## DMA存储器存取

## DMA数据转运-DMA+AD多通道

## USART串口协议

## USART串口外设

## 串口发送-串口发送+接收

## USART串口数据包

## 串口收发HEX数据包-串口收发文本数据包

## Flymcu串口下载-STLink utility

## I2C通信协议

## MPU6050简介

## 软件I2C读写MPU6050

## I2C通信外设

## 硬件I2C读写MPU6050

## SPI通信协议

## W25Q64简介

## 软件SPI读写W25Q64

## 硬件SPI读写W25Q64

## Unix时间戳

## BKP备份寄存器-RTC实时时钟

## 读写备份寄存器-实时时钟

## PWR电源控制