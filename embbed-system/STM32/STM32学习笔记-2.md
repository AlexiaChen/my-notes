
## GPIO输出

### GPIO简介

- GPIO（General Purpose Input Output）通用输入输出口
- 可配置为8种输入输出模式
- 引脚电平：0V~3.3V，部分引脚可容忍5V
- 输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等
- 输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等

### GPIO基本结构

![[Pasted image 20230806164400.png]]

### GPIO位结构

也就是IO引脚的电路图

![[Pasted image 20230808212132.png]]

上图可以看到，引脚出有两个二极管，在GPIO引脚的硬件电路中，接VDD的二极管和接VSS的二极管通常用于保护引脚免受静电放电和电压干扰的影响。这些二极管可以将过高或过低的电压引导到VDD或VSS，以保护GPIO引脚和相关电路。

还有一个上拉电阻和下拉电阻：上拉电阻连接到GPIO引脚和VDD（正电源）之间，起到拉高引脚电平的作用。当GPIO引脚未连接到外部设备时，上拉电阻将引脚电平拉高至VDD电平，以避免引脚悬空导致的不确定状态。下拉电阻连接到GPIO引脚和VSS（地）之间，起到拉低引脚电平的作用。当GPIO引脚未连接到外部设备时，下拉电阻将引脚电平拉低至VSS电平，以避免引脚悬空导致的不确定状态。本质就是让IO引脚处于一个确定的状态。无论是高电平还是低电平。避免引脚的电平不确定性。

还有一种，TTL触发器是一种数字逻辑电路，常用于GPIO引脚的输入/输出驱动器中。它可以将输入信号进行放大和整形，并将其转换为与TTL（Transistor-Transistor Logic，晶体管-晶体管逻辑）电平兼容的信号。TTL触发器通常由多个晶体管和电阻组成，用于实现逻辑门功能。经过这个触发器的整形，就可以输入数据寄存器了。

图上面还有模拟输入，为了保证是模拟输入，所以接在触发器之前，这个线是接入到ADC上的。复用输入是为了给片上外设使用的，外设就是之前 提到的 [[#^81274b]]

同理，上图的输出与输入差不多一样。重点说一下，输出数据寄存器，某一个位为1，那么输出控制的后面的P-MOS就连通并且N-MOS断开，这样Vdd就导通，输出高电平，反之Vss导通，就是输出低电平。推挽输出模式下，STM32对IO口有绝对的控制权。高低电平都由STM32芯片说了算。

在开漏模式下，P-MOS是无效的，只有N-MOS在工作，这时候如果输出数据寄存器某一位为1，这时候，N-MOS也断开，同时P-MOS不工作，这时候，整个输出都相当于是断开，也就是高阻模式。相当于输出不了高电平。数据寄存器为0时，N-MOS导通，输出低电平。开漏模式就是通讯协议的方式，比如I2C的通信引脚，就是使用开漏模式。而且还可以防止干扰。

关闭模式主要是为了对引脚输入，让引脚输出关闭（两个MOS管都无效）。电平由外部信号来控制。

### GPIO的模式

|   |   |   |
|---|---|---|
|模式名称|性质|特征|
|浮空输入|数字输入|可读取引脚电平，若引脚悬空，则电平不确定|
|上拉输入|数字输入|可读取引脚电平，内部连接上拉电阻，悬空时默认高电平|
|下拉输入|数字输入|可读取引脚电平，内部连接下拉电阻，悬空时默认低电平|
|模拟输入|模拟输入|GPIO无效，引脚直接接入内部ADC|
|开漏输出|数字输出|可输出引脚电平，高电平为高阻态，低电平接VSS|
|推挽输出|数字输出|可输出引脚电平，高电平接VDD，低电平接VSS|
|复用开漏输出|数字输出|由片上外设控制，高电平为高阻态，低电平接VSS|
|复用推挽输出|数字输出|由片上外设控制，高电平接VDD，低电平接VSS|


通过GPIO的端口配置寄存器，端口可以配置成以上8种模式。

以上提到的都是STM32内部的GPIO外设，接下来我们就需要讲STM32外部的设备和电路。

### LED-蜂鸣器

- LED：发光二极管，正向通电点亮，反向通电不亮
- 有源蜂鸣器：内部自带振荡源，将正负极接上直流电压即可持续发声，频率固定
- 无源蜂鸣器：内部不带振荡源，需要控制器提供振荡脉冲才可发声，调整提供振荡脉冲的频率，可发出不同频率的声音

![[Pasted image 20230808220623.png]]

上图左边两幅图是，LED的两种接法，右边是蜂鸣器的两种接法。

我们先看左边。

- 左上：PA0口输出一个低电平，由于LED本质是一个二极管结构，所以，3.3V与低电平有一个电压差，方向跟二极管一致，电流导通，LED点亮。PA0输出高电平，3.3V与3.3V没有电压差，所以无电流。LED灭。这个叫做低电平驱动，一般的单片机都是这样的接法，都遵循一个高电平弱驱动，低电平强驱动的设计原则做的。
- 左下: PA0输出一个高电平，由于LED的负极接地，所以有电压差，LED灯亮。输出低电平，没有电压差，LED灭。

右边

- 右上： 注意有一个三极管的结构，是一个PNP三极管，这个三极管，只有基级电压低于发射极，那么电流导通，驱动蜂鸣器工作、如果给高电平，三极管端口，蜂鸣器不工作。
- 右下: 是一个NPN三极管结构，这个三极管是基极高电平导通电流，驱动蜂鸣器。低电平，蜂鸣器不工作。
## LED闪烁-LED流水灯-蜂鸣器

这欧里可以看这里:   [AlexiaChen/stm32-rs-learning-by-doing: STM32 program with Rust (github.com)](https://github.com/AlexiaChen/stm32-rs-learning-by-doing)  这里面有我写的代码例程。

## GPIO输入

### 开关模块

开关按键是管理电路通断的器件，但是在单片机中，这个开关抖动（按下和弹起）的瞬间，有一小段时间的不平稳。在单片机中，需要过滤掉，最简单的过滤就是让它delay一下，抖动是1-150ms之间。

![[Pasted image 20230812142522.png]]


### 传感器模块

传感器模块：传感器元件（光敏电阻/热敏电阻/红外接收管等）的电阻会随外界模拟量的变化而变化，通过与定值电阻分压即可得到模拟电压输出，再通过电压比较器进行二值化即可得到数字电压输出

![[Pasted image 20230812142549.png]]

上面就是几个传感器的电路图，中间图的N1就是一个可变电阻，它的阻值可以根据环境的光线，温度等模拟量进行变化。N1与R1这个定值电阻串联，记性压力分散。保护可变电阻。VCC接正极，GND负极。这样就是一个分压电路了，中间图的左下有一个C2的电容，主要是为了给中间的电压输出进行滤波的，消除干扰，保证数据电压波形的平滑。

图中的主要内容是光敏电阻传感器的电路。光敏电阻连接到 LM393 运算放大器的反相输入。LM393 是一个比较器，这意味着它可以比较其反相和同相输入端的电压。当反相输入端（光敏电阻）的电压低于同相输入端的电压时，LM393 的输出变为高电平。当反相输入端的电压高于同相输入端的电压时，LM393 的输出变为低电平。

光敏电阻感应照射在其上的光量。LM393 反相输入端的电压根据照射在光敏电阻上的光量而变化。
LM393 的输出根据反相输入端的电压而变高或变低。传感器模块的 DO 引脚由 LM383 的输出控制。该电路可用于检测光的存在，测量光量或根据光量控制其他设备。

N1这个可变电阻，无非就是光敏，或者热敏，又或者是红外接收管。

![[Pasted image 20230812150023.png]]

	上图都是开关的接法。一般大部分是上两幅图。先来将下PA0接开关的做法。当按下按键时，PA0直接被下拉到GND。此时读取PA0口的电压就是低电平。如果按键断开，那么PA0的引脚的电平就悬空，出现不确定的状态。这时候比如让PA0口的输入模式变成上拉输入，这样引脚即使悬空，PA0也是高电平。所以逻辑只能这样，按下按键为低电平，松手就为高电平。第二幅图，在外部接入了一个上拉电阻，当按键断开时，这时候引脚的PA0由于上拉做作用，自然是高电平。如果按键断开接地了，那么PA0口就是低电平。所以PA0的引脚可以配置为浮空输入或者上拉输入。

上图的下面两张图暂时不分析，大部分的电路都是上面的做法。

最后所以右边的传感器的电路，除了常见的GND和VCC，DO是数字输出口，AO是模拟输出口。目前接DO直接输出数字电信号，可以直接拿过来用。
## 按键控制LED-光敏传感器控制蜂鸣器

![[3-4 按键控制LED.jpg]]

两个开关用之前提到的左上角图片那个接法方法，把两个按键按钮，加到B11和B1上。其实也就是GPIOB11和GPIOB1了。
## OLED调试工具

- OLED（Organic Light Emitting Diode）：有机发光二极管
- OLED显示屏：性能优异的新型显示屏，具有功耗低、相应速度快、宽视角、轻薄柔韧等特点
- 0.96寸OLED模块：小巧玲珑、占用接口少、简单易用，是电子设计中非常常见的显示屏模块
供电：3~5.5V，通信协议：I2C/SPI，分辨率：128\*64


![[Pasted image 20230813172909.png]]

以上四个引脚的一般是用IIC协议，就是我写的本笔记使用的OLED屏幕。

![[Pasted image 20230813172959.png]]

7引脚的一般是SPI协议，

![[Pasted image 20230813173055.png]]

上图左边的是4引脚的OLED屏幕的原理图，VCC接3.3V供电，剩下的SCL和SDA是IIC的通信引脚。目前打算用GPIO口模拟IIC的通信协议，所以这2个端口，可以直接接在任意GPIO口上。

右边的图是7引脚的OLED原理图，处理供电，剩下的D0 D1这些全是SPI通信协议的引脚。同理，如果是GPIO口模拟的，也可以接在任意的GPIO口上就行了。

## OLED显示屏

这里可以看我github上的个人项目

## EXTI外部中断

### EXTI简介

- 中断：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行

- 中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源

- 中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回

![[Pasted image 20230818200042.png]]

- EXTI（Extern Interrupt）外部中断
- EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序
- 支持的触发方式：上升沿/下降沿/双边沿/软件触发
- 支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断
- 通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒（主要是16个GPIO引脚都可以作为EXIT中断引脚，其他后面的都是用来唤醒STM32低功耗模式等设置的）
- 触发响应方式：中断响应（其实就是申请中断）/事件响应（不会打断CPU，也不是中断，而是触发其他外设，比如ADC，DMA等）

### STM32中断

- 68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设（是STM32F1XX系列最多的终端数量，中断通道就是中断源的意思）几乎所有的模块都可以申请终端。

- 使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级

![[Pasted image 20230818200822.png]]

![[Pasted image 20230818200845.png]]

![[Pasted image 20230818200925.png]]

上图的表的灰色部分是内核的中断，一般用不到。白色的部分就是外设的中断了。一般我们都是用外设的中断。

上图的EXIT开头的就是这节需要学习的中断。

表中后面的地址是IDT，中断向量表，一般C语言编程是不需要这个表的。

### NVIC基本结构

NVIC是嵌入向量中断控制器，它是用来统一分配中断优先级和管理中断的。，NVIC是一个内核外设。

![[Pasted image 20230818201524.png]]

NVIC相当于CPU的助手，如果中断的引脚全部接入到CPU，就会很复杂麻烦，而NVIC就做了中断引脚这件事，可以接入很多中断源。

上面外设的线路上有一个斜杠和n代表一个外设可能会同时占用多个中断通道，所以这里有N条线。NVIC只有一个输出口。

### NVIC优先级分组

- NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级
- 抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队（中断号就是之前那个IDT表里面的数字，第二列）

![[Pasted image 20230818202039.png]]

### EXTI基本结构

![[Pasted image 20230818202757.png]]

上图，有AFIO中断引脚选择是因为，EXTI中断只能有16个通道，但是GPIOA-C每一个都有16根引脚，所以不够用，要选择。相同的Pin，不能同时触发中断。

### AFIO复用IO口

- AFIO主要用于引脚复用功能的选择和重定义

- 在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择

![[Pasted image 20230818203423.png]]

上图是要配置对应的寄存器才可以对中断通道进行选择。

### EXTI框图

![[Pasted image 20230818203629.png]]

什么时候使用EXIT中断，是CPU不可能随时监测信号的行为，有其他装置突发过来的脉冲信号，如果主动监测，一个是影响效率，一个是可能会错过波形，转瞬即逝。所以需要中断介入，立即打断CPU执行。

### 旋转编码器

- 旋转编码器：用来测量位置、速度或旋转方向的装置，当其旋转轴旋转时，其输出端可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度和方向
- 类型：机械触点式/霍尔传感器式/光栅式

![[Pasted image 20230818204401.png]]

可以测量方向。比如正交输出的编码器，两个触点输出的信号会有一个相位差。

### 硬件电路

![[Pasted image 20230818204932.png]]

先看左边的图，当转轴旋转时，左右两边的开关交替接通，未接通是，被VCC的上拉电阻上拉为一个高电平，接通时，因为导线接入GND，所以电平被拉低。A,B触点都是相同的原理，因为交替进行，所以输出的方波肯定有相位差。
## 对射式红外传感器计次-旋转编码器计次

看gituhb仓库 stm32-rs-learning-by-doing
## TIM定时中断

TIM是STM32中最重要，几乎也是最复杂的外设了。

### TIM简介

- TIM（Timer）定时器
- 定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断
- 16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时
- 不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能
- 根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型

### 定时器类型

![[Pasted image 20230819154828.png]]


注意，STM32F103C8T6 没有基本定时器。不同的型号，有不同的外设。

### 基本定时器框图

![[Pasted image 20230819155326.png]]

下面三个寄存器，PSC预分频器，自动重装载寄存器，CNT计数器构成了最基本的计数计时电路，所以这块电路就是时基单元。

预分频器通过CK_PSC连接到了内部时钟（因为基本定时器都是内部时钟源），这个内部时钟是CK_INT。内部时钟源来自RCC的TIMxCLK时钟，这里的频率值一般都是系统的主频72MHz。所以通向时基单元的基准频率就是72MHz。

预分频器可以对72MHz的计数时钟进行预分频，比如分频器写0，就是1分频，输入频率等于输出频率，如果是写1，就是2分频，输出频率=输入频率/2= 36MHz。写2就是3分频，以此类推。预分频器是16位的，最大值可以写65535，也就是65536分频。

计数器可以对预分频后的计数时钟进行计数。计数时钟每来一个上升沿，计数器的值就加1. 计数器也是16位的，最大值可以累加到65535。所以计数器会一直自增运行，当自增运行到目标值时，就会产生中断，完成了定时的任务。

所以还需要有一个存储目标值的寄存器，就是自动重装寄存器了，它也是16位的，它存的就是我们写入的计数的目标值。一旦计数器到达目标值，就会产生中断信号，并且清零计数器。计数器自动开始下一次的自动计时。

上图的向上的折线就是产生的中断，叫UI，更新中断。更新中断之后就会通往NVIC，我们再配置好NVIC的定时器通道，那定时器的更新中断就能够得到CPU的响应了。

向下的折线就是会产生一个事件，叫做更新事件。不会触发中断，但是可以触发内部其他电路的工作。

下面讲解一下主从模式触发DAC，这是STM32定时器的一大特色，用途就是在我们使用DAC的时候，可能会用DAC输出一段波形，就需要每隔一段时间来触发一次DAC，让它输出下一个电压点。
正常思路是，每隔一段时间在中断程序中调用代码手动触发一次DAC转换，然后DAC输出。但是会使主程序频繁被中断，影响其他逻辑的运行。不太好。

所以定时器就设计了一个主模式，使用这个模式，可以把定时器的更新事件，映射到这个触发输出TRGO（trigger out）的位置，TRGO直接接入到DAC的触发转换引脚上，这样定时器的更新就不需要中断来触发DAC转换了，让硬件自己完成。

### 通用定时器框图

![[Pasted image 20230819161628.png]]

首先，上图的时基单元，与基本定时器是一样的。

不过对于通用定时器而言，计数器的计数模式就不止向上计数（向上自增）一种了，通用定时器和高级定时器还支持向下计数模式和中央对齐模式。向下计数模式就是从重装寄存器的值开始，向下自减，减到0之后，回到重装寄存器设定的值同时申请中断。

中央对齐的计数模式，就是从0开始，先向上自增，到重装寄存器的值，申请中断，然后向下自减，到0，再申请中断。

上图自动重装载寄存器的上面的部分，就是内外时钟源选择和主从触发模式的结构了。通用定时器可以选择内部时钟源或者外部时钟源。第一个外部时钟就是来自TIMx_ETR引脚上的外部时钟。比如你回过去看引脚图，TIM2_CH1_ETR就是复用在了PA0引脚的位置。都可以找到。

所以看到以上的例子，我们就可以在TIM2的ETR引脚，也就是PA0上接一个外部方波时钟，然后配置一下内部的极性选择，边沿检测和预频分器电路。再配置一下输入滤波电路。这两块电路可以对外部时钟进行一定的整形，因为是外部引脚的时钟，所以难免会有毛刺，这些电路可以对输入的波形进行滤波。最后滤波的信号，兵分两路，上面一路ETRF进入触发控制器，紧跟着就可以选择作为时基单元的时钟了。如果你想在ETR外部引脚提供时钟，或者想对ETR时钟进行计数，把这个定时器当作计数器使用，那就可以配置，进入ETRF这一路的电路。在STM32中，这一路也叫做外部时钟模式2.

下面还有一路可以提供时钟，就是TRGI(Trigger In), 用来触发输入使用的，可以触发定时器的从模式。这里后面再说。现在要说的是，这个触发输入作为外部时钟来使用的情况，可以把TRGI当作外部时钟来使用，这一路叫做外部时钟模式1。通过这路的外部时钟有哪些？第一个就是ETR引脚信号。 两路信号其实都是一样的，只是下面一路会占用触发输入的通道而已。第二个就是ITR信号，这一部分的时钟信号是来自其他定时器的，从右边可以看到，这个主模式的输出TRGO可以通向其他定时器，如果接到其他定时器，其实就相当于接到左边的其他定时器的ITR引脚上来了，ITR0-ITR3分别来自其他4个定时器的TRGO输出。比如看手册，就可以看到，TIM2的ITR0接在了TIM1的TRGO上。这一路其实就可以实现定时器的级联功能。比如先初始化TIM3，然后使用主模式，把它的更新事件映射到TRGO上，再初始化TIM2，选择ITR2，对应的就是TIM3的TRGO。然后设置外部时钟模式1，这样TIM3的更新事件就可以驱动TIM2的时基单元，也就实现了定时器的级联。

接着来看，TI1P_ED这里连接的是输入捕获单元的TIMx_CH1引脚，也就是从CH1引脚获得时钟，这里加入了一个ED(Edge)其实就是边沿的意思。也就是通过这路的时钟，上升沿和下降沿均有效。

最后，这个时钟还能通过TI1FP1和TI2FP2获得。其中TI1FP1是连接了CH1引脚的时钟。TI1FP2连接了CH2引脚的时钟。

到这里外部时钟模式1就介绍完了，就是外部时钟模式1的输入可以是ETR引脚，其他定时器，CH1引脚的边沿，CH1引脚，CH2引脚。

如果要使用外部时钟，首选还是ETR引脚外部时钟模式2的输入。编码器接口可以读取正交编码器的输出波形。

现在需要讲解上图下面一大部分的电路，右边这一块是输出比较电路，总共有4个通道，分别对应CH1到CH4的引脚。可以用来输出PWM波形，驱动电机。左边这块是输入捕获电路，也是4个通道，对应的也是CH1到CH4的引脚，可以用来测量输入方波的频率等。中间的寄存器是捕获/比较寄存器, 是输入捕获和输出比较电路共用的，因为输入捕获和输出比较电路不能同时使用，所以这里寄存器是共用的，引脚也是共用的。

### 高级定时器基本框图

![[Pasted image 20230819220414.png]]

高级定时器的左上的很大一部分电路与通用定时器基本差不多，主要的改动就是右下和左下这两个部分。

右下部分就是，申请中断的地方，增加了一个重复次数计数器，有了这个之后，就可以做到，每隔几个周期，才发生一次更新事件和更新中断。原来是一个周期就发生一次。相当于对输出的更新信号又做了一次分频。

DTG(Dead Time Generate)是死区生成电路，右边的输出引脚，由原来的一个变成了两个互补的输出，可以输出一对互补的PWM波。这些电路是为了驱动三相无刷电机的，这个电机还是比较常用的，四轴飞行器，电动车的后轮，电钻等，里面都有可能是这个电机。三相无刷电机的驱动电路一般需要3个桥臂，每个桥臂2个大功率开关管来控制。总共需要6个开关管，所以输出PWM引脚的前三路就变成了互补的输出。第四路就没有变化，因为三相电机，只需要三路就可以了。为了防止互补输出的PWM驱动桥臂时，在开关切换的瞬间，由于器件的不理想，造成短暂的直通现象。所以就有了DTG电路，在开关切换的瞬间，产生一定时长的死区，让桥臂的上下管全部关断，防止直通现象。

最后一部分，就是刹车输入的功能，为了给电机驱动提供安全保障的，如果外部引脚TIMx_BKIN产生了刹车信号，或者内部时钟失效，产生了故障。那么控制电路就会自动切断电机的输出，防止意外发生。

### 定时中断基本结构

![[Pasted image 20230819222155.png]]

这幅图就是之前的电路图的高级抽象，把关键部分列了出来。

### 预分频器时序

![[Pasted image 20230819222531.png]]

CK_PSC是预分频器的输入时钟，这个时钟在不断地运行。
CNT_EN是计数器使能，高电平计数器正常运行，低电平计数器停止。
CK_CNT是计数器时钟，其实就是预分频器的时钟输出，也是计数器的时钟输入。

可以看淡计数器未使能的情况下，计数器时钟是低电平，未运行。使能以后，经过一小段时间，正常工作，这个就是参数1的情况，也就是2分频，计数器的时钟等于预分频器前的时钟。后半段，预分频器系数变为2了，计数器的时钟输入就变成了预分频器前时钟的一半了。在计数器时钟输入的驱动下，下面的计数器寄存器也跟随时钟的上升沿不断自增，看上面的图，寄存器的值变为0，就可以推断出，自动重装载寄存器的值是FC。所以在重新计数的时候，下面就产生一个更新事件UEV（一个高电平）。

下面三行时序是预分频寄存器的一种缓冲机制，是为了在计数周期内，改变分频系数，缓冲是让周期完成了，才会设置为新的分频系数、

### 计数器时序图

![[Pasted image 20230819223933.png]]

分频系数为2.  第三行就是计数器的输入时钟了，因为系数为2，所以这个频率是CK_INT的频率除以2，当计数器增长到36的时候，就溢出，又重新开始计数。这时候，产生更新事件，同时，设置中断标志位，也就是高电平。这个标志位只要设置为1，就回去申请中断。中断程序中手动清零，就是清理这个标志位了。

### RCC时钟树

![[Pasted image 20230819225017.png]]

ST公司已经帮我们写好了，在进入main函数之前，有一个SystemInit函数，就是配置这个RCC时钟数的。RCC是高速晶振（也就是系统时钟），连接着AHB,APB1 APB2。RTC连接的是低速晶振。

## 定时器定时中断-定时器外部时钟

阅读我在github的项目stm32 rs learning by doing

## TIM输出比较

- OC(Output Campre) 输出比较
- 输出比较可以通过比较CNT与CCR寄存器(捕获比较寄存器)的关系，来对输出电平进行置1或者0，或者翻转的操作，用于输出一定频率和占空比的PWM波形
- 每个高级定时器和通用定时器都拥有4个输出比较通道
- 高级定时器的前三个通道额外拥有死区生成电路和互补输出功能

如果要用TIM做驱动电机的项目，比如智能车什么的，那么TIM的输出比较功能就必须好好学了。

![[Pasted image 20230819161628.png]]

再来复习下上面的图，主要看下半部分，当使用输入时，就是捕获寄存器，当使用输出时，就使用比较寄存器。在输出那里，比较寄存器会比较CNT和CCR的值。

当CNT大于CCR，小于CCR或者等于CCR时，TIMx_CH1这样的引脚就会输出对应的1，0，1，0 这样就可以输出一个电平不断跳变的PWM波形了。

### PWM简介

- PWM（Pulse Width Modulation）脉冲宽度调制
- 在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域
- PWM参数：
     频率 = 1 / Ts           占空比 = Ton / Ts           分辨率 = 占空比变化步距

![[Pasted image 20230825150528.png]]

可以看到，PWM波形是一个数字信号。虽然它是数字信号，但是，可以看到上面简介中第二条，简而言之就是可以用PWM波形等效实现一个模拟信号的输出。比如用普通的高低电平来控制LED灯，LED灯只有两种状态，完全熄灭，完全亮。但是PWM波形控制的LED灯，可以做到LED的亮度是渐变的，是一个连续的亮度。原理是什么呢？PWM波形以高频来输出高低电平的变化，让LED不断地点亮熄灭切换，在这样一种时候，LED就不会闪烁了，就会出现一个过渡亮度的中间状态，这个中间状态有很多，当我们调整Ton和Toff值的比例时，就会出现不同的亮度级别。

当然，PWM驱动电机也是一样的，想象你有一辆车，油门只有不踩和完全踩下两种状态。完全踩下，车子立刻在很短的时间内飚到最高时速，不踩，在很短的时间内停止。你要怎么控制车速呢？你只有快速踩油门和不踩油门切换（有一个周期），这样就能稳定控制车速了，车速也会维持不同的中间状态，你想让车快一点，油门踩下的时间相对不踩的时间就多一点，也就是Ton > Toff。当然，也可以用占空比描述。实质是一回事。

前置条件是一个惯性系统 ，电机和LED灯的亮灭，都会在人眼中形成一个视觉暂留。电机断电时，电机的转动也不会立马停止。

PWM的频率越快，等效的模拟信号就越稳定，一般来说PWM的频率都在几K到几十KHz，已经足够快了。占空比越大，等效的模拟电压就越趋近于高电平。比如高电平为5V，如果50%的占空比就是高电平和低电平时间相等的方波，等效的电压就是2.5V。

那么什么是分辨率呢，比如有的占空比只能是1%，2%，3%等等这样以1%的步距跳变，那分辨率就是1%。相当于就是占空比变化的粒度。

### 输出比较通道(通用定时器)

![[Pasted image 20230825153230.png]]

其实上图就是通用定时器TIM输出比较部分的输出控制电路。

当CNT > CCR1 或CNT = CCR1时，就会给输出模式控制器传递一个信号，然后输出模式控制器就会改变它输出OC1ref的高低电平。ref就是reference参考信号的意思，上面有一个ETRF输入，是定时器的一个小功能。

oc1ref后面会输出到主模式控制器，可以把这个ref映射到主模式的TRGO输出上去。不过ref的主要去向是下面这一路，到达极性选择这里，给寄存器写0，信号就会往上走，相当于电平信号无翻转，进来啥样，出去也是啥样。给寄存器写1，就往下走，通过一个非门门电路，实现电平翻转。使能电路就是让电平信号要不要输出，输出到OC1引脚。在引脚定义表里面就可以看到OC1 CH1引脚对应的是哪个GPIO口了。

接下来要具体看看输出模式控制器，知道什么时候会给oc1ref高电平，什么时候低电平。

### 输出比较模式

![[Pasted image 20230825154257.png]]

上图就是输出模式控制器的执行逻辑了。模式选择，通过OC1M\[2:0\] 来进行配置，具体看芯片手册。 上面的有效电平和无效电平其实就是高低电平的意思。

PWM模式1和2的区别其实就是输出的电平取反。本质都是一样的。

### PWM基本结构

下面讲解下如何用PWM模式1的向上计数来产生PWM波形。

![[Pasted image 20230825155524.png]]

上图就是重点内容了。其实就是向上计数的时候，让计数器在某个计数区间内，维持一个高电平，剩下的区间内，就是低电平，因为本质上计数器也是一个周期信号。上图计数器计到30，下面的的数字信号就是低电平，这里的30，就是CCR输出比较寄存器里面的值，也就是红色线。黄色线的99，就是ARR寄存器(自动重装寄存器)的值。

这里使用CNT计数器，就不用申请中断了。

到这里可以明白了，CCR寄存器的值，本质就是在调节占空比。

### PWM参数计算

![[Pasted image 20230825185114.png]]

CK_PSC / (PSC + 1) 其实就是CK_CNT，也就是计数器的时钟输入，也是预分频器的时钟输出。
### 舵机简介

- 舵机是一种根据输入PWM信号占空比来控制输出角度的装置
- 输入PWM信号要求：周期为20ms，高电平宽度为0.5ms~2.5ms

![[Pasted image 20230825185712.png]]

我们主要使用SG90这个型号的舵机。三根线，两根是电源线，一根是信号线，这个信号线就是传递PWM波形的。

第一张图，蓝色塑料的上面有个白色的塑料。一般是固定不动，至于固定在哪个位置，是由PWM信号来决定的。

可以发现，舵机不是单独的电机，是由直流电来驱动的，里面还有一个控制电路板，是一个电机的控制系统。

周期20ms，对应的频率就是50Hz，1000 / 20 = 50。

### 直流电机及驱动简介

- 直流电机是一种将电能转换为机械能的装置，有两个电极，当电极正接时，电机正转，当电极反接时，电机反转
- 直流电机属于大功率器件，GPIO口无法直接驱动，需要配合电机驱动电路来操作
- TB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并且控制其转速和方向

![[Pasted image 20230825191319.png]]

直流电机是一个单独的电机，里面没有驱动电路，所以需要外挂一个驱动电路，就是中间红色的这个电路板，左边的图就是130直流电机。

电机的驱动电路有不少选择，TB6612 DRV8833 L9110 L298N等等。

### 直流电机驱动电路分析

![[Pasted image 20230825193720.png]]

上图左边这个就是电机的驱动模块的硬件电路，左下角的VM，就是电机电源的正极，要接入一个可以输入大电流的电源，比如电机是5V电机，就需要接入5V，VCC引脚要和STM32的电源保持一致，所以就是3.3V。  AO1 AO2  BO1 BO2就是两路电机的输出了，M就是电机，这个驱动电路支持两个电机。AO1 AO2接的电机，是由PWMA, AIN2, AIN1控制的，B路的电机同理。

STBY是待机引脚，如果接地，就不工作，接入VCC，就正常工作，不需要待机模式就接入STM32的 3.3V

## PWM驱动LED呼吸灯-PWM驱动舵机-PWM驱动直流电机

看github repo

## TIM输入捕获

## 输入捕获模式测频率-PWMI模式测频率占空比

## TIM编码器接口

## 编码器接口测速

## ADC模数转换器

## AD单通道-AD多通道

## DMA存储器存取

## DMA数据转运-DMA+AD多通道

## USART串口协议

## USART串口外设

## 串口发送-串口发送+接收

## USART串口数据包

## 串口收发HEX数据包-串口收发文本数据包

## Flymcu串口下载-STLink utility

## I2C通信协议

## MPU6050简介

## 软件I2C读写MPU6050

## I2C通信外设

## 硬件I2C读写MPU6050

## SPI通信协议

## W25Q64简介

## 软件SPI读写W25Q64

## 硬件SPI读写W25Q64

## Unix时间戳

## BKP备份寄存器-RTC实时时钟

## 读写备份寄存器-实时时钟

## PWR电源控制