什么是拜占庭将军问题？为什么它对分布式系统很重要？这个问题有解决方案吗？

去中心化共识的核心原则指南。

![[Pasted image 20221004212456.png]]

拜占庭将军问题是在1982年由一篇学术论文提出的。它描述了一个博弈论问题，表明分散的各方在没有可信的中心方的帮助下达成协议（共识）是多么困难。[The Byzantine Generals Problem]([The-Byzantine-Generals-Problem.pdf (microsoft.com)](https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Byzantine-Generals-Problem.pdf)) 
这篇论文就是lamport写的。

拜占庭将军问题是一个思想实验：想象一个与拜占庭交战的古老城市。

拜占庭军队的4个师从四面八方逼近该城。每个师都有一个将军，对他们的师有统一的控制权。

![[Pasted image 20221004212712.png]]

该城防守严密；需要整个拜占庭军队来攻占它。如果只有一个师（或一个分队）进攻，他们肯定会被打败。

将领们到达并扎营过夜后，必须做出选择：明天，我是战斗还是撤退？

撤退需要有秩序地撤出你的部队；这并不意味着失败。

失败是指攻打城市并在战斗中失败。或者在你撤退时，让你的同僚将军进攻（并输掉）。

重要的是将领们的行动是一致的。
.
![[Pasted image 20221004212839.png]]

因为这是古代，将军们的通讯能力有限。他们能做的就是在一张纸上写下信息，交给信使，然后把它们送到另一个将军那里。

通信是异步的、双向的、不协调的。
.
在一个完美的世界里，我们可以设计出一个相对简单的方案。也许有一位将军被选为leader并发出命令。或者，每个将军对他们的选择进行排名，得票最多的选择获胜...（类似于validator中弄一个排名）

...但这并不是一个完美的世界。
.
记住，拜占庭军队正在攻击一座城市......到处都是人......那些人大概不希望拜占庭军队获胜。

因此，他们可以扰乱通讯。
.
想象一下，在这个世界上，城市里的人们非常密切地注意着在将军之间移动的信使。

如果他们能够抓住一个信使并阻止信息的传递呢(网络不可靠)？

或者，如果他们抓住了信使并替换了信息呢（作恶拦截）？

也许城里的人几个月前就已经看到了这次入侵，并一直在策划破坏活动。

如果他们能够策反拜占庭的一位将军呢(作恶节点)？也就是validator中有作恶的validator

这就是拜占庭将军问题的核心：**当没有人能够核实其他成员的身份时，网络成员如何能够就特定的现实达成一致？**

 拜占庭式故障描述的是一个系统，其组件可能会出现故障，但并不提供关于组件是否出现故障的明确、可靠的数据。

一条消息被城防军取代或一个叛徒将军说谎都是拜占庭式故障的例子。就是网络不可靠，会有作恶，会有掉线，会有其他各种可能。

一个拜占庭容错（BFT）的系统是一个能够抵抗这类故障（和攻击）的系统。

拜占庭将军问题有一个以上的可能解决方案；因此，有许多可能的BFT系统。

 BFT系统（通常）试图优化两个属性。

- 安全性(safety)--所有诚实的参与者都能就事件的顺序达成一致，因此拥有相同的信息, 相当于对副本状态机之间的数据一致达成一致。也就是操作日志(区块链中是交易)顺序达成一致

- 活性(liveness)--系统必须能够最终达成共识并向前推进，意思是共识不会暂停 [[ETH之Casper FFG共识#^eab037]]


 1999年，随着 "实用拜占庭容错"（PBFT）的发表，取得了巨大的突破。

PBFT的 "实用性 "意味着它可以在异步环境中工作（如思想实验......或互联网），并且相对较快。[Practical Byzantine Fault Tolerance]([osdi99.pdf (mit.edu)](https://pmg.csail.mit.edu/papers/osdi99.pdf)), 这篇论文是一篇发表在OSDI上的论文。

pBFT算法提供了safety和liveness，假设至少有$2/3+1$个节点是诚实的。

没有一个BFT系统可以支持有超过$1/3$的故障节点的网络。这是一个数学上的属性。也就是最大容错率是$1/3$，就是允许有$1/3$的节点出现拜占庭故障。

![[Pasted image 20221004214139.png]]
 PBFT足够复杂，值得它自己深入研究。

现在，pBFT在一系列的回合(rounds)中工作。首先，选择一个leader，然后将行动广播给小组。

这是你会看到的典型的图；IMO是很不容易进入的。

node 0是leader，他将行动广播给小组的其他成员（pre-prepare）。

然后小组的每个成员将其收到的信息广播给所有其他成员（prepare）。


![[Pasted image 20221004214311.png]]


一旦每个成员都收到了prepare信息，他们就会实际采取行动。最后，他们广播确认他们做了这个动作（commit）。

正是这个两轮（two round）系统使pBFT具有拜占庭式的容错能力。

最初的实现也考虑到了有问题的leader，但是检测/替换leader的过程（被称为 "view change"）是不可扩展的（scalable）。

然而，它的贡献是不可估量的。事实上，它仍然是（大多数）PoS的基础。

请记住...拜占庭将军问题有很多解决方案。那些看起来像PBFT的只是BFT系统的一个类别，叫BFT类共识

其他的看起来非常不同。有些人可能完全抛弃了投票。例如，可能使用一些其他类型的工作...
比如比特币 ，中本聪的论文（比特币白皮书）[Bitcoin: A Peer-to-Peer Electronic Cash System]([bitcoin.pdf](https://bitcoin.org/bitcoin.pdf))，就是采用PoW算法巧妙地解决了拜占庭将军的问题。PoW简单，但是也有它自身的缺点。

[Byzantine generals problem and PBFT algorithm and POW consensus - Krybot](https://blog.krybot.com/a?ID=01600-445abfd9-a8e4-42e7-bad1-550635a6a136)

[protocol - BFT VS Bitcoin PoW VS PBFT - Bitcoin Stack Exchange](https://bitcoin.stackexchange.com/questions/75923/bft-vs-bitcoin-pow-vs-pbft)

