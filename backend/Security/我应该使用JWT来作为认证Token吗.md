
不满意？好吧，好吧。我会写一个更长的答案。

让我们谈谈我们正在谈论的内容。jwt代表json Web Tokens，这是一种相当明确定义的用于身份验证(Authentication)令牌的标准。具体来说，它们有一个包含格式信息的头部、有效载荷和签名或消息认证码。核心思想是拥有相应验证密钥的人可以验证有效载荷是否真实且未被篡改。他们如何处理这些信息取决于他们自己。

[jwt规范]([RFC 7519 - JSON Web Token (JWT) (ietf.org)](https://datatracker.ietf.org/doc/html/rfc7519))（rfc 7519）通过提供一些众所周知的注册声明claim名称来提出建议：发行者(issuer)、受众(andience)、主题(subject)、过期时间(expired)等。一个常见的使用模式是，在根据与发行者的信任关系验证真实性之后，接收方检查自己是否为预期受众（如果有指定），并且过期时间尚未到达，然后将主题作为令牌持有人的经过身份验证的身份。

它非常适用于承载令牌认证！或者说呢？让我明确一点：jwt作为身份验证令牌是为Google/Facebook规模环境而设计的，并且除了Google/Facebook以外没有其他人需要忍受随之而来的权衡。如果您每秒处理不到10,000个请求，那么您既不是Google也不是Facebook。

拥护者会告诉你，核心优势在于接收jwt的用户无需连接到用户数据库来验证令牌的真实性并提供服务。在像谷歌这样的大型安装中，这意味着jwt发行者、认证服务可以是一个专门管理和扩展的服务(独立的服务)，并且是唯一需要访问集中式用户数据库的服务。所有其他服务只需根据jwt中存储的信息进行操作，而不需要经过用户数据库，从而避免了瓶颈。

那么注销/会话失效怎么处理呢？为了使该模型正常工作，身份验证令牌应具有相对较短的生命周期。最多可能为5分钟。客户端还会被分配第二个令牌，即所谓的刷新令牌(refresh token)，通过它可以向认证服务(颁发JWT的独立服务)请求新的身份验证令牌。这给予了认证服务机会去查询用户数据库的表以查看是否在此期间阻止了该用户或特定会话。

这里有一个很少被明确说明的转折：在这个设置中，刷新令牌(refresh token)而不是JWT认证令牌, 刷新令牌才是真正的会话令牌。刷新令牌代表与认证服务的会话（可以被撤销），而认证令牌只是用于最多几个请求的派生凭据。从谷歌的角度来看，美妙之处在于将保持会话活动委托给客户端，即非谷歌服务器。顺便说一下，刷新令牌通常是不透明的，并且通常只由创建它的同一服务使用。通过只使用存储在数据库中的不透明标识符来降低了许多复杂性。

现在，让我们假设你不是谷歌。检查以下哪些适用于你：

- 您想要实现注销功能，因此现在您正在保留有效JWT的允许列表或已撤销JWT的拒绝列表。为了进行检查，您会在每个请求中查询数据库。
- 您需要能够完全阻止用户，因此您会在数据库中检查“用户活动”标志。为了进行检查，您会在每个请求中查询数据库。
- 您需要用户对象与数据库中其他对象之间的附加关系。为了建立这种关系，您会在每个请求中查询数据库。
- 无论何时，在服务中涉及到对数据库数据的任何操作时，都需要通过每个请求来查询数据库。

恭喜，如果您确认上述任何项目，则不需要JWT。无论如何，您都会访问数据库，并且我相信您只有一个数据库，其中存储了用户配置文件和应用程序数据。通过仅使用“普通”的不透明会话令牌并将其存储在数据库中（就像Google使用刷新令牌一样），摒弃所有jwt身份验证令牌的荒谬之处，您将获得以下巨大好处：

- 没有为jwt作为身份验证令牌(Authentication)的缺点而进行奇怪的解决方法（允许/拒绝列表）
- 大大降低复杂性。无
- 需管理安全的jwt签名/身份验证密钥您可以避免一些有趣的错误。[NVD - CVE-2024-22513 (nist.gov)](https://nvd.nist.gov/vuln/detail/CVE-2024-22513) [Critical vulnerabilities in JSON Web Token libraries (auth0.com)](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/)

只需使用您的Web框架附带的正常会话(Session)机制，就像在有人告诉您Google使用jwt之前一样。它经受住了时间的考验，可能是可行的。

如果您需要做些事情让自己感觉像在运行一个大型部署，您可以配置会话机制以使用redisvalkey来存储会话数据。仍然要使用经过身份验证的用户ID查询数据库，但对于未经身份验证的请求，这可能更快/占用更少资源。也可能不是这样。您将需要进行调整和测量。

### 评论

> 我不反对你关于使用JWT作为会话令牌的观点，但还有其他用例。例如，如果你有两个应用程序，每个应用程序都有自己的用户和会话管理，但偶尔你希望将用户从一个应用程序发送到另一个应用程序而无需再次登录。其中一种（在我看来很优雅）的解决方案是，应用程序1发出一个短期有效的令牌，并将用户代理重定向到应用程序2，在那里它被接受为证明该用户已经通过身份验证。

> 你是对的。你所描述的在OpenID Connect（oidc）中得到了正式化，并且用于从身份提供者(IDP)传递用户信息给服务提供者的jwt被称为id token，这是底层oauth2协议中第三种令牌类型（除了访问令牌和刷新令牌）。OAuth网站对于是否可以解释访问令牌或从中获取用户信息有一些意见：https://oauth.net/2/access-tokens/ 😉

> 好的，我来解释一下...
> 
   >这篇文章似乎根本没有涉及微服务架构？对我来说，这是使用JWT的主要原因——这样你就可以通过微服务之间的调用链传递身份验证（"声明"或者你想叫它们什么都行）。如果你没有微服务，那么使用JWT的理由就少得多。
 > 
 > 我并不是说这篇文章完全是个草人论点，但它似乎忽略了JWT的主要用例。至少，在我的愤怒中使用它们时是如此。
 > 
 > 此外，“如果您使用错误的库或配置不正确，则JWT可能存在安全问题”的论点虽然有些道理，但在我看来更像是一个观点：您应该对任何用于安全性的库进行尽职调查。更好的JWT库默认情况下并不会存在安全问题。
 > 
 > 如果我正在制作一个单体应用程序，我不会使用JWT；但有很多公司（无论好坏）在使用微服务。
 
> 只需使用您的Web框架提供的正常会话Session机制，以及在有人告诉您Google使用JWT之前一直在使用的机制。它经受住了时间的考验，可能是可行的。
> 
> 不需要成为Facebook或Google才能拥有多个需要验证用户现有会话而无需强制用户重新登录的基础设施服务。跨多个服务共享会话是一个分布式系统问题，并且存在许多安全隐患，因此令牌可能是一个很好的替代方案。
> 
> 如果您只有一个单体Web应用程序作为身份提供者(IDP)、做出所有身份验证决策等，则可能确实不需要JWT。这与成为Google/Facebook之间存在巨大差距。
> 
> 除此之外，根据我上次检查时得到的信息，Google和Facebook甚至在浏览器和后端之间并没有使用JWTs，而实际上采用了某种分布式会话概念。



> 外部服务经常使用JWT，所以如果你必须处理JWT，使用JWT意味着只有一个原语、一组库和概念供开发人员了解。
> 
> “你不需要所有这些！”当然，但你可能已经在代码库的某个地方拥有它，并且它非常通用。你也可能没有充分利用HTTP本身的每个功能，这并不能成为不使用HTTP的有力论据。
> 
> JWT得到许多工具、库、中间件设备等支持；存在着庞大的生态系统来支持它。
> 
> 您还可以将认证委托给像Auth0或FusionAuth这样的第三方，以便您不处理任何PII（个人识别信息），因为所有PII都由供应商处理，并且您仅存储特定于应用程序的数据。
> 
> “您想要实现注销”意味着几件事情；在大多数应用程序中，你只需...使客户端忘记令牌，并继续进行日常操作即可。"但是如果一个邪恶角色窃取了令牌怎么办！！！" 你可能会说, 但自定义会话令牌也面临同样问题.
> 
> “您想要关闭对所有用户的访问权限”是可以通过HTTP中间件实现的;例如, 我曾经使用过一些中间件，“只允许带有声明中具有'admin'角色的JWT的请求通过，因为我们已经关闭了用户系统以进行停机维护”，这样做效果很好。（特别是我在一个下午写了一个traefik插件来实现这个）。
> 
> “您想要快速禁止单个特定用户”是JWT无法直接实现的功能。


> 我会添加两个jwts的优点（我猜oauth 2和oidc更具体
>  1. 它标准化了您的身份验证系统。虽然会话身份验证在大多数系统中以相同方式实现，但学习oauth和oidc可以为您提供行业标准。
>  3. Jwts为“前端”应用程序和API身份验证提供了一条简单的路径，使其以相同方式工作。理论上，这将减少您的安全面积，因为所有身份验证代码都可以在不同产品之间共享。


> 如果您的组织只有一个应用程序，那么不应使用JWT。然而，当您拥有多个应用程序时，需要一种形式的集中身份验证/授权服务。否则，您将不得不在每个应用程序中维护身份验证数据库，每个应用程序都需要单独登录，在X次认证失败后无法实现简单地“暂停用户帐户”，也无法获得集中的身份验证日志。


