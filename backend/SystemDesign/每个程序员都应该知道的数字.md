#### 每个程序员都应该知道的数字

主要是Jeff Dean和一些谷歌高级系统个工程师的总结，这些数字在设计系统的时候大概要有一个印象。比如一些常见的网络，内存，磁盘读写延迟。

![[Pasted image 20221005191340.png]]




这篇也主要是收集一些Google大佬的slide整理，其中第二篇是Jeff Dean的。标题就意味着，这些大概的数值在你构造高性能的系统的时候，应该大致在你头脑中有个概念。



##### Google AppEngine number

###### 写的代价是很昂贵的

- 数据存储是事务型的：写需要磁盘访问
-  磁盘访问意味着磁盘寻道
- 拇指法则（经验规则）：一次磁盘寻道就往往浪费了10 ms（毫秒）
- 简单的计算一下： 1s / 10ms = 100 seeks / sec, 也就是1秒磁盘最大寻道次数在100次

所以，根据以上法则，要时刻考虑你的数据大小和数据结构，并且要以批量的思想来做，批量写和批量读。

###### 读的代价是很便宜（cheap）的

- 读是不需要事务化的，它仅仅跟一致性有关。
- 数据从磁盘中读一次，一般就轻而易举被缓存了（缓存在内存了）。
- 所以，随之而后的读，都是直接从内存中读取的。
- 拇指法则（经验规则）：1MB的数据从内存中只需要250 us（微秒）
- 简单的计算一下：1s / 250usec = 4GB/sec 也就是1秒中最大能读4GB的数据

###### Numbers Miscellaneous

- CPU L1缓存的访问引用是0.5 ns
- CPU分支预测失败代价是5ns
- CPU L2缓存的访问引用是7ns
- Mutex的lock或unlock操作代价是100ns（所以加锁解锁的操作不耗费时间，锁的大量竞争才耗费，思路降低锁粒度，每个锁对象只保护一小部分数据）
- 主内存的访问引用代价是100ns
- 用Zippy压缩1K字节大概是在10000ns（0.01ms）
- 通过千兆网卡发送2K字节数据代价是20000ns（0.02ms）
- 从内存中顺序（内存地址连续）读1M的数据代价是250000ns（0.25ms）
- 在一个数据中心（高性能局域网）内数据往返的代价时间是500000ns（0.5ms）
- 一次磁盘寻道在10000000ns（10ms）
- 从网络中顺序（网络字节流顺序）读取1M数据要10000000ns（10ms）
- 从磁盘中顺序（文件字节流顺序）读取1M数据要30000000ns（30ms） 
- 从美国加州从发一个Packet（网络IP层的Packet包）到荷兰再回到加州的往返时间为150000000ns（150ms）

###### The lessons

- 写的代价一般是读的40倍
- 全局共享数据是非常昂贵的，这一般是分布式系统的基本单元的瓶颈，它是性能杀手，它让事务变成串行和缓慢
- 为可扩展的写行为作架构
- 优化比较缓慢的写行为
- 优化的更加广泛些，就是尽可能让写行为并行化

##### 参考

- http://highscalability.com/numbers-everyone-should-know
