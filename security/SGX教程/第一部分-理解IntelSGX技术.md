软件应用程序经常需要处理私人信息，如密码、账号、财务信息、加密密钥和健康记录。这些敏感数据只能由指定的接收者访问。在英特尔SGX术语中，这种私人信息被称为应用程序的秘密(secrets)。

操作系统的工作是在计算机系统上执行安全策略，使这些秘密不会无意中暴露给其他用户和应用程序。操作系统将阻止一个用户访问另一个用户的文件（除非明确授予了这样做的权限），一个应用程序访问另一个应用程序的内存，以及非特权用户访问操作系统资源，除非通过严格控制的接口。应用程序通常采用额外的保障措施，如数据加密，以确保即使操作系统和硬件被破坏，发送到存储或通过网络连接的数据也不会被第三方访问。

尽管有这些保护措施，在大多数计算机系统中仍然存在一个重要的漏洞：虽然有许多防护措施，保护一个应用程序不受另一个应用程序的影响，保护操作系统不受无权用户的影响，但一个应用程序几乎没有保护，不受以更高权限运行的进程，包括操作系统本身的影响。获得管理权限的恶意软件可以不受限制地访问所有系统资源和系统上运行的所有应用程序。复杂的恶意软件可以针对应用程序的保护方案，直接从内存中提取加密密钥甚至是秘密数据本身。

为了实现对秘密的高级别保护并帮助防御这些软件攻击，英特尔设计了英特尔SGX。英特尔SGX是一组CPU指令，使应用程序能够创建enclave：应用程序地址空间中的保护区，即使在有特权的恶意软件存在的情况下也能提供保密性和完整性。enclave代码是通过使用特殊指令来启用的，它是作为Windows动态链接库（DLL）文件或者是Linux的so库构建和加载的。

英特尔SGX可以减少应用程序的攻击面。图1显示了有无英特尔SGX飞地的攻击面之间的巨大差异。

![[Pasted image 20221214094114.png]]

## Intel的SGX技术是怎样帮助对数据做出安全保证的

英特尔SGX提供了以下保护措施，防止已知的硬件和软件攻击。  
  
- 无论当前的权限级别和CPU模式如何，都不能从enclave之外读取或写入飞地内存。  
- 生产enclave不能被软件或硬件调试器所调试。(可以用一个调试属性来创建enclave，允许一个特殊的调试器--英特尔SGX调试器--像标准调试器一样查看其内容。这是为了帮助软件的开发周期）。  
- enclave环境不能通过传统的函数调用、跳转、寄存器操作或堆栈操作进入。调用 "enclave "函数的唯一方法是通过一条新指令，该指令会执行若干保护检查。  
- enclave中的内存使用具有重放保护的行业标准加密算法进行加密。窃听内存或将DRAM模块连接到另一个系统将只产生加密的数据（见图2）。  
- 内存加密密钥在每个电源周期（例如，在启动时，以及从睡眠和休眠状态恢复时）随机改变。该密钥存储在CPU内，无法访问。  
- 隔离在enclave内的数据只能由共享enclave的代码访问。  

受保护内存的大小有一个硬性限制，由系统BIOS设置，典型值为64MB和128MB。一些系统供应商可能会在其BIOS设置中把这个限制作为一个可配置的选项。根据每个 "enclave "的大小，你可以预期有5到20个 "enclave "可以同时驻留在内存中。  

![[Pasted image 20221214094502.png]]

## 设计考量


使用英特尔SGX的应用设计要求将应用程序分为两个部分（见图3）。

- 受信任的组件（安全）。这就是enclave。驻扎在enclave中的代码是访问应用程序秘密的代码。一个应用程序可以有一个以上的可信组件/enclave。
- 不受信任的组件（非安全）。这是应用程序的其他部分和它的任何模块。需要注意的是，从enclave的角度来看，操作系统和VMM被认为是不可信任的组件。

受信任的组件（enclave）应该尽可能的小，仅限于最需要保护的数据和那些必须直接作用于它的操作。一个具有复杂接口的大型飞地不仅会消耗更多的受保护内存：它还会创造一个更大的攻击面。

enclave也应该有最小的受信-不受信组件的交互。虽然enclave可以离开受保护的内存区域并调用不受信任的组件中的函数（通过使用特殊指令），但限制这些依赖性将加强enclave的被攻击面。

![[Pasted image 20221214094832.png]]

## 证明(Attestation)

在英特尔SGX架构中，证明指的是证明特定enclave在平台上建立的过程。有两种证明机制。

- 当同一平台上的两个enclave相互认证时，就会发生本地认证。
- 远程证明发生在一个enclave获得一个远程提供者的信任时。

### 本地证明(local attestation)

当应用程序有一个以上的 "enclave "需要共同完成一项任务时，或者当两个独立的应用程序必须在 "enclave "之间进行数据通信时，本地验证非常有用。每个 "enclave "都必须验证另一个 "enclave"，以确认它们都是可信的。一旦完成，它们就会建立一个受保护的会话，并使用ECDH密钥交换来共享一个会话密钥。该会话密钥可用于加密两个enclave之间必须共享的数据。

因为一个enclave不能访问另一个enclave的受保护的内存空间，即使是在同一个应用程序下运行，所有的指针都必须被解除引用它们的值并被复制，而且完整的数据集必须从一个enclave转移到另一个。

### 远程证明(remote attestation)

通过远程验证，英特尔SGX软件和平台硬件的组合被用来生成一个报价(quote)，并被发送到第三方服务器以建立信任。该软件包括应用程序的enclave，以及报价enclave（QE，Quoting Enclave）和供应enclave（PvE， Provisioning Enclave），两者都由英特尔提供。证明的硬件是支持英特尔SGX的CPU。软件信息的摘要与来自硬件的平台特有的非对称密钥相结合，以生成报价(quote)，并通过认证通道发送到远程服务器。如果远程服务器确定 "enclave "是正确实例化的，并且运行在真正的英特尔SGX处理器上，那么它现在可以信任 "enclave"，并选择通过认证通道向其提供秘密(provision secrets)。

## 密封数据(Sealing Data)

密封数据是对其进行加密(encrypt)的过程，以便可以将其写入不受信任的内存或存储，而不泄露其内容。数据可以在以后被 "enclave "读回并解封(unsealed)或解密(decrypted)。加密密钥是根据需求在内部derived的，不会暴露给enclave。

有两种密封数据的方法。

- 飞地身份(enclave identity)。这种方法产生一个对这个确切的enclave来说是唯一的密钥。
- 密封身份(Sealing identity)。这种方法产生的密钥是基于enclave的Sealing Authority的身份。来自同一签署机构的多个enclave可以衍生出相同的密钥。

### 用enclave identity密封

当密封到 "enclave identity "时，密钥对密封数据的特定enclave来说是唯一的，对enclave的任何影响其签名的改变都会导致新的密钥。通过这种方法，一个版本的 "enclave "（也就是没有被改动的enclave代码）所密封的数据是其他版本的 "enclave "所不能访问的，所以这种方法的副作用是，密封的数据不能迁移到新版本的应用程序和它的 "enclave"。这是为那些旧的、密封的数据不应该被较新版本的应用程序使用的应用而设计的。

### 用Sealing Identity密封

当密封到Sealing Identity时，来自同一机构的多个enclave可以透明地密封和解封彼此的数据。这允许一个版本的enclave的数据被迁移到另一个版本，或在同一软件供应商的应用程序之间共享。（因为同一软件厂商的代码可能会启动多个enclave，互相之间通信协作，这样提供便利）

如果需要防止旧版本的软件和enclave访问被较新版本的应用程序密封的数据，当局可以选择在签署enclave时包括一个软件版本号（SVN）。比指定的SVN更早的enclave版本将无法得出密封密钥，因此将被阻止解封数据。换句话说，**就是老版本访问不了新版本，但是新版本兼容老版本。**





