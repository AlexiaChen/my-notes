
## 前言

本文是对零知识证明领域相关资料的梳理以及行业应用的探讨，希望能给非技术出身的研究员提供 ZKP 研究的指引。企图帮助非技术出身的研究员由浅入深理解零知识证明。

## 从Alice和Bob的故事体会零知识

本章是对 [Aviv Zohar](https://medium.com/@avivzohar) 2017年发表的 **[The Incredible Machine](https://medium.com/qed-it/the-incredible-machine-4d1270d7363a)** 的概括，从故事的角度出发，帮助读者更直观得体会零知识证明的相关特性。

Alice 和 Bob 都是数独爱好者，有一天 Alice 向 Bob 说，“我设计了一个很难的数独，你要不要挑战一下？” Bob 接受挑战，但迟迟无法填满空格，便质疑 Alice 的题目是无解的。为了证明其题目有解且不暴露答案本身，Alice 想到了个办法。(首先建议了解下九宫格的游戏规则)

-   承诺：Alice 拿出 81（9x9）张空白的卡片放在桌上，在每张纸上写上 1-9 中的一个数字，他让 Bob 转过身闭上眼，然后把这 81 张卡片按照解的排列放在桌上，代表谜底的卡片，数字面朝下放在桌上；代表谜面的卡片，则数字面朝上放在桌上。
    
-   随机实验：Bob 随意选择行，或者按照列，或者按照3x3的九宫格来检验解。接着把选中的9张卡片收起来单独放到一个麻布袋里。所有卡片都被收完放在了9个麻布袋里。Alice 接着摇了摇每个麻布袋，把里面的卡片顺序都打散。最后把这9个麻布袋交给 Bob。

![[Pasted image 20220918142457.png]]

-   验证：Bob 打开布袋，验证每个布袋是否都是 1～9 的数字卡片(验证这个阶段就是相当于Verifier知道这个游戏的规则，来向规则发起测试(挑战)，如果有与规则的结果相背，那么验证失败)

![[Pasted image 20220918142650.png]]

- 重复: 按照数独需要每一行每一列每个九宫格的数字都不会重复，只做一次随机实验，Alice 没说谎的概率只有 1/3，重复做几次实验，每次实验结果都是不会重复的数字，则可以证明 Alice 确实是知道这道题的解。(随着验证次数的反复进行，Alice撒谎的概率越来越低，Alice做出来这个九宫格的解，也就是生成证明的时间很长，但是验证时间很短，只要根据九宫格的规则来验证就好了。Alice是Prover，Bob是Verifier)
- 非交互式：Alice 和 Bob 挑选排列方式属于交互式，双方存在联合起来欺骗第三方的可能。于是Charlie 设计了一个机器来进行行列块的选择，以实现随机实验的非交互性。Alice 只要把卡片放在传送带上，机器会自动选择按行，或列，或九宫格来收取卡片，放到袋子里打乱顺序，然后把袋子通过传送带再送出来。(相当于之前Bob的选择9张卡片放进一个袋子的重复这样9次的操作就被这台机器取代了，Alice的摇一摇袋子这个操作也被机器取代了)

![[Pasted image 20220918144008.png]]
![[Pasted image 20220918144023.png]]
-   初始化设置：行,列,块（宫）的抽取顺序是 Charlie 设置的，因此这台机器没法验证他是否能解数独，其他人也可以通过贿赂 Charlie 知道抽取顺序。于是 Alice 提议让 Charlie 把控制面板重新打开，多方（multi-party）共同设置控制面板上的试验序列。这个过程称为“可信任的初始设置仪式（trusted setup ceremony）。把机器放在一个黑暗的房间里，第一个人进房间后拨动拨盘到任意随机的位置，第二个人和第三个人按照第一个人随机选中的顺序分别往下加一格和两格，用这样的方式，保证每一个拨盘都不会被其中任何人知道。这个设置仪式完成之后，他们就焊接好机器控制面板。

这样的机器，就可以实现 ZK 的三个特性：

-   完整性 —— 只要「陈述」是正确的，证明者(_prover)_ 就可以让验证者(_verifier)_ 确信
    
-   可靠性 —— 如果「陈述」是错误的，那么作弊的 _prover_ 就没有办法让 _verifier_ 相信
    
-   零知识 —— 协议的交互仅仅揭露「陈述」是否正确而不泄漏除公共信息外的其它的信息

这个陈述就是Prover和Verifier共有的认知(公共信息)，就是九宫格(数独)这个游戏规则(现象)达成一致。

## 从数学中体会零知识证明

本章是对 ZK-SNARK（主流的 ZKP）的数学证明过程，主要参考 [Vitalik Buterin](https://medium.com/@VitalikButerin?source=post_page-----f6d558cea649--------------------------------) 2016 年发表的 [Quadratic Arithmetic Programs: from Zero to Hero](https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649) ，从数学的角度出发，帮助读者进一步理解零知识证明的实现过程。

### 预备知识

#### 复杂度

-   当问题规模扩大后，程序需要的时间长度增长得有多快。
    
-   数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有O(1)的时间复杂度，也称常数级复杂度；
    
-   数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是O(n)。
    
-   $O(1),O(log(n)),O(n^c)$等，我们把它叫做多项式级的复杂度。(P复杂度)
    
-   $O(c^n)和O(n!)$型复杂度，它是非多项式级的(NP复杂度)，其复杂度计算机往往不能承受。
    
-   当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。

![[Pasted image 20220918150417.png]]

#### P问题与NP问题

-   P 问题：多项式时间内可解的问题，如
    
    -   已知私钥 sk 和椭圆曲线生成元 G，可快速计算出公钥$pk = sk * G$
        
    -   已知原象 x 和哈希函数 SHA256，可快速计算出哈希值 $Y = SHA256(x)$
        
-   NP 问题：不能在多项式时间内可解（求解困难），但是可以在多项式时间内验证的问题（验证简单），如：
    
    -   已知公钥 pk 和椭圆曲线生成元 G，不可在多项式时间内计算出私钥sk使得 $pk = sk*G$
        
    -   以知哈希值 Y 和哈希函数 SHA256， 不可在多项式时间内计算出原象 x 使得 $Y = SHA256(x)$

#### 多项式

-   多项式有一个非常好的特性，就是如果我们有两个阶为 d 的不相等多项式，他们相交的点数不会超过 d。我们不可能找到两条不同的曲线，他们会在某段区域内重合（他们只会相交于一些点）。这个阶就是最高次项的幂了。
    
-   如检查两个长度为 1000 的向量（prover提供的信息与正确的信息）是否相等，一定要检查1000次，而两个 1000 次的多项式，最多只有1000个点相同(相交)，并且这最多1000个的点在一个很大的取值范围，如 1 到 1 亿。两个不同多项式在同一点上相同(相交)的概率只有一百万分之一。检查两个多项式是否相等比检查同等规模的两个向量是否相等要快得多。
    
-   $(Ax, s) * (Bx, s) - (Cx, s)$ 为二次算法多项式，简称 QAP 多项式（$Ax、Bx、Cx$为 d 阶多项式，$s$ 为 d 阶向量，根据最高次项的相乘合并，那么最高次项最终是幂相加，显然那么QAP为 2d 阶多项式）。$a_1,a_2,…,a_n$ 是 QAP 多项式等于 0 的解，令$Z(x)=(x-a_1)*(x-a_2)_…*(x-a_n)$，则QAP多项式可以被$Z(x)$整除。
    
-   若不知道向量$s$，需要指数时间(NP复杂度)暴力搜索出向量$s$，使得构建的QAP多项式能整除$Z(x)$，若已知$s$，则可快速验证(P复杂度)QAP多项式是否与$Z(x)$满足整除关系。说句白话就是，不能在多项式时间暴力搜索出向量$s$，使得构造的QAP多项式可以整除$Z(x)$，但是可以在多项式时间内验证这个整除关系正不正确。
    
-   QAP 多项式的整除关系，构成 NP 问题。

#### 算术电路

-   在用电路写程序方面，已经算是比较成熟了，例如 CPU 以及各种芯片、嵌入式设备、ASIC 矿机等都是电路设计。同时，电路的结构又足够简单，不至于给构造 ZKP 带来太多麻烦。只不过ZKP常用的是`算术电路`（左图），硬件中常见的是`布尔电路`（右图）。
    
-   多项式时间运算关系的代码，都可以用算术电路来表示。算术电路由`加法门`和`乘法门`构成。
    
-   连续光滑的函数能通过泰勒展开无限逼近，泰勒展开由加减法和幂构成，幂函数由乘法构成。AND 和 XOR 等位运算非光滑，较难用加法乘法表示。这里就说明，连续光滑的函数，可以用算术电路实现，而也承接了上面的QAP多项式，正好，QAP多项式是连续光滑的，QAP多项式可以用算术电路表达。

![[Pasted image 20220918153030.png]]

所以一旦你理解上面，你就知道了，有些密码学工程师会说，我生成的电路比较大，上亿个门的电路，门就只这里的加法和乘法的这个节点了(左图)。

#### 线性代数基础知识

- 向量的內积(点积，数量积)运算

![[Pasted image 20220918153548.png]]
- 矩阵乘法运算

![[Pasted image 20220918153907.png]]


-   拉格朗日插值法
    
    -   利用拉格郎日插值法可将点转化为多项式
        
    -   如求经过 (1, 3)、(2, 2)、(3, 4)的二阶多项式 f(x) 有且只有一个，求f(x)

拉格朗日插值有一个特性，就是对于给定n+1个点，那么过这个n+1个点的次数不超过n的多项式有且仅有一个。如果是更高次的，那么就会有无穷多个多项式。我们插出来的，就是这个不超过n的多项式。

![[Pasted image 20220918154348.png]]

最后的$f(x) = 1.5*x^2 - 5.5*x + 1$

- 如左图所示，若已知输入，验证人（Verifier）想要验证证明人（Prover）给的结果是否正确，可通过计算算术电路中每一个节点的值最终得出结果与输出进行对比，但此过程无法达到简洁性，也即证明人和验证人为了得出结论所使用的计算时间是相同的(显然，验证过程需要比这个更快，更高效)，因此可以将运算过程中的值作为未知变量，通过零知识证明来进行验证，以此达到验证过程的简洁性；如右图所示，证明人(Prover)为了保持部分输入的隐私性，可通过零知识证明技术让验证人相信证明人是知道正确的解。也就是相当于，ZKP技术是在这些用简单算术构造的电路中实行的。把一个需求，转化为多项式，再把多项式转化成算术门电路，这些一个一个的门，拆出来非常简单，简单才可以比较高效地构造一些ZKP证明。

![[Pasted image 20220918160615.png]]

-   验证者(Verifier)已知的信息(公共信息)为Statement（如下图绿色所示），证明者(Prover)知道的知识而验证者不知道的信息为Witness（如下图蓝色所示）。这个statement 和witness在sigma protocol这种构造ZKP的手法中也提到过，这些概念是ZKP的基础。[(5条消息) 密码学中的sigma-protocol_mutourend的博客-CSDN博客](https://blog.csdn.net/mutourend/article/details/100708354)  [(5条消息) 基于Sigma protocol实现的零知识证明protocol集锦_mutourend的博客-CSDN博客](https://blog.csdn.net/mutourend/article/details/106391126)

![[Pasted image 20220918160647.png]]


由上图就可以看出，ZKP技术就应用在了一个一个这样的算术门中。

### 数学证明过程

1.  为了实现简洁性或零知识性,需要把算法转换成NP问题（验证简单，求解困难）
    
2.  验证者知道的答案与正确答案包含的信息数据可以用向量来表示，判断两个向量是否相等需要进行向量长度的运算，例如判断两个长度为 100 的向量是否相等，需要进行 100 次对比后才能得出结论。没有达到简洁性和零知识性。
    
3.  判断两个多项式是否相等比判断两个向量是否相等更容易，因为两个不同的 n 阶多项式至多相较于n个点，只要把范围取得足够大，则碰撞出两个函数相交的点概率极低，是不可能事件。例如两个不相同的 100 阶多项式函数，至多只有 100 个相同的点，若把 x 的取值范围定在[-1,000,000, 1,000,000]，随机取 1 个点使得两个多项式相交的概率为100/2,000,000=1/20,000 , 若均匀取两个点使得两个多项式相交的概率为(1/20,000)*(1/20,000)，为不可能事件。
    
4.  将验证两个向量是否相等的问题转化为验证两个多项式是否相等，可以将计算的复杂度大大降低。SNARK将向量对比问题转换为 QAP 多项式整除目标多项式这一天然的NP问题作为验证方式。
    
5.  为了构建 QAP 多项式，需要将程序转化为算术电路，构建 R1CS。
    
6.  SNARK证明过程：程序转化为多项式时间运算关系-> R1CS -> QAP -> QAP 整除关系 -> 椭圆曲线离散对数。


![[e6a476fb0a0c665394c61f2c3427bc3.jpg]]

## zkSNARK与zkSTARK

TODO

### SNARK与STARK含义

#### SNARK

#### STARK

### SNARK与STARK的异同

## ZKP应用

### Layer 2扩容

#### Optimistic Rollup

#### ZK Rollup

### 隐私

#### 隐私应用

#### 隐私公链

## 兼容性-zkEVM

### 设计挑战

### 分类

#### Type 1(完全等效于以太坊)

#### Type 2(完全等效于EVM)

#### Type 2.5 (EVM等效，gas成本除外)

#### Type 3(几乎等效于EVM)

#### Type 4(高级语言等效)

### zkEVM实现的可能性

## 总结

