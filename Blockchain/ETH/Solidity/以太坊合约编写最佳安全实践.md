## 通用哲学观

### 为失败作好准备

任何非琐碎(non-trivial)的合约都会有错误。因此，你的代码必须能够优雅地应对错误和漏洞。

- 当事情出错时暂停合约（"断路器（ciruit breaker）"）。
- 管理风险金额（费率限制，最大使用量）。
- 有一个有效的升级路径来修复错误和改进问题

### 保持更新

追踪新的安全发展。

- 一旦发现任何新的错误，立即检查你的合约
- 尽快升级到任何工具或库的最新版本
- 采用看起来有用的新安全技术

### 保持简单

复杂性会增加出错的可能性。

- 确保合约逻辑简单
- 将代码模块化，使合约和函数保持小规模
- 尽可能使用已经写好的工具或代码（例如，不要自己开发随机数发生器）。
- 在可能的情况下，优先考虑清晰性而不是性能
- 只在系统中需要去中心化的部分使用区块链。

### 发布流程

在完整的生产发布之前抓住错误总是更好的。

- 彻底测试合约，并在发现新的攻击载体时增加测试。
- 从alpha测试网发布开始，提供bug悬赏。
- 分阶段推出，在每个阶段增加使用和测试。

### 区块链属性

虽然你的许多编程经验将与以太坊编程有关，但也有一些陷阱需要注意。

- 对外部合约的调用要非常小心，这可能会执行恶意代码并改变控制流。
- 要明白你的公共函数是公开的，可能被恶意调用，而且是以任何顺序调用。智能合约中的私人数据也可以被任何人查看。
- 牢记gas成本和区块gas限制。
- 要注意时间戳在区块链上是不精确的，矿工可以在几秒的范围内影响交易的执行时间。
- 随机性在区块链上是不可行的，大多数随机数生成的方法在区块链上都是可以玩的。

### 简单和复杂

在评估智能合约系统的结构和安全性时，有多种基本的权衡需要考虑。对任何智能合约系统的一般建议是确定这些基本权衡的适当平衡。

从软件工程的角度来看，一个理想的智能合约系统是模块化的，重用代码而不是重复代码，并支持可升级的组件。从安全架构的角度来看，一个理想的智能合约系统可能会有这样的心态，特别是在更复杂的智能合约系统的情况下。

然而，也有一些重要的例外情况，安全和软件工程的最佳实践可能不一致。在每一种情况下，适当的平衡是通过沿着合约系统的维度确定属性的最佳组合来获得的，例如以下讨论的话题

#### 刚性和可升级型

虽然包括本网站在内的多种资源都强调了可塑性特征，如可杀伤、可升级或可修改的模式，但在可塑性和安全性之间存在着基本的权衡。

根据定义，可塑性模式增加了复杂性和潜在的攻击面。在智能合约系统在预先定义的有限时间内执行一套非常有限的功能的情况下，简单性比复杂性特别有效，例如，一个无治理的有限时间框架的代币销售合约系统。

#### 单体化和模块化

一个单体的独立合约可以保持所有知识的本地可识别性和可读性。虽然很少有被高度重视的智能合约系统是以单体形式存在的，但也有一种说法是数据和流程的极端本地化--例如，在优化代码审查效率的情况下。

与这里考虑的其他权衡一样，在简单的短期合约中，安全的最佳实践趋于远离软件工程的最佳实践，而在更复杂的永久合同系统中，则趋于软件工程的最佳实践。

> 也就是代码不复杂的话，就不要老是想着模块化了，反过来一样。

#### 重复和复用

从软件工程的角度来看，一个智能合约系统希望在合理的情况下最大限度地重复使用。在Solidity中，有很多方法可以重用合约代码。使用你自己拥有的经过验证的先前部署的合约，通常是实现代码重用的最安全方式。

在自己拥有的先前部署的合同不可用的情况下，经常依靠重复使用。像OpenZeppelin的Solidity库这样的努力试图提供模式，使安全的代码可以被重复使用而不需要重复。任何合同安全分析必须包括任何重新使用的代码，这些代码以前没有建立与目标智能合同系统中的风险资金相称的信任水平。

## 开发建议

### 常规建议

#### 外部调用

##### 1. 进行外部调用的时候要小心

对不受信任的合约的调用会带来一些意想不到的风险或错误。外部调用可能会在该合约或它所依赖的任何其他合同中执行恶意代码。因此，每一个外部调用都应该被视为一个潜在的安全风险。当不可能，或不希望删除外部调用时，使用本节其余部分的建议，以尽量减少危险。

##### 2. 对不受信的合约进行标记

当与外部合约交互时，以一种明确的方式命名你的变量、方法和合约接口，表明与它们交互是潜在的不安全的。这也适用于你自己调用外部合约的函数。

```d
// bad
Bank.withdraw(100); // Unclear whether trusted or untrusted

function makeWithdrawal(uint amount) { // Isn't clear that this function is potentially unsafe
    Bank.withdraw(amount);
}

// good
UntrustedBank.withdraw(100); // untrusted external call
TrustedBank.withdraw(100); // external but trusted bank contract maintained by XYZ Corp

function makeUntrustedWithdrawal(uint amount) {
    UntrustedBank.withdraw(amount);
}
```

##### 3. 避免外部调用后的状态变化

无论是使用原始调用（形式为`someAddress.call()`）还是合约调用（形式为`ExternalContract.someMethod()`），都要假设恶意代码可能会执行。即使`ExternalContract`不是恶意的，恶意代码也会被它所调用的任何合约执行。

一个特别的危险是，恶意代码可能会劫持控制流，导致由于重入而产生的漏洞。(关于这个问题的更全面的讨论，请参见重入性）。

如果你正在调用一个不受信任的外部合约，请避免在调用后进行状态改变。这种模式有时也被称为检查-效果-互动模式(Checks-Effects-Interactions Pattern)。[Security Considerations — Solidity 0.8.18 documentation (soliditylang.org)](https://docs.soliditylang.org/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern) 

[SWC-107 · Overview (swcregistry.io)](https://swcregistry.io/docs/SWC-107)

##### 4. 不要使用`transfer()`或者`send()`

`.transfer()`和`.send()`正好将2300个gas转发给接收者。这种硬编码的气体津贴的目的是为了防止重入漏洞，但这只有在gas成本不变的假设下才有意义。最近，[EIP 1884]([EIP-1884: Repricing for trie-size-dependent opcodes (ethereum.org)](https://eips.ethereum.org/EIPS/eip-1884))被列入伊斯坦布尔硬分叉中。EIP 1884中包含的一个变化是增加了`SLOAD`操作的gas成本，导致合约的fallback功能成本超过2300 gas。

建议停止使用`.transfer()`和`.send()``，而是使用`.call()`。

```d
// bad
contract Vulnerable {
    function withdraw(uint256 amount) external {
        // This forwards 2300 gas, which may not be enough if the recipient
        // is a contract and gas costs change.
        msg.sender.transfer(amount);
    }
}

// good
contract Fixed {
    function withdraw(uint256 amount) external {
        // This forwards all available gas. Be sure to check the return value!
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success, "Transfer failed.");
    }
}
```

请注意，`.call()`对减轻重入攻击毫无作用，所以必须采取其他预防措施。为了防止重入攻击。请用Checks-Effects-Interactions Pattern。

##### 5. 处理外部调用的错误

Solidity 提供了对原始地址工作的低级调用方法：`address.call()`, `address.callcode()`, `address.delegatecall()`, 和 `address.send()`。这些低级方法从不抛出异常，但如果调用遇到异常，将返回`false`。另一方面，合约调用（例如`ExternalContract.doSomething()``）将自动传播一个throw（例如，如果`doSomething()`抛出，ExternalContract.doSomething()也将抛出）。

如果你选择使用低级别的调用方法，请确保通过检查返回值来处理调用失败的可能性。

```d
// bad
someAddress.send(55);
someAddress.call.value(55)(""); // this is doubly dangerous, as it will forward all remaining gas and doesn't check for result
someAddress.call.value(100)(bytes4(sha3("deposit()"))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted

// good
(bool success, ) = someAddress.call.value(55)("");
if(!success) {
    // handle failure code
}

ExternalContract(someAddress).deposit.value(100)();
```

[SWC-104 · Overview (swcregistry.io)](https://swcregistry.io/docs/SWC-104) 

##### 6. 倾向pull而不是push外部调用

外部调用可能意外地或故意地失败。为了尽量减少这种失败造成的损失，通常最好是把每个外部调用隔离成自己的交易，可以由调用的接收者发起。这对于支付来说尤其重要，最好是让用户提取(pull)资金，而不是自动推送(push)资金给他们。(这也减少了gas限制出现问题的机会 [Denial of Service - Ethereum Smart Contract Best Practices (consensys.github.io)](https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/) ) 避免在一个交易中合并多个以太币转移。

```d
// bad
contract auction {
    address highestBidder;
    uint highestBid;

    function bid() payable {
        require(msg.value >= highestBid);

        if (highestBidder != address(0)) {
            (bool success, ) = highestBidder.call.value(highestBid)("");
            require(success); // if this call consistently fails, no one else can bid
        }

       highestBidder = msg.sender;
       highestBid = msg.value;
    }
}

// good
contract auction {
    address highestBidder;
    uint highestBid;
    mapping(address => uint) refunds;

    function bid() payable external {
        require(msg.value >= highestBid);

        if (highestBidder != address(0)) {
            refunds[highestBidder] += highestBid; // record the refund that this user can claim
        }

        highestBidder = msg.sender;
        highestBid = msg.value;
    }

    function withdrawRefund() external {
        uint refund = refunds[msg.sender];
        refunds[msg.sender] = 0;
        (bool success, ) = msg.sender.call.value(refund)("");
        require(success);
    }
}

```

> 看上面的代码，我的理解就是说，这样对于一个外部调用，要有容错，这个容错的方式就是让用户来主动调用，给用户看到报错。

[SWC-128 · Overview (swcregistry.io)](https://swcregistry.io/docs/SWC-128)

##### 7. 不要delegatecall不受信的代码

`delegatecall`函数被用来调用其他合约的函数，就像它们属于caller合约一样。因此，callee可以改变调用地址的状态（callee的代码是在caller的状态上下文中运行的）。这可能是不安全的。下面的一个例子显示了使用`delegatecall`如何导致合约的破坏和失去平衡。

```d
contract Destructor
{
    function doWork() external
    {
        selfdestruct(0);
    }
}

contract Worker
{
    function doWork(address _internalWorker) public
    {
        // unsafe
        _internalWorker.delegatecall(bytes4(keccak256("doWork()")));
    }
}
```

如果`Worker.doWork()`被调用，并将部署的`Destructor`合约的地址作为参数，`Worker`合约将自毁。只将执行委托给受信任的合约，而不要委托给用户提供的地址。

> 警告： 不要假设合约是以零余额创建的。攻击者可以在合约创建之前向其地址发送以太币，所以合约不应该假设其初始状态包含零余额。更多细节见问题61。[Don't assume contracts are created with zero balance · Issue #61 · ConsenSys/smart-contract-best-practices (github.com)](https://github.com/ConsenSys/smart-contract-best-practices/issues/61) 

[SWC-112 · Overview (swcregistry.io)](https://swcregistry.io/docs/SWC-112)

#### 强行灌入以太币

小心编码一个严格检查合约余额的不变式。

攻击者可以强行向任何账户发送以太币，这是不可能被阻止的（即使有一个做`revert()`的fallback函数也不行）。

攻击者可以通过创建一个合约，用1wei为它提供资金，并调用`selfdestruct(victimAddress)`来做到这一点。在 `victimAddress` 中没有调用任何代码，所以无法阻止它。区块奖励也是如此，它被发送到矿工的地址，这可以是任何任意的地址。

此外，由于合约地址可以预先计算，在合约部署之前，以太币可以被发送到一个地址。

[SWC-132 · Overview (swcregistry.io)](https://swcregistry.io/docs/SWC-132)

#### 公共的链上数据

许多应用要求提交的数据在某个时间点之前都是私有的，以便工作。游戏（如链上剪刀石头布）和拍卖(Auction)机制（如密封竞价的Vickrey拍卖 [Vickrey auction - Wikipedia](https://en.wikipedia.org/wiki/Vickrey_auction) ）是两大类例子。如果你正在建立一个隐私问题的应用程序，请确保你避免要求用户过早地发布信息。最好的策略是使用具有独立几个阶段的承诺方案 [Commitment scheme - Wikipedia](https://en.wikipedia.org/wiki/Commitment_scheme) ：第一个阶段使用哈希值(hash（choose-value）)进行承诺，并在稍后的阶段reveal这些数值。  
  
例子：
  
- 在剪刀石头布游戏中，要求双方玩家先提交他们打算采取的行动的hash，然后要求双方玩家提交他们的行动；如果提交的行动与哈希值不一致，就把它扔掉。  
- 在拍卖中，要求玩家在初始阶段提交他们的出价的哈希值（以及大于他们的出价的保证金），然后在第二阶段提交他们的拍卖出价值。  
- 当开发一个依赖随机数生成器的应用程序时，其顺序应该总是：（1）玩家提交动作，（2）生成随机数，（3）玩家支付。产生随机数的方法本身就是一个活跃的研究领域；目前最好的解决方案包括比特币区块头（通过http://btcrelay.org 进行验证）、hash-commitment-reveal方案（即一方产生一个数字，公布其哈希值以 "承诺 "该值，然后随后reveal该值）和RANDAO [randao/randao: RANDAO: A DAO working as RNG of Ethereum (github.com)](https://github.com/randao/randao) 。由于以太坊是一个确定性的协议，协议内的任何变量都不能被用作不可预测的随机数。另外，要注意的是，矿工在某种程度上控制着block.blockhash()值。  [contract design - When can BLOCKHASH be safely used for a random number? When would it be unsafe? - Ethereum Stack Exchange](https://ethereum.stackexchange.com/questions/419/when-can-blockhash-be-safely-used-for-a-random-number-when-would-it-be-unsafe) 

更多请参考 [[ETH之随机性和RANDAO]]
  
#### 不可靠的参与者

不要让退款或索赔过程依赖于特定的一方执行特定的行动，而没有其他的方式将资金取出。例如，在石头剪刀布游戏中，一个常见的错误是在双方都提交自己的动作之前不进行赔付；然而，一个恶意的玩家可以通过简单地从不提交自己的动作来 "恶心 "对方--事实上，如果一个玩家看到其他玩家透露的动作并确定他们输了，他们根本就没有理由提交自己的动作。这个问题也可能出现在国家频道结算的背景下。当这种情况成为一个问题时，（1）提供一种规避不参与游戏的参与者的方法，也许是通过时间限制，以及（2）考虑增加经济激励，使参与者在所有他们应该提交信息的情况下提交信息。

#### 有符号整数的负数

Solidity 提供了几种类型来处理有符号的整数。像大多数编程语言一样，在Solidity中，一个有符号的N位整数可以代表从`-2^(N-1)`到`2^(N-1)-1`的值。这意味着`MIN_INT`没有正数的等价物。负数的实现是寻找一个数字的二进制补码，所以最负的数字的负数会产生相同的数字。[Two's complement - Wikipedia](https://en.wikipedia.org/wiki/Two%27s_complement#Most_negative_number) 

这对Solidity中所有的有符号整数类型（`int8`, `int16`, ..., `int256`）都是如此。

```d
contract Negation {
    function negate8(int8 _i) public pure returns(int8) {
        return -_i;
    }

    function negate16(int16 _i) public pure returns(int16) {
        return -_i;
    }

    int8 public a = negate8(-128); // -128
    int16 public b = negate16(-128); // 128
    int16 public c = negate16(-32768); // -32768
}
```

一种处理方法是在负数(Negation)前检查变量的值，如果等于`MIN_INT`就扔掉。另一个办法是通过使用容量更大的类型（例如`int32`而不是`int16`），确保永远不会出现最负的数字。

在`MIN_INT`乘以或除以`-1`时，会出现与`int`类型类似的问题。

### 预防措施

#### 常规措施

这里没什么，跟之前一节所说的差不多 [[#通用哲学观]]

#### 可升级性

> 注意： 智能合约的可升级性是一个活跃的研究领域。有许多重要的问题，以及与智能合约可升级性有关的风险。做好对技术现状的研究。我们欢迎对相关问题进行讨论。[Improve upgradeability section · Issue #164 · ConsenSys/smart-contract-best-practices (github.com)](https://github.com/ConsenSys/smart-contract-best-practices/issues/164) 

如果发现错误或需要改进，就需要修改代码。发现一个错误，但没有办法处理它是不好的。  
  
为智能合约设计一个有效的升级系统是一个积极研究的领域，我们无法在本文中涵盖所有的复杂情况。然而，有两种基本方法是最常用的。这两种方法中比较简单的是有一个注册合约，持有合同的最新版本的地址。对合约用户来说，一个更无缝的方法是有一个合同，将调用和数据转发到最新版本的合同上。  
  
无论采用什么技术，重要的是要有模块化和组件之间的良好分离，这样代码的改变就不会破坏功能，不会出现孤儿数据，也不会需要大量的成本来移植。特别是，将复杂的逻辑与你的数据存储分开通常是有益的，这样你就不必为了改变功能而重新创建所有的数据。  [[可升级合约#代理升级模式]]
  
有一个安全的方式让各方决定升级代码也很关键。根据你的合约，代码的改变可能需要由一个受信任的一方，一组成员，或全套利益相关者的投票来批准。如果这个过程可能需要一些时间，你要考虑是否有其他的方法在发生攻击时能更快地做出反应，如紧急停止或断路器。  
  
无论你的方法是什么，重要的是要有一些方法来升级你的合同，否则当合同中不可避免的错误被发现时，它们将变得无法使用。  

##### 1. 使用注册合约来存储合约的最新版本

在这个例子中，调用没有被转发，所以用户应该在每次与之互动之前获取当前地址。

```d
pragma solidity ^0.5.0;

contract SomeRegister {
    address backendContract;
    address[] previousBackends;
    address owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner)
        _;
    }

    function changeBackend(address newBackend) public
    onlyOwner()
    returns (bool)
    {
        if(newBackend != address(0) && newBackend != backendContract) {
            previousBackends.push(backendContract);
            backendContract = newBackend;
            return true;
        }

        return false;
    }
}

```

##### 2. 使用delegatecall来转发数据和调用

这种方法依赖于使用fallback函数（在`Relay`合约中），使用delegatecall将调用转发给目标合约（`LogicContract`）。记住，delegatecall https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries 是Solidity中的一个特殊函数，它在调用合约（Relay）的上下文中执行被调用地址（LogicContract）的逻辑，所以 "存储、当前地址和余额仍然指调用合约，只是代码取自被调用地址"。

```d
pragma solidity ^0.5.0;

contract Relay {
    address public currentVersion;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    constructor(address initAddr) {
        require(initAddr != address(0));
        currentVersion = initAddr;
        owner = msg.sender; // this owner may be another contract with multisig, not a single contract owner
    }

    function changeContract(address newVersion) public
    onlyOwner()
    {
        require(newVersion != address(0));
        currentVersion = newVersion;
    }

    fallback() external payable {
        (bool success, ) = address(currentVersion).delegatecall(msg.data);
        require(success);
    }
}

```


```d
contract LogicContract {
    address public currentVersion;
    address public owner;
    uint public counter;

    function incrementCounter() {
        counter++;
    }
}

```

这种模式的简单版本不能从`LogicContract`的函数中返回值，只能转发，这限制了它的适用性。更复杂的实现试图通过内联汇编代码和返回大小的注册表来解决这个问题。它们通常被称为代理模式 [[可升级合约#代理升级模式]] ，但也被称为Router [PeterBorah/ether-router: Upgradeable smart contracts on Ethereum (github.com)](https://github.com/PeterBorah/ether-router) 、Dispatcher https://gist.github.com/Arachnid/4ca9da48d51e23e5cfe0f0e14dd6318f 和Relay。每种实现方式都引入了一系列不同的复杂性、风险和限制。

你必须非常小心地对待你用这种方法存储数据的方式。如果你的新合约的存储布局与第一个合约不同，你的数据可能最终会被破坏。当使用`delegatecall`的更复杂的实现时，你应该仔细考虑和理解以下问题

-   How the EVM handles the [layout of state variables in storage](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html), including packing multiple variables into a single storage slot if possible
-   How and why [the order of inheritance](https://github.com/OpenZeppelin/openzeppelin-sdk/issues/37) impacts the storage layout
-   Why the called contract (`LogicContract`) must have the same storage layout of the calling contract (`Relay`), and only append new variables to the storage (see [Background on delegatecall](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/))
-   Why a new version of the called contract (`LogicContract`) [must have the same storage layout as the previous version](https://github.com/OpenZeppelin/openzeppelin-sdk/issues/37), and only append new variables to the storage
-   [How a contract's constructor can affect upgradeability](https://blog.openzeppelin.com/towards-frictionless-upgradeability/)
-   How the ABI specifies [function selectors](https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html?highlight=signature#function-selector) and how [function-name collision](https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357) can be used to exploit a contract that uses `delegatecall`
-   How `delegatecall` to a non-existent contract will return true even if the called contract does not exist. For more details see [Breaking the proxy pattern](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/) and Solidity docs on [Error handling](https://solidity.readthedocs.io/en/latest/control-structures.html#error-handling-assert-require-revert-and-exceptions).
-   Remember the [importance of immutability to achieve trustlessness](https://consensys.net/diligence/blog/2019/01/upgradeability-is-a-bug/)

[Contract upgrade anti-patterns | Trail of Bits Blog](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/) 

> 其实小节的本意就是编写可升级合约要注意的地方罢了 [[可升级合约#编写可升级合约]]

#### 断路器

断路器在满足某些条件的情况下停止执行，在发现新的错误时，断路器可以发挥作用。例如，如果发现了一个错误，合同中的大多数行动可能被暂停，现在唯一活跃的行动是撤回。你可以给某些受信任的人以触发断路器的能力，否则就有程序化的规则，在满足某些条件时自动触发某些断路器。

```d
bool private stopped = false;
address private owner;

modifier isAdmin() {
    require(msg.sender == owner);
    _;
}

function toggleContractActive() isAdmin public {
    // You can add an additional modifier that restricts stopping a contract to be based on another action, such as a vote of users
    stopped = !stopped;
}

modifier stopInEmergency { if (!stopped) _; }
modifier onlyInEmergency { if (stopped) _; }

function deposit() stopInEmergency public {
    // some code
}

function withdraw() onlyInEmergency public {
    // some code
}
```

> 以上代码本质就是一个开关，就是在启用断路器的情况下，不能继续存款了，但是可以取款

#### 减速器

减速器减缓了行动，因此，如果发生恶意行动，有时间恢复。例如，The DAO [blockchainsllc/DAO: The Standard DAO Framework, including Whitepaper (github.com)](https://github.com/blockchainsllc/DAO) 要求在成功请求分裂DAO和能够分裂之间有27天的时间。这确保了资金被保存在合约内，增加了恢复的可能性。在The DAO的案例中，在减速带给出的时间内没有可以采取的有效行动，但与我们的其他技术相结合，它们可以相当有效。

```d
struct RequestedWithdrawal {
    uint amount;
    uint time;
}

mapping (address => uint) private balances;
mapping (address => RequestedWithdrawal) private requestedWithdrawals;
uint constant withdrawalWaitPeriod = 28 days; // 4 weeks

function requestWithdrawal() public {
    if (balances[msg.sender] > 0) {
        uint amountToWithdraw = balances[msg.sender];
        balances[msg.sender] = 0; // for simplicity, we withdraw everything;
        // presumably, the deposit function prevents new deposits when withdrawals are in progress

        requestedWithdrawals[msg.sender] = RequestedWithdrawal({
            amount: amountToWithdraw,
            time: block.timestamp
        });
    }
}

function withdraw() public {
    if(requestedWithdrawals[msg.sender].amount > 0 && block.timestamp > requestedWithdrawals[msg.sender].time + withdrawalWaitPeriod) {
        uint amountToWithdraw = requestedWithdrawals[msg.sender].amount;
        requestedWithdrawals[msg.sender].amount = 0;

        require(msg.sender.send(amountToWithdraw));
    }
}

```

#### 速率限制

速率限制停止或需要批准重大变化。例如，存款人可能只被允许在某一时间段内提取一定数额或总存款的百分比（例如，在1天内最多提取100个乙醚）--在该时间段内的额外提取可能会失败或需要某种特别批准。或者速率限制可以是在合约层面，在一个时间段内，合约只发行一定数量的代币。

```d
uint internal period; // how many blocks before limit resets
uint internal limit; // max ether to withdraw per period
uint internal currentPeriodEnd; // block which the current period ends at
uint internal currentPeriodAmount; // amount already withdrawn this period

constructor(uint _period, uint _limit) public {
    period = _period;
    limit = _limit;

    currentPeriodEnd = block.number + period;
}

function withdraw(uint amount) public {
    // Update period before proceeding
    updatePeriod();

    // Prevent overflow
    uint totalAmount = currentPeriodAmount + amount;
    require(totalAmount >= currentPeriodAmount, 'overflow');

    // Disallow withdraws that exceed current rate limit
    require(currentPeriodAmount + amount < limit, 'exceeds period limit');
    currentPeriodAmount += amount;
    msg.sender.transfer(amount);
}

function updatePeriod() internal {
    if(currentPeriodEnd < block.number) {
        currentPeriodEnd = block.number + period;
        currentPeriodAmount = 0;
    }
}

```

#### 部署

合约应该有一个相当长的测试期--在大量资金被置于风险之中之前。

至少，你应该

- 有一个完整的测试套件，具有100%的测试覆盖率（或接近于此）。
- 在你自己的测试网上进行部署
- 在公共测试网上部署，并进行大量的测试和错误悬赏。
- 详尽的测试应该允许各种玩家与合约进行大量的互动。
- 在主网上部署测试版，对风险金额进行限制

> 然而，做到这点的合约项目方太少了，Github上充斥着大量缺少文档，缺少单元测试的合约项目，大量的合约项目互相抄袭借鉴，没有漏洞才见鬼了

在测试过程中，你可以通过阻止任何动作，在一定的时间段后，强制进行自动废止。例如，一个阿尔法合约可以工作几个星期，然后自动关闭所有的动作，除了最后的退出。

```d
modifier isActive() {
    require(block.number <= SOME_BLOCK_NUMBER);
    _;
}

function deposit() public isActive {
    // some code
}

function withdraw() public {
    // some code
}

```

在早期阶段，你可以限制任何用户（或整个合约）的以太币数量 - 减少风险。

#### 安全庇护所

[Safe Haven - Ethereum Smart Contract Best Practices (consensys.github.io)](https://consensys.github.io/smart-contract-best-practices/development-recommendations/precautions/safe-haven/) 

### solidity语言相关



### Token代币相关

### 文档

## 攻击

## 安全工具



